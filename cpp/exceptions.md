# Basics

C++ offers _exceptions_ as the preferred alternative to `setjmp` and `longjmp`. Exceptions are the proper way to bail out of a situation which cannot be handled easily by a function itself, but which is not disastrous enough for a program to terminate completely.

In C++, anything having value semantics may be thrown as an exception. There also exists a standard exception type. A program terminates when an exception reaches the boundary of the global `try` block (generated by the runtime support system by which all of the program's code is itself surrounded), and when this happens destructors of local and global objects that were alive at the point where the exception was generated are _not_ called!  All exceptions should be generated within a `try`-block explicitly defined by the program. Immediately following try `try`-block, one or more `catch`-clause must be defined. It's best to put a `catch` clause for most general exception last. C++ does not support a Java-style `finally` clause activate after completing a catch clause. Since a program is always surrounded by a global `try` block, `throw` statements may appear anywhere in the code.

The destructor of objects can easily be skipped through `setjmp` and `longjmp`. Exceptions provide a means to break a function's normal flow without having to use a cascade or `return`, and without the need to terminate the program using blunt tools like `exit`. Exceptions do not disrupt the proper activation of destructors.

Objects defined locally in functions are automatically destroyed once exceptions thrown by these functions leave these functions, which also happens to objects thrown as exceptions. The thrown object is copied to the outer caller and reconstructed there. Don't throw pointers to local objects.

An `Exception` object might support stream-like insertion operations:

```cpp
if (!lookup(variableName))
    throw Exception() << "Undefined variable" << variableName;
```

objects that were successfully constructed within the try block before executing the throw statement are destroyed before any exception handler’s code is executed.

An exception catcher may decide to ignore the exception, to process the exception, to rethrow it after inspection or to change it into another kind of exception. By placing an empty `throw` statement in the exception handler’s code the received exception is passed on to the next level that might be able to process that particular type of exception. The rethrown exception is always transferred to an exception handler at a more superficial level.

In general pointers should not be thrown as exceptions. If dynamically allocated memory must be passed to an exception handler then the pointer should be wrapped in a smart pointer.  the order of the catchers is not important for types not having any hierarchal relationship to each other (i.e., int is not derived from double; string is not derived from an NTBS).

```cpp
#include <iostream>
using namespace std;

int main()
{
    while (true)
    {
        try
        {
            string s;
            cout << "Enter a,c,i,s for ascii-z, char, int, string "
                                                      "exception\n";
            getline(cin, s);
            switch (s[0])
            {
                case 'a':
                    throw "ascii-z";
                case 'c':
                    throw 'c';
                case 'i':
                    throw 12;
                case 's':
                    throw string();
            }
        }
        catch (string const &)
        {
            cout << "string caught\n";
        }
        catch (char const *)
        {
            cout << "ASCII-Z string caught\n";
        }
        catch (double)
        {
            cout << "isn't caught at all\n";
        }
        catch (int)
        {
            cout << "int caught\n";
        }
        catch (char)
        {
            cout << "char caught\n";
        }
    }
}
```

```bash
 djn-pc  djn-pc-lenovo  ../yo/exceptions/examples  ./a.out 
Enter a,c,i,s for ascii-z, char, int, string exception
a
ASCII-Z string caught
Enter a,c,i,s for ascii-z, char, int, string exception
c
char caught
Enter a,c,i,s for ascii-z, char, int, string exception
i
int caught
Enter a,c,i,s for ascii-z, char, int, string exception
s
string caught
Enter a,c,i,s for ascii-z, char, int, string exception
```

This default exception handler (`catch(...)`, placed behind all catchers)cannot determine the actual type of the thrown exception and cannot determine the exception’s value but it may execute some statements, and thus do some default processing. 

In multi-threaded programs (cf. chapter 20), thrown exceptions can be transferred between threads after converting `std::exception` objects to `std::exception_ptr` objects.

__(Removed in C++17)__ A function may specify a function throw list or exception specification list specifying the types of the exceptions that can be thrown by the called function. 

```cpp
throw ()
throw (type)
throw (type1, type2, type3 ...)
```

Once a function throw list has been specified its function may only throw exceptions of the types mentioned in its throw list. A runtime error occurs if such a function throws exceptions of types not specified in its function throw list. A function without a throw list may throw any kind of exception. Without a function throw list the program’s designer is responsible for providing the correct handlers.

 Declaring exception throwers does not imply that the compiler checks whether an improper exception is thrown. Rather, the function for which a function throw list has been specified is surrounded by additional code in which the actually thrown exception is inspected: if the exception is of a type that is listed in the function’s throw list then that exception is rethrown; otherwise a run-time error is thrown. Instead of compile-time checks you get run-time overhead, resulting in additional code (and execution time) that is added to the function’s code

Although function throw lists are deprecated, `noexcept` is not. The `noexcept` keyword is used where previously empty function throw lists were used. when violating `noexcept` it results in `std::terminate`, ending the program. `noexcept` can be given an argument that is evaluated compile-time: if the evaluation returns true then the `noexcept` requirement is used; if the evaluation returns false, then the `noexcept` requirement is ignored.
