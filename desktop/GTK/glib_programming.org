#+title: Glib_programming


A general-purpose lbirary that provides many kinds of utility functions, data
types and wrappers functions.

* Basic Data Types

- =gboolean= (=TRUE=, =FALSE=, an =int=); =gchar=, =guchar=, =gconstpointer=,
  =gdouble=, =gfloat=, =g(u)int=, =g(u)int8=, =g(u)int16= ..., =g(u)long=,
  =gpointer=, =gsize=, =gssize=
  + some limit macros are available

- =G_GINT64_CONSTANT()=, =G_GUINT64_CONSTANT()=: 64-bit integer literals

* Standard Macros

- =ABS()=; =CLAMP()=; =MIN()=, =MAX()=

- =G_DIR_SEPARATOR=, =G_DIR_SEPARATOR_S=

- Type Conversions: =GINT_TO_POINTER()=, =GPOINTER_TO_INT()= ...

- Some constants: =G_E=, =G_PI= ...

* Error Reporting and Handling

Using =GError= and a set of conventions for recoverable runtime errors.

- =g_set_error()=, =g_set_error_literal()=: creates an error and assigns it to a
  variable. this pair is safe in that they check if the destination is actually
  an error or =NULL=.

- =g_error_matches()=: check for a specific type of error.

- =g_propagate_error()=: transfers the ownership of an error to another
  variable.

- =g_clear_error()=: free an errror and set the variable to =NULL=.

- When using libc functions, pair with =g_strerror()= to translate =errno=.

** Basic Rules

- A =GError*= must be initialized to =NULL= before passing its address to a
  function that can report errors to indicate a clear status before any error occurs.

- the last non-varargs argument is the =GError**= type.
  =NULL= is passed in if the caller ignores any error.

- control flow should not be affected by whether the caller wnats a =GError=.

- if a =GError= is reported, any out arguments are not defined to be valid.

- clear an error before reusing a =GError*= variable.

- =g_return_if_fail(error == NULL || *error == NULL)= should be put at the beginning
  of a =GError=-reporting function to ensure a valid destination for the
  =GError*=

- avoid using a boolean return value that indicate some other meaning than
  success/failure when paired with =GError= (under which case, a =gboolean*=
  parameter should be used). If a failure =FALSE= is returned, then the =GError=
  parameter must be set to a non-=NULL= value.

** Warnings and Assertions

Contract-based Programming: When using contracts, a supplier should not try to
verify that the contract conditions are satisfied. They simply assume that.

- preconditions (expected), invariants (maintained), postconditions (guaranteed)

- =g_return_if_fail()=; =g_return_val_if_fail()=; =g_return_if_reached()=,
  =g_return_val_if_reached()=:
  even with a =return=, these macros try to log messages if failed. A function
  is guaranteed to return if =G_DISABLE_CHECKS= is defined.

- =g_warn_if_fail()=, =g_warn_if_reached()=

- =g_on_error_query()=, =g_on_error_stack_trace()=, =G_BREAKPOINT()=: for debug only

* Message Logging

Any type of textual message can be conveyed using =g_log()=.

- =g_messsage()=, =g_warning()=, =g_critical()=, =g_error()= and =g_debug()= for the sake of convenience, emitted under the =G_LOG_DOMAIN=. Some types of messages can be set fatal using =g_log_set_always_fatal=. By default, only =G_LOG_LEVEL_ERROR= messages are fatal.

* Memory Management

** The =g_malloc()= Family

Various typed and untyped wrappers around =malloc= and =realloc=. Must be used
with =g_free()=.

- =g_clear_pointer()=: a useful helper to clean up a generic resource.

- =g_steal_pointer()=: not very useful for common C scenarios (useful only to
  save some typing), but typically
  with =g_autoptr=.

** Memory Slices

The advantage of using memory slices is that they avoid memory waste and fix
scalability and performance problems that plagued memory chunks,
achieved by using slab allocation. One constraint of memory slices is that
the size of the object must be the same size when it was allocated and when it
is freed.

It is recommended to use the new =g_slice= API instead of =g_malloc()= and friends,
as long as objects are not resized during their lifetime and the object size
used at allocation time is still available when freeing.

** Reference Counting

- =grefcount=, =gautomicrefcount=: opaque types that implement refcount
  semantics.

- RcBox and ARcBox: refcounted memory block.
  + =GRefString=: refcounted string type.

* Utilities

=g_get_current_dir()=, =g_get_home_dir()=, =g_get_host_name()=,
=g_get_real_name()=; =g_get_tmp_dir()=; =g_get_user_name()=; =g_setenv()=;
=g_getenv()=; =g_unsetenv()=

- =GDate=: a Julian (starts with 1-1-1 though) and day-month-year representation of the date, ranging from
  1-1-1 to year 8000 or so.

- =GTimeZone=: time zone structure. With a set of /intervals/ and their abbreviations, a timezone
  identifier, a daylight saving time flag.

- =GDateTime=: date time structure with timezone info, from 0001-01-01T00:00:00
  to 9999-12-31T23:59:59.999999. Microsecond precision.

- =GTimer=: more like a stop watch.

** String

- ASCII character function

- string copy; string concatenation; string generation; substring search (including prefix/suffix
  search);

- =g_printf= family

*** Unicode

- Unichar equivalents of =ctype.h= and some Unicode-specific functions

- UTF-8 specific functions

- UTF-8 UTF-16 UTF-32 conversion

*** CharSet Conversion

- =g_convert()= family

- =g_iconv_= family

* File Manipulation

#+BEGIN_SRC C
#include <glib.h>

gchar *filename, *content;
gsize bytes;
GError *error = NULL;

filename = g_build_filename(g_get_home_dir(), "temp", NULL);
g_file_set_contents(filename, "Hello World", 1 &error);
handle_error(error);

if (!g_file_test(filename, G_FILE_TEST_EXISTS))
    g_error("Error: File does not exist!");

g_file_get_contents(filename, &content, &bytes, &error);
handle_error(error);
g_print("%s\n", content);

g_free(content);
g_free(filename);
#+END_SRC

#+BEGIN_SRC C
GDir *dir = g_dir_open(g_get_home_dir(), 0, NULL);

if (!g_file_test(g_get_home_dir(), G_FILE_TEST_IS_DIR))
    g_error(...)

const gchar *file;
while ((file = g_dir_read_name(dir)))
    g_print("%s\n", file);

g_dir_close(dir);
#+END_SRC

=g_rename()=; =g_remove()=; =g_rmdir()=; =g_mkdir()=; =g_chdir()=; =g_chmod()=


* The Main Loop

TODO


* Timeouts Functions

Methods that are called at certain interval time until =FALSE= is returned.

#+include "gtk_c/timeouts.c" src

* Idle Functions

A function that will be called when there are no events pending

=g_idle_add()=, =g_idle_add_full()=

* Data Types

- =GString=: a byte array specialized for UTF-8 null-terminated character string.

- =GTree=: a balanced binary tree

* I/O Channels

- =GIOChannel=: handle files, pipes and sockets

* Threading

** Threads, Mutexes, Conditional Variable, and Others

Modeled on pthreads.

** Thread Pools

a pretty primitive thread pool.

- =g_thread_pool_new()=, =g_thread_pool_free()=

- =g_thread_pool_push()=
