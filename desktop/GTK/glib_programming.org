#+title: Glib_programming
* Error Reporting and Handling

Using =GError= and a set of conventions for recoverable runtime errors.

- =g_set_error()=, =g_set_error_literal()=: creates an error and assigns it to a
  variable. this pair is safe in that they check if the destination is actually
  an error or =NULL=.

- =g_error_matches()=: check for a specific type of error.

- =g_propagate_error()=: transfers the ownership of an error to another
  variable.

- =g_clear_error()=: free an errror and set the variable to =NULL=.

- When using libc functions, pair with =g_strerror()= to translate =errno=.

** Basic Rules

- A =GError*= must be initialized to =NULL= before passing its address to a
  function that can report errors to indicate a clear status before any error occurs.

- the last non-varargs argument is the =GError**= type.
  =NULL= is passed in if the caller ignores any error.

- control flow should not be affected by whether the caller wnats a =GError=.

- if a =GError= is reported, any out arguments are not defined to be valid.

- clear an error before reusing a =GError*= variable.

- =g_return_if_fail(error == NULL || *error == NULL)= should be put at the beginning
  of a =GError=-reporting function to ensure a valid destination for the
  =GError*=

- avoid using a boolean return value that indicate some other meaning than
  success/failure when paired with =GError= (under which case, a =gboolean*=
  parameter should be used). If a failure =FALSE= is returned, then the =GError=
  parameter must be set to a non-=NULL= value.

** Warnings and Assertions

Contract-based Programming: When using contracts, a supplier should not try to
verify that the contract conditions are satisfied. They simply assume that.

- preconditions (expected), invariants (maintained), postconditions (guaranteed)

- =g_return_if_fail()=; =g_return_val_if_fail()=; =g_return_if_reached()=,
  =g_return_val_if_reached()=:
  even with a =return=, these macros try to log messages if failed. A function
  is guaranteed to return if =G_DISABLE_CHECKS= is defined.

- =g_warn_if_fail()=, =g_warn_if_reached()=

- =g_on_error_query()=, =g_on_error_stack_trace()=, =G_BREAKPOINT()=: for debug only

* Memory Management

** The =g_malloc()= Family

Various typed and untyped wrappers around =malloc= and =realloc=. Must be used
with =g_free()=.

- =g_clear_pointer()=: a useful helper to clean up a generic resource.

- =g_steal_pointer()=: not very useful for common C scenarios (useful only to
  save some typing), but typically
  with =g_autoptr=.

** Memory Slices

The advantage of using memory slices is that they avoid memory waste and fix
scalability and performance problems that plagued memory chunks,
achieved by using slab allocation. One constraint of memory slices is that
the size of the object must be the same size when it was allocated and when it
is freed.

It is recommended to use the new =g_slice= API instead of =g_malloc()= and friends,
as long as objects are not resized during their lifetime and the object size
used at allocation time is still available when freeing.

** Reference Counting

- =grefcount=, =gautomicrefcount=: opaque types that implement refcount
  semantics.

- RcBox and ARcBox: refcounted memory block.
  + =GRefString=: refcounted string type.

* Utilities

=g_get_current_dir()=, =g_get_home_dir()=, =g_get_host_name()=,
=g_get_real_name()=; =g_get_tmp_dir()=; =g_get_user_name()=; =g_setenv()=;
=g_getenv()=; =g_unsetenv()=

- =GDate=: a Julian (starts with 1-1-1 though) and day-month-year representation of the date, ranging from
  1-1-1 to year 8000 or so.

- =GTimeZone=: time zone structure. With a set of /intervals/ and their abbreviations, a timezone
  identifier, a daylight saving time flag.

- =GDateTime=: date time structure with timezone info, from 0001-01-01T00:00:00
  to 9999-12-31T23:59:59.999999. Microsecond precision.

- =GTimer=: more like a stop watch.

** String

- ASCII character function

- string copy; string concatenation; string generation; substring search (including prefix/suffix
  search);

- =g_printf= family
* Threading

** Threads, Mutexes, Conditional Variable, and Others

Modeled on pthreads.

** Thread Pools

a pretty primitive thread pool.

- =g_thread_pool_new()=, =g_thread_pool_free()=

- =g_thread_pool_push()=
