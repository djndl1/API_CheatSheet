#+SETUPFILE: https://fniessen.github.io/org-html-themes/setup/theme-readtheorg.setup

* Introduction

** Peak Finding (1D Version)

- Formulation: Suppose there is an array of integers. The problem is to find a peak 
(the numbers that are larger than or equal to their neighbors).

#+INCLUDE: "python-implementation/peak_finder_1d.py" src python

- ~naive_peak_finder_1d~: $\Theta(n)$ 

- ~recursive_peak_finder_1d~: $Theta(\log_{2) n$

** Peak Finding (2D Version)

- Formulation: $a$ is a 2D-peak 
iff $a$ is greater than or equal to all its neighbors (the four cells around it).

#+INCLUDE: "python-implementation/peak_finder_2d.py" src python

- ~greedy_ascent_peak_finder~: worst case $\Theta(nm)$

** Models of Computation (the mathematical analog to a computer)

Algorithm: mathematical abstraction of computer program, computational procedure to solve a problem

Specifies what operations an algorithm is allowed, cost (time, space ...) of each operation, cost of algorithm = sum of operations costs

Some other analogs:

- program <-> algorithm

- programming languages <-> pseudocode

- computer <-> model of computation

*** Some Models 

A way of structuring the thinking about how an algorithm is written, s
imilar to how programming styles structure a program.

**** Random Access Machine

Basically what assembly programming is, ignoring caching. A realistic and powerful model.

Every basic objects is assumed to fit into a word.

+ having random access memory

+ load/store a word from/in memory, do computations in registers in constant time

**** Pointer Model

A more abstract model but simpler. Dynamic memory allocation has been taken cared of already. 
It can be implemented with a RAM and many data structures are built this way.

A field is either a word, which stores a basic object, or a pointer (reference). 
The only operation allowed on pointers is to follow them, which costs constant time.

**** The Python Model

Offers both the above models.

- =list=: random-access array, but appending an element takes nearly constant time
 through table doubling

- Pointer-machine style OOP

- =L.sort()= takes $\Theta(\left| n\right| \log\left|n\right|)$ via comparison sort

- =len(L)=: constant time

** Reading Notes

Chap.1, Chap.3, D.1

*instance of the problem*: the input that satisfies the constraints of the problem

*data structure*: a way to store and organize data in order to facilitate access and modifications.

Algorithims considered as a technology, total system performance depends on choosing
 efficient algorithms as much as on choosing fast hardware. 
Algorithims are at the core of most technologies used in contemporary computers.


*** Pseudocode conventions

1. indentation indicates block structure;

2. The loop counter retains its value after exiting the loop and the counter is beyond the final value. ~to~ incremets the counter and ~downto~ decrements.

3. Variables are local to the given procedure.

4. Compound data are organized into *objects*, which are composed of attributes, ~A.length~. 
A variable representing an array or object represents a pointer/reference to the data representing the array or object. Null pointer is denoted as ~NIL~.

5. Parameters are passed by value in nature.

6. ~and~, ~or~ are short circuiting.

*** Growth of Functions

For large enough inputs, the asymptotic efficiency of algorithms is 
more of concern.

**** Asymptotic Notation

Typically confined to $\mathbb{N}$.

- \Theta-notation: For a given function $g(n)$

$$
\Theta \left(g\left(n\right)\right)=\left\{ f \left(n \right)\colon\exists c_{1}>0,c_{2}>0\text{ and }n_{0}\in\mathbb{N}\text{ s.t. }0\leq c_{1}g\left(n\right)\leq f\left(n\right)\leq c_{2}g\left(n\right)\text{ for all } n\geq n_{0} \right\} 
$$

where $f(n)$ and $g(n)$ are required to be /asymptotically nonnegative/ 
(nonnegative whenever $n$ is sufficient large). $g(n)$ is said to be
 an /asymptotically tight bound/ for $f(n)$.

Conventionally, we write $f(n) = \Theta(g(n))$ instead of $f(n) \in \Theta(g(n))$.

The lower-order terms and the coefficient of the highest-order term
of an asymptotically positive function can be ignored in determining
asymptotically tight bounds.

- The /O/-notation is for an symptotic upper bound, a superset of the
\Theta-notation. When used to bound the worst-case running time,
 it is a bound on the running time of the algorithm on every input.
\Theta-notation bound on the worst-case running time does not imply
 a \Theta bound on the running time on every input.

- The \Omega-notation provides an /asymptotic lower bound/.

e.g. For the insertion sort algorithm, the worst-case running time
is $\Omega(n^{2})$, although a best-case runs in $\Theta(n)$ time. 
It is an abuse to say that the running time of insertion sort is 
$O(n^{2})$, since for a given $n$, the actual running time varies,
depending on the particular input of size. "The running time is 
$O(n^2)$" means there is a function that is $O(n^2)$ s.t. for any 
 value of $n$, the running time on that input is bounded from above
by the value $f(n)$.

- /o/-notation: an upper bound that is not asymptotically tight, 
defined as

$o(g(n)) = \{ f(n):$ for *any* positive constant $c > 0$, there exists
 a constant $n_{0} > 0$ s.t. $0 \leq f(n) < cg(n)$ for all $n \geq n_{0} \}$.

Intutively, in /o/-notation, $f(n)$ becomes insignificant relative 
to $g(n)$ as $n$ approaches infinity, i.e.

$$
\lim_{n\to\infty}\frac{f\left(n\right)}{g\left(g\right)}=0
$$

which is directly from the definition.

- \omega-notation

***** Some other notation abuses

- $=$ means $\in$ for a standalone asymptotic notation

- $=$ in a large formula means that a function $f(n)$ is in that set

e.g. 

$$
2n^{2}+\Theta\left(n\right)=\Theta\left(n^{2}\right)
$$

means that for any function $f(n) \in \Theta(n)$, there is some 
function $g(n) \in \Theta(n^{2})$ s.t. $2n^{2} + f(n) = g(n)$ for all
 $n$.

***** Some Properties of Asymptotic Notation

- Transitivity for all five notations

- Reflexivity for \Theta, /O/ and \Omega.

\begin{aligned}
f\left(n\right) &	= \Theta\left(f\left(n\right)\right) \\
f\left(n\right)	& = O\left(f\left(n\right)\right) \\
f\left(n\right)	& = \Omega\left(f\left(n\right)\right)
\end{aligned}

- Symmetry: $f(n) = \Theta(g(n))$ iff $g(n) = \Theta(f(n))$.

- Transpose symmetry: 
   + $f(n) = O(g(n))$ iff $g(n) = \Omega(f(n))$
   + $f(n) = o(g(n))$ iff $g(n) = \omega(f(n))$

Not all functions are asymptotically comparable.

**** Running times comparison 

- $n^{b}=o\left(a^{n}\right)$, any exponential function with a base greeater
 than $1$ grows faster than any polynomial function.

- $\lg^{b}n=o\left(n^{a}\right)$: any positive polynomial function grows
 faster than any polylogarithmic function

- For factorial:
    + $n!=o\left(n^{n}\right)$
    + $n!=\omega\left(2^{n}\right)$
    + $\lg\left(n!\right)=\Theta\left(n\lg n\right)$

- Function iteration: a function itertively applied $i$ times to an initial 
value of $n$.

$$
f^{\left(i\right)}\left(n\right)=\begin{cases}
n & \text{if }i=0\\
f\left(f^{\left(i-1\right)}\left(n\right)\right) & \text{if }i>0
\end{cases}
$$

#+BEGIN_SRC python
# Run this in sage
n = var('n')

log2n = log(n, 2)
sqt = sqrt(n)
y = n
nlgn = n*log(n, 2)
quad = n^2
cube = n^3
expon = 2^n
factori = factorial(n)


plog2n = plot(log2n, (x, 0, 20), color='red', 
              legend_label='$\log_{2} n$')
psqt = plot(sqt, (x, 0, 20), color='cyan',
           legend_label='$\sqrt{n}$')
py = plot(y, (x, 0, 20), color='black',
         legend_label='$n$')
pnlgn = plot(nlgn, (x, 0, 20), color='blue',
            legend_label='$n \log_{2} n$')
pquad = plot(quad, (x, 0, 20), color='green',
            legend_label='$n^{2}$')
pcube = plot(cube, (x, 0, 20), color='yellow',
            legend_label='$n^{3}$', xmax=20)
pexpon = plot(expon, (x, 0, 20), color='purple',
             legend_label='$2^{n}$')
pfact = list_plot([factori(n) for n in range(20)], color='orange',
            legend_label='$n!$',ymax=50)

plog2n + psqt + py + pnlgn + pquad + pcube + pfact + pexpon

pexpon = plot(expon, (x, 0, 20), color='purple',
             legend_label='$2^{n}$')
pfact = list_plot([factori(n) for n in range(20)], color='orange',
            legend_label='$n!$', ymax=1200)
pcube = plot(cube, (x, 0, 20), color='yellow',
            legend_label='$n^{3}$', xmax=20)
pexpon + pfact + pcube
#+END_SRC


* Sorting and Trees


#+TODO: 

* Hashing

#+TODO: 

* Numerics

#+TODO: 

* Graphs

#+TODO: 

* Shortest Paths

#+TODO: 

* Dynamic Programming

#+TODO: 

* Advanced Topics

#+TODO: 
