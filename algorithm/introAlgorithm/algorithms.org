#+SETUPFILE: https://fniessen.github.io/org-html-themes/setup/theme-readtheorg.setup

* Introduction

** Peak Finding (1D Version)

- Formulation: Suppose there is an array of integers. The problem is to find a peak 
(the numbers that are larger than or equal to their neighbors).

#+INCLUDE: "python-implementation/peak_finder_1d.py" src python

- ~naive_peak_finder_1d~: $\Theta(n)$ 

- ~recursive_peak_finder_1d~: $Theta(\log_{2) n$

#+BEGIN_SRC python
peak_finder(a, 1, n)
if a[n/2] < a[n/2-1]:
    return peak_finder(a, 1, n/2-1)
elif a[n/2] < a[n/2+1]:
    return peak_finder(a, n/2+1, n)
else:
    return n/2
#+END_SRC

** Peak Finding (2D Version)

- Formulation: $a$ is a 2D-peak 
iff $a$ is greater than or equal to all its neighbors (the four cells around it).

#+INCLUDE: "python-implementation/peak_finder_2d.py" src python

- ~greedy_ascent_peak_finder~: worst case $\Theta(nm)$

- ~recursive_peak_finder_2d~: $T(n, m) + T(n, m/2) + \Theta(n)$. Worst case $\Theta(n \log m)$

** Reading Notes

*instance of the problem*: the input that satisfies the constraints of the problem

*data structure*: a way to store and organize data in order to facilitate access and modifications.

Algorithims considered as a technology, total system performance depends on choosing efficient algorithms as much as on choosing fast hardware. 
Algorithims are at the core of most technologies used in contemporary computers.

* Sorting and Trees


#+TODO: 

* Hashing

#+TODO: 

* Numerics

#+TODO: 

* Graphs

#+TODO: 

* Shortest Paths

#+TODO: 

* Dynamic Programming

#+TODO: 

* Advanced Topics

#+TODO: 
