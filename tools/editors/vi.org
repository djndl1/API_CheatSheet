* Basic Concepts

~vi~ has tow modes:

- command mode:

- insert mode:

- =ex= mode

The general form of ~vi~ commands is

#+begin_src
[(command)][(number)](text object)
[(number)][(command)](text object)
#+end_src

Where =text object= is commands like =w=, =b=, regexes etc, that is, certain
commands in vi denotes both text objects and certain related commands.

* Basic Operations

** Status Aware

- =C-g=: show the location in a file and the file status

** Motion

*** Scrolling and Paging

- ~^f~ / ~^b~ :: scroll up/down a screen

- ~^d~ / ~^u~ :: scroll up/down half screen

- ~^e~ / ~^y~ :: scroll up/down one line

- ~zENTER~ / ~z.~ / ~z-~ :: move current line to top/center/bottom of screen and scroll
  + with a line number prefixed, the command sets the specified line the anchor.

*** Go to a Position

- ~G~  :: go to the specified line/the end if none

- =``= :: get back to a previous position (not down a list).

- =mx=, =`x=, ='x= :: mark a position; return to the position; return to the
  first non-white character of the marked line.

*** Moving Around on the Screen

- =j=, =^n=;  =k=, =^p= ::

- =+=​/​=Enter=, =-= :: go down/up to the first character of the line

- =nH=, =nL= :: the screen top/bottom n line (the first if none)

- =M= :: the middle of the screen

*** Moving Within a Line

- =^= :: first non-white character.

- =0= :: beginning of the line.

- =$= :: EOL.

- =h=, =SPACE=; =l=, =BACKSPACE= (also as =^h=) ::

- =w=, =b=; =W=, =B=; ~e~, =E=  :: move to the next/last word. The upper
  case version ignores punctuation, splits words by whitespaces.

- ~n|~ :: move to column n

- ~(~​/​~)~, ~{~​/​~}~, ~[[~​/​~]]~ :: move to beginning of current/next sentence/paragraph/section

- =%= :: move to the matching parenthesis

- Commands that change text can be combined with ~/~ and ~?~ ::

- ~f~ / ~F~ / ~t~ / ~T~ / ~;~ /~,~ ::

*** High Level Text Objects

A sentence is defined as a text block ending with =.=, =!= or =?= which is followed by either the
end of a line or by at least two spaces (one in the case of vim). A paragraph begins after each empty line and
also at each a set  of paragraph macros (typically used by the =troff= system).
Sections are completely defined by macros.

- =(=, =)= :: move over the beginning of the current/next sentence

- ={=, =}= :: move over the beginning of the current/next paragraph

- =[[=, =]]= :: move to the beginning of the current/next sentence
  + works for C blocks.

** Change Text

*** Insert Mode

- =o= / =O= :: insert a newline below/above and enter the insert mode.

- =a= :: append after the cursor, =i= before the cursor; =I= and =A=: prepend/append to the
  current line.
  + insert commands may be prefixed with a count number, to indicate the
    repetition of the inserted text.
  + Under =vi=, =a= only appends, =i= only inserts: they cannot modify existing
    text and backspace deleting characters are not instantly displayed as deleted.
  + Under insert mode, =^H= is backspace, =^U= deletes the input on the current
    line; =^W= erases a word; =^I= inserts a tab; =^[= is the escape key.
  + In case some other operations are required under
    insert mode, use =^o= to access normal mode commands.

- ~ra~ :: replace the current char with ~a~, no need to enter the insert mode;
  + replace =&&= with =||=: type =2r|=

- ~R~ :: the replace mode that replaces (overstrikes) everything in its way, basically the
  INSERT key in CUA: one may even restore to normal insert mode by pressing the
  =INSERT= key.

- =Esc= or =^[= :: leaves the insert mode.

- ~c~ :: change, a combination of delete followed by insert, used with various
  motion commands.
  - =s= :: substitute the first char and then enters the insert mode.
  - ~cc~, =S= :: change the entire line
  - ~C~ ::  ~c$~
  - =ce= and =cw= :: the same even if =w= and =e= have different semantics.

- special characters :: insert a =^V= before the character.

*** Deletion

- =x=, =X= :: delete the next/previous character

- ~["x]d~ :: delete operator, used with =b=, =d=, =w= and various motion and
  search commands, optionally into register =x=.
  + ~D~ delete to the end of the line, equal to  = ~d$~
  + to delete with a search inclusively, add an offset (typically =e=) after the
    search pattern.

The editor saves the last 9 deleted blocks of text in a set of numbered
registers 1-9, accessible by ="n=.

*** Rearranging and Duplicating

There are a few special buffers (registers) provided by =vi= for temporary use:
the unnamed buffer and the named buffers.The unnamed buffer (deletion register) is lost when switching files; the named buffers (from =1= to =9= and =a= to =z=) do not, thus they may be used to transfer content from one file to another.

- ~("buffer_name)y~ :: yank (copy into a buffer, by default the unnamed one
  (deletion register), unless prefixed by
  a named buffer)

- ~p~, ~P~ :: put after/before the line/the cursor
  + =xp= :: to transpose two characters

- ~Y~ :: curiously = ~yy~, not yank to the end of the line.
  + under Neovim,  more consistently defined as =y$=

- =~= :: changing case
  + =gU{motion}= (uppercase), =gu{motion}= (lowercase)

- =<=, =>= :: combined with motion, search command to shift lines by a =shiftwidth=.
  + =<<=, =>>= shift the current line.

- =^D= and =^T= :: shift lines under insert mode, so-called tabbing.

- ~J~ :: join

** Search/Replace

*** Pattern Search

- =/=, =?= :: forward/backward search (possibly with regex). Search is also a way to move around.
  + By default, the search wraps around when it hits the end of the buffer
    unless =nowrapscan= is set.
  + By default the cursor is placed on the first character of the match. These
    patterns may be followed by an offset to put the cursor at the
    location specified by the offset: line count (positive or
    negative), =e[+/-num]= characters to the right/left of the end of the match
    (by default 0),
    =s/b[+/-num]= characters to the right/left of the match, or =;{pattern}=  to
    perform another search.
  + =/=, =?= without a pattern repeats the previous search.
  + =n=, =N= continue the search in the same/opposite direction.
  + (vim) a history of search commands is maintained, retrievable with arrow keys or =^p=, =^n=.
  + the final =/= or =?= is optional without the offset
  + use =\%>= and =\%<= to limit the search range.

- =*=, =#= :: search forward/backward for the count'th occurrence of the word nearest to the cursor.
  + a =g= prefix may be added to indicate no word boundaries.

- =^C= :: interrupt the current search command

- =fchar=, =Fchar=; =;= :: search for the next =char= forwards/backwards on the
  current line; =;=
  repeats the previous search.
  + =t= and =T= is a version of =f= that goes to the position before the searched character.
  + =;=​/​=,= repeats the previous find command in the same/opposite direction.
  + use =``= or =''= to return to the position/line before the search.

Substitution is mostly done through the =substitute= ex command.

** Undo/Redo

- ~u~: undo; ~U~: undo all on a line, ~C-r~ (vim): redo (redo an undone operation)
  + =vi='s undo may undo a previous undo.
  + =vim= adds branching undo, similar to Git commit tree and branches.

- Since the last nine deletions are saved in the nine named buffer in addition
  to the /deletion register/, use ="np= to
  retrieve them. But vim supports infinite undo.

** Other Operations

- ~:e!~ :: returns to the last saved version of the file

- ~ZZ~ / ~:wq~ ::

- ~.~ :: repeat the last command

- =%= on a paired punctuation mark ::

- =Ctrl-^= :: =:e #=

** Combination For Special Tasks

- =dwelp= :: swap the two words. Delete the word, go over the next word and a step forward, put the
  deleted word.

- =lb=, =he= :: move to the beginning/end of a word; =l=​/​=h= here guards against the case
  where the cursor is already at the beginning.

- =f(xf)x= :: delete a pair parentheses.

* ex commands and the ex mode

Originally, =vi= was the visual mode of the =ex= editor, an improved line editor
from and a superset of =ed=. Modern =ex= runs a cleared terminal, unlike =ed=,
which runs directly in the current view of the terminal. To enter =ex= mode
under visual mode, hit =Q=.

=ex= has buffers named =a= through =z=.
The =ex= editor has five modes:

- *command mode* :: the =:= prompt
  + =address command ! parameters count flags=, all parts are optional. The
    degenerate case (empty command) prints the next line in the file. Here
    =flags= are =p=, =l= or =#=, executed after the main command.
  + Most commands names are English words with prefix abbreviations. Most commands
    accept prefix addresses specifying the lines in the file upon which they are
    to have effect. A few (e.g. =delete=) may take a trailing count specifying the
    number of lines to be involved or other parameters after the command name.
  + For commands that takes a range address, the count parameter limits the
    command to the lines starting at the last line of the range with
    =count= lines involved. That is, the range address is actually invalid and only the last address number is taken.
  + commands are commented out by a double quote ="=.
  + Different elements of an =ex= command may be separated by spaces.
  + multiple commands on a single line are separated by =|= in the same way a
    semicolon separates a shell command.

- *text input mode* :: gathers input lines and places them in the file; the
  =append=, =insert= and =change= commands use text input mode. A =.= line exits
  the mode.

- *open mode* :: displays one line at a time, not really useful on modern
  terminals and monitors and they are usually not implemented. They are designed for hardcopy terminals (terminals
  that print a line to display instead of drawing on the screen) or glass TTYs
  (display terminal that behaves like a teletype printing terminal without
  cursor support).

- *visual mode*, *text insertion mode* :: vi's modes
  + type =Q= to enter =ex= mode.

** Command Addressing

Addresses may be absolute line numbers, relative line offset, special symbols
indicating some special lines or search pattern as addresses and they may be
combined: two patterns may form a range with a comma; patterns with an offset
indicates a line relative to the matching line.

- =.= :: the current line

- =n= :: the nth line

- =$= :: the last line

- =%= :: the entire buffer, equal to =1,$=, unlike ed, where comma =,= addresses the
  whole buffer.

- =+n=, =-n= :: an offset relative to the line specified before it

- =/re/=, =?re?= :: scan forward or backward respectively for a line containing
  a regex, possibly with some commands to operate on these lines. The search wraps around the end of the buffer. Without the trailing
  =/= or =?=, the command simply prints the next matching line using the regex. =//= or =??= uses the last regex.

- ='"= :: the previous current line is marked by ="=.

- Null address specification :: defaults to the current line, =1,p= prints the
  first line through the current line. This is more consistent than in =ed=, where
  =,addr= denotes =1,addr= and =addr,= denotes =addr,addr=.

- =;= is also available in =vi= to set the first address as the current line.

** Commands

- =args= :: the members of the argument list of the =ex= process

- =(.){a}ppend= ::
  + =a!= toggles autoindent

- =cd=, =chdir= :: After a =chdir= the current file is not considered edited.

- =(.,.){c}hange count= ::
  + =c!= toggles autoindent

- =(.,){co}py addr flags=, also abbreviated as =t= :: copy and put the range after =addr=

- =(.,.){d}elete (buffer) count flags= :: If a buffer name is given, the deleted
  lines are saved (lower case buffer name)/append (upper case buffer name) there.

- =(.,.)yank buffer count= :: yank the specified lines in th named buffer, if
  any, for later retrieval via =put=.

- ={e}dit=, =ex= :: clear the current clean buffer and begin an editing session on a new file.
  + =e!= :: discards changes to the buffer and reload the file.

- ={f]ile filename=, =file= ::

- =(1,$) {g}lobal /re/ commands= :: the command list may span multiple lines and
  may include =append=, =insert=, =change= commands and their associated input
  text. The global command and the undo command are not allowed in the command list.
  + =g!=, abbr. =v= :: at each line not matching the pattern

- =(.){i}nsert= ::
  + =i!= :: the autoindent version

- =(.,.+1) {j}oin count flags= ::
  + =j!=

- =(.)k x=  or =(.)mark x= :: mark a line with a letter.

- =(.,.){m}ove addr= :: move (cut and paste) the specified lines to =addr=.

- ={n}ext= :: the next file from the command line arguments is edited

- ={rew}ind= :: the argument list is rewound and the first file is edited.

With =args=, =n= and =rew=, one may switch between multiple files without leaving vi.
=last=, =prev= (vim) enhanced support for multiple files. However, moving to
another file requires a save as the buffer is cleared. =vi= remembers the
current filename as =%= and the alternate filename as =#=. They may be used with =e=, =r=, =!cmd=.

- =(.,.){nu}mber count flags=, =#= :: print with line numbers

- =(.){o}pen (/re/) flags= :: enter intraline editing open mode at each
  addressed line. =Q= to exit.

- =(.,.){p}rint count= ::

- =(.){pu}t buffer= :: puts back deleted or yanked lines, possibly from a named buffer.

- ={q}uit= ::

- =(.){r}ead file= :: If no filename is given, the current filename is used. The
  current file name is not changed unless there is none, in which case the
  specified =file= becomes the current one.

- =recover file= ::

- ={sh}ell= :: start a new shell, resume editing after the shell exits

- ={so}urce file= :: reads and executes =ex= commands from the specified file

- =(.,.) {s}ubstitute /re/replacement/ options count flags= ::
  + the address range may be replaced with a global command with a search pattern,
    under which case, =/re/= may be omitted as =//= to denote the search pattern.

    #+begin_src vim
:g/editer/s//editor/g
    #+end_src
  + =options= may be =g= global, =c= asking for confirmation
  + =&= repeats the previous substitute command with possibly different flags.
  + =~= last used search pattern in a regular search.
  + any nonalphanumeric, nonspace character except =\=, ="= and =|= may be used
    as the delimiter, especially useful when dealing with pathnames.

- =stop= :: suspends the editor

- =ta tag= :: switch the focus of editing to the location of =tag=, defined by
  the tags file, created by, for example, =ctags=.

- =! command= :: it executes a shell command but vim documentation calls it
  "filter" as it may be used to filter text in the buffer and write back into the buffer.
  + =%= and =#= in the command are expanded as in filenames.
  + if a range address is appended before =!=, that range of lines are supplied
    as stdin to the command. The possible output then replaces the original lines.
  + in =vi= mode, type =!= followed by motion operations enters this command
    with a range automatically. To operate only on the current n lines, type =!!=.

- =($)== :: prints the line number of addressed line without changing the
  current line.

- =(.){vi}sual -/^/. windows_size flags= :: enters visual mode at the specified line

- =(1,$){w}rite (>>) file/!command= :: overwrite/appends (to file only) the specified lines (by
  default the entire buffer) to a filename/command stdin.
  + =w!= overwrite an existing file.

- ={x}it! file= :: exits with changes saved if modified.

- =preserve= :: write the current buffeer into its swap and the swap file will
  not be deleted after exiting so that changes may be recovered.

- =(.+1)z window_size= :: print the next count lines, the current line is
  changed. This command is basically scroll.

- =(.)z -/./ number_of_lines= :: prints a window of text with the specified line
  at the top.
  - =-= puts the line at the bottom, =.= at the center, === also at the center
    with surrounding =-= characters.

- =(.,.) >/< count flags= :: shift the specified lines.
  + Only whitespaces are shifted; no non-white characters are discarded with a left-shift.

- (.+1, .+1) :: an address alone causes the addressed line to be printed (and
  also change the curent line).

** Pattern Matching

Ex/Vi/Vim mostly uses POSIX basic regular expression. All =vi= clones support
optional extended regular expression syntaxes. For syntax and rules of regular expressions, see [[./posix_regex.org][POSIX Regex.]]

*** Replacement Syntax

Aside from literal characters, the replacement contains a few metacharacters.

- =~= in the replacement pattern stands for the defining text of the previous
  replacement pattern.  Useful for repeating an edit.
  + also as a command to perform the previous substitution but with the previous
    search pattern (not necessarily the one used in the last substitution command).

- =#= as the replacement pattern alone specifies the previous replacement pattern.

- =&= in the replacement is replaced by the characters matched by the search pattern.
  - =&= as a command under both vi mode and ex mode (=:&=) repeats the last substitution without moving the cursor.

- =\n= (backreference): matches the text that was matched by the n-th regular
  subexpression in the search pattern.
  + in the replacement pattern, it is replaced by the text matched by the corresponding subexpression.
  + For nested expression, =n= is determined by the counting occurrences of =\(=
    starting from the left.

- =\u= and =\l= cause the immediately following character in the replacement to
  be converted to upper- and lower-case respectively.
  + =\U= and =\L= turns on the conversion until =\E= and =\e= turns it off.

- =\<=, =\>= matches the beginning/end of a word.

- Most metacharacters lose their special meaning inside brackets except =\=,
  =-=, =]= which are used by bracket expressions or as the escape marker.

- A simple =:s= is =:s//~/=, repeating the last substitution.

*** Some Pattern Matching Examples

- move a block of XML

#+begin_src ex
:g /<syntax>/.,<syntax\/>/ move /<parameters>-1/
#+end_src
 
- delete all blank lines plus any lines that contain only whitespace

#+begin_src 
:g/^[ tab]*$/d
#+end_src

- delete all leading spaces

#+begin_src 
:%s/^  *\(.*\)/\1/
#+end_src

- insert a ~>  ~ at the start of every line in a file

#+begin_src 
:%s/^/>  /
#+end_src

- reverse the order of lines in a file

#+begin_src 
:g/.*/mo0
#+end_src

- repeat a command

#+begin_src 
# copy lines 12-17 to the end of the file ten times
:1,10g/^/ 12,17t$
#+end_src

* Advanced Usage
** How To Exit

Inside Emacs or VSCode terminal, beside =Ctrl-[= and =Esc=, =Ctrl-C= escapes insert mode, =Ctrl-o= gives a
chance to execute normal mode command (in which case =ZQ= or =ZZ=).

** Read-Only Mode

=vim -R= or =view=. Use =w!= or =wq!= to force a write if necessary.

** Word Abbreviation

=:(un)abbrivate abbr expanded text=

Abbreviations expand as soon as a nonalphanumeric character is pressed.
Definitions are not recursively expanded.

** Recovery

- =vi -r name= :: recovery a file at the directory where a file is previously not written.

- Use =:{pre}serve= the buffer even if there is no crash, especially when the
  user cannot save the file, under which case preserving the file offers an
  alternative to backup the file.
  + for =vim=, it preserves the content in the =.swp= file.

** Options

#+begin_src
:set option
:set nooption
#+end_src

~:set all~ displays all options. =set option!= (vim) toggle the value of an
option. =set option?= shows the current value of the option.

Options may be set in a =.exrc= file in the home directory.

*** Useful Options

- =exec= :: enable directory-local =.exrc= settings.

- =autoindent= :: supply indentation automatically following the previous line
  upon starting a new line; useful for programming

- =autowrite= :: automatic write before =:n=, =ta= etc.

- =ignorecase= :: ignore case in searching

- =number= :: display line numbers

- =showmatch= :: show matching punctuation

- =tags= :: the tags file to be searched

- =shell= :: the shell used, by default =$SHELL=.

- =wrapmargin= :: the number of columns of a line before the line is
  automatically broken at a word boundary. Useful for nonprogram text.

- =showmode= :: the modeline

**** Search

- =incsearch= (vim) :: show where the pattern matches as the pattern is typed so far.
  + =^G=, =^T= to move to the next/previous match.

- =hlsearch= :: searched matches are highlighted. =:nohlsearch= turns highlight
  off until the next search.

**** Tabs

To debug tab problem, =set list= or use =:l= command to display tabs and spaces.

- =tabstop= :: number of spaces that a tab in the file counts for (visually and
  sometimes expanded space count). The length of
  a real tab character.

- =softtabstop= :: number of spaces that a tab in the file counts for while
  performing editing operations, i.e. a tab key in Insert mode is no longer a
  =tabstop= wide unless multiple tab keys combined reaches the width of
  =tabstop=, without =expandtab=, it becomes a real tab character.

- =expandtab= :: tabs are replaced by the appropriate number of spaces in Insert
  mode. Real tabs are inserted with =^V<Tab>=.

- =shiftwidth= :: number of spaces to use for each step of (auto)indent, for
  =cindent=, =<<=, =>>= etc.
  + used in shift commands and autoindent backtabbing.
  + =^D=, =^T= moves a shiftwidth backwards/forwards.

- =smarttab= :: use =shiftwdith= for a tab in front of a line. Probably "smart"
  in that it respects indentation width.

** Key Macros

There are two flavors of macros:

- the macro body is put in a buffer register =x=, =@x= invokes the macro.

- =:map macro macro_body= defines a key macro
  + =:map!= causes the mapping to apply to input mode.
  + special characters are input with =^V= prefixed. Vertical bar =|= can never
    be escaped as it is used as the crucial =ex= separator.
  + =:unmap= deletes a macro.
  + =#0= through =#9= mean function keys.

- Vim has an internal leader key (=\= by default, and denoted in macro
  definition as =<leader>=) for prefixing in order not to overload other
  keys. This leader key is defined with =mapleader=.

* VIM

Vi is part of POSIX, with little change over the years. Vim extended its feature
set and gained a large community around it. It emphasizes modality and touch
editing but provides features for less experienced users (=evim=, =vimtutor=,
and some third-party tutorials: OpenVim, Vim Adventures).

- Initialization and Customization with scripting and plugins
  + =_vimrc= on Win32.

- Infinite undo.

- GUI features

- Multiwindow Editing

- Autocompletion

- Syntax awareness

- Postprocessing after editing (e.g. cleanups)

- Arbitrary line length up to a C =long= integer.

- Unicode Awareness

- Binary data: no newline after at the EOF.

- Session Context: recent docuemnts, recent edits of recent files, command
  history, previous leaving location.

- Meta-information: foru special registers
  + =%=: the current filename
  + =#=: the alternate filename
  + =:= the last shell command
  + =.= the last inserted text

- the black hole register ="_=: the =/dev/null= of vim.

- Transparent editing with compressed files.

- Builtin help: the =:help= intro provides some basic usage before goint into details.
  + =Ctrl-]= jumps to the tag

** GUI gVim

Separate =.gvimrc= in =$HOME= and local directories are used for gVim only.

** Command line options

- ~-b~: in binary mode

- ~+command~ ,~c command~: execute command as an =ex= command

- ~-C~: vi-compatible mode (not fully compatible)

- ~-d~: diff mode

- ~-E~: improved ex mode, with extended regex

- ~-F~ / ~-A~: Farsi or Arabic mode

- ~-M~: turn off the write option

- ~view~: vim in read-only mode

- ~vimdiff~: diff mode

- ~ex~: ex mode, useful in scripts

** New Commands

- =n CTRL-END= :: to the end of the file

- =line_count_percent%= :: go to the line count percent into the file

- =:go n=, =:n go= :: go to the nth byte in the buffer

** New Modes

*** Visual Mode =v=

Define selections visually and perform editing commands on the visual selection.

**** Visual Block =^V=


** Extended Regex

More than POSIX ERE.

- ~\|~: indicates alternation

- ~\+~

- ~\&~: concatenation

- ~\=~: matches zero or one of the preceding regex

- ~{-(n),(m)}~: the =-= inside bound expressions indicates non-greed matching

- =\a= (alphabetica), =\A= (non-alphabetic)

- =\b= backspace

- =\d=, =\D=  digit  and non-digit

- =\e= escape

- =\f=, =-F= filename character, the latter excludes digits

- =\h=, =\H=: head-of-word character (letters and underscores), non-head-of-word character

- =\i=, =\I= identifier character (the latter excludes digits)

- =\k=, =\K= keyword character (the latter excludes digits)

- =\l=, =\L= lowercase and nonlowercase

- =\n= newline, =\r= carriage return, =\t= tab

- =\o=, =\O= octal and non-octal character

- =\p=, =\P= printable character (the latter excludes digits)

- =\s=, =\S= a tab or space

- =\u=, =\U= uppercase and non-uppercase characters

- =\w=, \W=: word character and non-word character

- =\x=, =X= hexadecimal digit and non-hexdecimal digit

- =\_x= any the of the previous characters: match the same character but with
  newline included

** Multiwindows behavior

- =-o=​/​=-oNumber=: start with multiple windows

- =:split [filename]=, =Ctrl-Ws=: split the window horizontally

- =:vnew= / =:vsplit=, =Ctrl-Wv=: vertically split the window (with a new buffer
  or the current buffer)

- =:new=, =Ctrl-Wn=: new window

Split commands may come optionally with a prefix to indicate the window size.

- =:sview filname= : open a file in a split window as readonly.

- =:sfind filename=: open a window for a file if found

- =:close=, =Ctrl-Wc=: close the current window; =:only=: close all but the current window

- =Ctrl-W= + =q=: quit a window (quit vim if no window exists); + =c=: close the
  current window until the tab is closed

- =Ctrl-W= + =o=, =:only= close all windows except the current window.

*** Conditional Split

- =topleft=, =vertical=, =leftabove=, =aboveleft=, =rightbelow=, =belowright=,
  =botright=: modifier before a split command to open a new window only if the
  command succeeeds.

*** Moving Across Windows

- =Ctrl-W= + =h,j,k,l=,

- =Ctrl-W= + =t= (top leftmost), =b= (bottom rightmost),

- =Ctrl-W= + =p= previously accessed

- =Ctrl-W= + =w=, =W=: cycle through all windows top leftmost to bottom rightmost, the case difference indicates
  different directions

*** Moving Windows & Changing Layouts

- =Ctrl-W= + =r=: rotate windows on a row/column rightwards/rightwards; + =R= in the
  opposite direction

- =Ctrl-W= + =x=: exchange the current window with the nth (by default the
  first) next one
  + exchange only happens in a row or column

- =Ctrl-W= + =K, J, H, L=: move the current window, full height/width

- =Ctrl-W= + =T=: move to a new tab

*** Change Windows Size

- =Ctrl-W= + =+=​/​=-= (=:resize=): increase/decrease the current windows
  height; + =<=​/​=>= (=:vertical resize=): decrease/increase width

- =Ctrl-W= + ===: resize all windows to equal size.

- =zCount= + =ENTER=: set the current window to =Count= lines
  + =:resize n=, or =n= + =Ctrl-W= + =_=

- =Ctrl-W= + =|=: resizes the current window width to the specified column (by
  default the widest possible)

- =Ctrl-W= + =o=: maximize a window

- =Ctrl-W= + =G=:

- =Ctrl-W= + =F=: edit the filename underneath the cursor.

=winheight=, =winwidth= defines the minimal size of the current active window,
even if the window in inactive state has a different size.

*** Tabbed Editing

- =:tabnew filename=, =:tabedit filename=

- =:tabclose=

- =:tabonly=

- =gT=, =Ctrl-PageDown=, =Ctrl-PageUp=

*** Windows and Buffers

- =:ls=, =:buffers=, =:files= lists buffers and files
  + =%= (current), =#= (alternate)
  + =u= unlisted buffer (e.g. a help buffer)
  + =a= active (loaded and visible) buffer, =h= hidden buffer
  + =-=, ===, not modifiable. === is read-only and never modifiable
  + =+= modified, =x= read error

A buffer may be hidden by opening another file if the =hidden= option is set.

- =:windo cmd=: do =cmd= in each window of the current tab

- =:bufdo[!] cmd=: do =cmd= in all the buffers

- =ball=, =sball= (in new windows): edit all args or buffers

- =unhide, =sunhide= (in new windows): edit all loaded buffers

- =badd file=: add file to the buffer list; =bunload=: unload the current buffer from
  memory (the buffer is still open), =bdelete=: delete the buffer from the
  buffer list

- =b[uffer]=, =sb[uffer]=: move to a buffer

- =:bnext=, =:sbnext=, =:bNext=, =:sbNext=, =:bprevious=, =:sbprevious=, =:bfirst=,
  =:sbfist=, =:blast=, =:sblast=,

- =:bmod=, =:sbmod=: move the nth modified buffer

**** Special Buffers

- directory: a list of a directory

- help

- quickfix: the list of errors created by a command or the location list,
  typically used with edit-compile-debug cycle

- scratch

** Configuration Files

- =$HOME/.vimrc= (Unix), =$HOME/_vimrc= (MS Windows)

** Folding

Folding define what parts of the file to see. Folds are not simply defined by
language syntax.

To display fold levels, set =foldcolumn= to an appropriate number.

A folded block acts as a line for line operations.

*** Define Folds

The =foldmethod= option defines how folds are defined/created and accepts the
following methods.

- =diff= :: defined the difference between two files

- =expr= :: defined by regular expressions

- =indent= :: corresponds to the indentation of text and =shiftwidth=

- =manual= :: result from user Vim commands
  + =zf=, =nzF=

- =marker= :: predefined markers in the file specify fold boundaries

- =syntax= :: defined by the semantics of a file's language.

*** Fold Commands

- =zA= :: toggle fold state
  + =za= :: toggle teh state of one fold

- =zC= :: close folds, recursively
  + =zc= :: close one fold

- =zD= :: delete/undefine folds, recursively (not the content in the folds)
  + =zd= :: delete one fold
  + =zE= ::  delete all fields

- =zO= :: open folds recursively
  + =zo= :: open one fold

- =zf= :: create a fold from the current line to the one where the following
  motion command takes the cursor
  + =zf%= fold a C code block
  + =Count= + =zF= :: fold count lines. The count number here counts for visual lines
    on the screen.

- =zM= :: set =foldlevel= to zero
  + =zm=, =zr= :: decrement/increment =foldlevel=

- =zN=, =zn= :: set/reset =foldenable= option
  + =zi= :: toggle =foldenable=

** Auto and Smart Indenting

- =autoindent= :: similar to vi's, differs subtly as to where the cursor is
  placed after indentation is deleted.
  + understands comments

- =smartindent= :: recognizes some basic C syntax for defining indentation
  levels
  + before a line starting with ={=, before a line starting with certain
    keywords =cinwords=
  + a new line before/after a =}=

- =cindent= :: richer awareness of C syntax and supports customization
  + =cinkeys= :: keyboard keys under insert mode that triggers reindenting.
    Reindenting means to indent to an appropriate position.
     A set of expressions are used to define this option.
  + =cinoptions= :: indentation style. Another set of expression for various situations are used to
    define C indentation styles.
  + =cinwords= :: keywords that signal when Vim should add an extra indent in
    subsequent lines

- =indentexpr= :: custom indentation rules
  + not a trivial task to define. Predefined expressions are under =$VIMRUNTIME/indent=.

#+begin_comment
TODO learn more about cindent customization and indent expressions
#+end_comment

To use the file type to define indentation, set =:filetype indent on=.

If manual indentation is applied, autoindentation on that line is disabled.

Indentation options may cause indentation problems when pasting text into the
file. Set the =paste= option before pasting and reset it afterward..

- =^N=, =^P= Move in the candidate list; =Enter= to select the match; =^E= to
  halt the match ithout substituting any text.

** Autocompletion

Insertion completion from programming language specific keywords to filenames,
dictionary words and even entire lines. Completion includes

- Whole Lines =^X-^L= :: look backwards for a line matching the typed characters

- Keyword =^X-^N= :: not PL-specific keywords, possibly any word in the file,
  defined by the =iskeyword= option.

- Dictionary =^X-^K= :: searches through the files defined by the =dictionary= option.

- thesaurus =^X-^T= :: searches through the files defined by the =thesaurus=
  option. A set of similar words are listed as candidates.

- keyword in the current file and includes files =^X-^I= in C/C++ ::

- tag =^X-^]= :: searches forward through the current file and includes files
  for keywords matching tags.

- filename =^X-^F= :: searches for filenames in the current directory matching the keyword at the current cursor.

- macro and definition names =^X-^D= :: =#define=

- =^X-^V= :: meant for use on the Vim command line and tries to guess the best
  completions for words to assist users developing Vim scripts.

- =^X-^U= :: use the completion method defined by a custom function =completefunc=.

- Omni =^X-^O= :: use filetype-specific functions to determine the candidate
  list
  + C, CSS, HTML, JaaScript, PHP, Python, Ruby, SQL and XML.

- Spelling correction =^X-^S= :: if the word at the location appears to be badly
  spelled, "more correct" spellings are offered

- Comprehensive complete =^N= :: defined by the =complete= option.

** Syntax Highlighting

=:syntax enable=, =:syntax on=, =set syntax=filetype=. Syntax definition files
are stored in =$VIMRUNTIME/syntax=.

#+begin_comment
TODO: customization
#+end_comment

** QuickFix: Edit-Compile-Edit Cycle

=:make= builds the project and collects the result text in the =Quickfix List=
window, where one can inspect, jump to and correct errors.

- =:cnext=, =:cprevious=: move in the error list

- =errorformat=: an option defining a format of errors returned from a compile

- =makeprg=: an option containing the name of the build instruction

*** grep

Vim's grep may also take advantage of the Quickfix list.

- =vim[grep]  /pattern[g][j] files= :: use builtin grep to search for a pattern
  + by default the result is shown in the Quickfix list.

- =copen= :: open the Quickfix list

**** ripgrep

#+begin_src vimscript
set grepprg=rg\ --vimgrep\ --no-heading\ --smart-case
set grepformat+=%f:%l:%c:%m
#+end_src


** Vimscripts

- conditions are not required to be surrounded by parentheses.

- =elseif=, not =else if=; =if= ends with an =endif=

- =let= assigns a variable.
  + a variable may has a prefix to indicate its scope:
    - =a= function argument
    - =b=: buffer-local
    - =g=: global
    - =l=: function-local
    - =s=: script-level
    - =t=: tab-level
    - =v=: controlled by Vim
    - =w=: window-level
  + by default variables are global =g=

- =.= string concatenation

- =execute=: execute a string as vimscript

#+begin_src vim
let g:Favcolorschemes = ["darkblue", "morning", "shine", "evening"]
function SetTimeOfDayColors()
    " currentHour will be 0, 1, 2, or 3
    let g:CurrentHour = strftime("%H") / 6
    if g:colors_name !~ g:Favcolorschemes[g:CurrentHour]
    execute "colorscheme " . g:Favcolorschemes[g:CurrentHour]
    echo "execute " "colorscheme " . g:Favcolorschemes[g:CurrentHour]
    redraw
    endif
endfunction
#+end_src

- Arrays: =[elm1, elm2, elm3, elm4, ...]

- =&option_name=: retrieve the vale of an option

Vim uses /events/ to execute commands (/autocommands/) e.g. =BufNewFile=, =BufReadPre=, =BufRead=,
=BufReadPost=, =BufWrite=, =BufWritePre=, =FileType=, =VimResized=, =WinEnter=,
=WinLeave=, =CursorMoved=, =CursorMovedI=.

#+begin_src vim
augroup newFileDetection
# everytime the cursor moved under Insert mode.
    autocmd CursorMovedI * call CheckFileType()
augroup END

function CheckFileType()
    if exists("b:countCheck") == 0
        let b:countCheck = 0
    endif
        let b:countCheck += 1
    " Don't start detecting until approx. 20 chars.
    if &filetype == "" && b:countCheck > 20 && b:countCheck < 200
        filetype detect
    elseif b:countCheck >= 200 || &filetype != ""
        autocmd! newFileDetection # delete the commands within the group, deleting a group doesn't delete its commands.
    endif
endfunction
#+end_src

** Binary Files

=-b= or =:set binary=. =textwidth=, =wrapmargin= are set to zero. =modeline= and
=expandtab= are unset=. Another editor designed to edit binaries is =bvi=.

To show bytes as hex, =:set display=uhex=. See =:h using-xxd=.

** Display Buffers as HTML

Vim can convert the rendered buffer to an HTML document, duplicating the
original Vim graphics =TOhtml=.

** Backup

- =backup= :: make a backup before writing a file and leave it around after writing.

- =writebackup= (default) :: make a backup before writing a file and delete it after writing.

** Sessions

- *viminfo*: a global session file that saves command line history, search
  string history, input line history, non-empty registers, file marks, last
  search/substitute pattern, the buffer list and global variables.

- *Session*: addition to viminfo, a view is a collection of settings that apply
  to one window; a session keeps the views for all windows plus the global
  setting.
  + =:mksession session_filename.vim=: a session file, similar to a vimrc script file, is created

** Remote

Vim and Neovim support a client-server mode (if compiled with =clientserver= option, by
default on Neovim).
A client remotely programmatically control the server.

#+begin_src shell
nvim --listen pipepath/socket
nvim --server
vim --servername
#+end_src
