* Basic Concepts

~vi~ has tow modes:

- command mode:

- insert mode:

- =ex= mode

The general form of ~vi~ commands is

#+begin_src
[(command)][(number)](text object)
[(number)][(command)](text object)
#+end_src

Where =text object= is commands like =w=, =b=, regexes etc, that is, certain
commands in vi denotes both text objects and certain related commands.

* Basic Operations

** Status Aware

- =C-g=: show the location in a file and the file status

** Motion

*** Scrolling and Paging

- ~^f~ / ~^b~ :: scroll up/down a screen

- ~^d~ / ~^u~ :: scroll up/down half screen

- ~^e~ / ~^y~ :: scroll up/down one line

- ~zENTER~ / ~z.~ / ~z-~ :: move current line to top/center/bottom of screen and scroll
  + with a line number prefixed, the command sets the specified line the anchor.

*** Go to a Position

- ~G~  :: go to the specified line/the end if none

- =``= :: get back to a previous position (not down a list).

- =mx=, =`x=, ='x= :: mark a position; return to the position; return to the
  first non-white character of the marked line.

*** Moving Around on the Screen

- =j=, =^n=;  =k=, =^p= ::

- =+=​/​=Enter=, =-= :: go down/up to the first character of the line

- =nH=, =nL= :: the screen top/bottom n line (the first if none)

- =M= :: the middle of the screen

*** Moving Within a Line

- =^= :: first non-white character.

- =0= :: beginning of the line.

- =$= :: EOL.

- =h=, =SPACE=; =l=, =BACKSPACE= (also as =^h=) ::

- =w=, =b=; =W=, =B=; ~e~, =E=  :: move to the next/last word. The upper
  case version ignores punctuation, splits words by whitespaces.

- ~n|~ :: move to column n

- ~(~​/​~)~, ~{~​/​~}~, ~[[~​/​~]]~ :: move to beginning of current/next sentence/paragraph/section

- =%= :: move to the matching parenthesis

- Commands that change text can be combined with ~/~ and ~?~ ::

- ~f~ / ~F~ / ~t~ / ~T~ / ~;~ /~,~ ::

*** High Level Text Objects

A sentence is defined as a text block ending with =.=, =!= or =?= which is followed by either the
end of a line or by at least two spaces (one in the case of vim). A paragraph begins after each empty line and
also at each a set  of paragraph macros (typically used by the =troff= system).
Sections are completely defined by macros.

- =(=, =)= :: move over the beginning of the current/next sentence

- ={=, =}= :: move over the beginning of the current/next paragraph

- =[[=, =]]= :: move to the beginning of the current/next sentence
  + works for C blocks.

** Change Text

*** Insert Mode

- =o= / =O= :: insert a newline below/above and enter the insert mode.

- =a= :: append after the cursor, =i= before the cursor; =I= and =A=: prepend/append to the
  current line.
  + insert commands may be prefixed with a count number, to indicate the
    repetition of the inserted text.
  + Under =vi=, =a= only appends, =i= only inserts: they cannot modify existing
    text and backspace deleting characters are not instantly displayed as deleted.
  + Under insert mode, =^H= is backspace, =^U= deletes the input on the current
    line; =^W= erases a word; =^i= inserts a tab; =^[= is the escape key.
  + In case some other operations are required under
    insert mode, use =^o= to access normal mode commands.

- ~ra~ :: replace the current char with ~a~, no need to enter the insert mode;
  + replace =&&= with =||=: =2r|=

- ~R~ :: the replace mode that replaces (overstrikes) everything in its way, basically the
  INSERT key in CUA: one may even restore to normal insert mode by pressing the
  =INSERT= key.

- =Esc= or =^[= :: leaves the insert mode.

- ~c~ :: change, a combination of delete followed by insert, used with various
  motion commands.
  - =s= :: substitute the first char and then enters the insert mode.
  - ~cc~, =S= :: change the entire line
  - ~C~ ::  ~c$~
  - =ce= and =cw= do the same even if =w= and =e= have different semantics.

- special characters :: insert a =^V= before the character.

*** Deletion

- =x=, =X= :: delete the next/previous character

- ~["x]d~ :: delete operator, used with =b=, =d=, =w= and various motion and
  search commands, optionally into register =x=.
  + ~D~ delete to the end of the line, equal to  = ~d$~

The editor saves the last 9 deleted blocks of text in a set of numbered
registers 1-9, accessible by ="n=.

*** Rearranging and Duplicating

There are a few special buffers (registers) provided by =vi= for temporary use:
the unnamed buffer and the named buffers.The unnamed buffer (deletion register) is lost when switching files; the named buffers (from =1= to =9= and =a= to =z=) do not, thus they may be used to transfer content from one file to another.

- ~("buffer_name)y~ :: yank (copy into a buffer, by default the unnamed one
  (deletion register), unless prefixed by
  a named buffer)

- ~p~, ~P~ :: put after/before the line/the cursor
  + =xp= :: to transpose two characters

- ~Y~ :: curiously = ~yy~, not yank to the end of the line.

- =~= :: changing case

- =<=, =>= :: combined with motion, search command to shift lines by a =shiftwidth=.
  + =<<=, =>>= shift the current line.

- =^D= and =^T= :: shift lines under insert mode, so-called tabbing.

- ~J~ :: join

** Search/Replace

- =/=, =?= :: forward/backward search (possibly with regex). Search is also a way to move around.
  + By default, the search wraps around when it hits the end of the buffer
    unless =nowrapscan= is set.
  + these patterns may be followed by a count =n= to denote the =n=-th occurrence.
  + =/=, =?= without a pattern repeats the previous search.
  + =n=, =N= continue the search in the same/opposite direction.
  + (vim) a history of search commands is maintained, retrivable with arrow keys or =^p=, =^n=.

- =fchar=, =Fchar=; =;= :: search for the next =char= forwards/backwards on the
  current line; =;=
  repeats the previous search.
  + =t= and =T= is a version of =f= that goes to the position before the searched character.
  + =;=, =,= repeats the previous find command in the same/opposite direction.
  + use =``= or =''= to return to the position/line before the search.

Substitution is mostly done through the =substitute= ex command.

** Undo/Redo

- ~u~: undo; ~U~: undo all on a line, ~C-r~ (vim): redo (redo an undone operation)
  + =vi='s undo may undo a previous undo.

- Since the last nine deletions are saved in the nine named buffer in addition
  to the /deletion register/, use ="np= to
  retrieve them. But vim supports infinite undo.

** Other Operations

- ~:e!~ :: returns to the last saved version of the file

- ~ZZ~ / ~:wq~ ::

- ~.~ :: repeat the last command

- =%= on a paired punctuation mark ::

- =Ctrl-^= :: =:e #=

* ex commands and the ex mode

Originally, =vi= was the visual mode of the =ex= editor, an improved line editor
from and a superset of =ed=. Modern =ex= runs a cleared terminal, unlike =ed=,
which runs directly in the current view of the terminal. To enter =ex= mode
under visual mode, hit =Q=.

=ex= has buffers named =a= through =z=.
The =ex= editor has five modes:

- *command mode* :: the =:= prompt
  + =address command ! parameters count flags=, all parts are optional. The
    degenerate case (empty command) prints the next line in the file. Here
    =flags= are =p=, =l= or =#=, executed after the main command.
  + Most commands names are English words with prefix abbreviations. Most commands
    accept prefix addresses specifying the lines in the file upon which they are
    to have effect. A few (e.g. =delete=) may take a trailing count specifying the
    number of lines to be involved or other parameters after the command name.
  + For commands that takes a range address, the count parameter limits the
    command to the lines starting at the last line of the range with
    =count= lines involved. That is, the range address is actually invalid and only the last address number is taken.
  + commands are commented out by a double quote ="=.
  + Different elements of an =ex= command may be separated by spaces.
  + multiple commands on a single line are separated by =|= in the same way a
    semicolon separates a shell command.

- *text input mode* :: gathers input lines and places them in the file; the
  =append=, =insert= and =change= commands use text input mode. A =.= line exits
  the mode.

- *open mode* :: displays one line at a time, not really useful on modern
  terminals and monitors and they are usually not implemented. They are designed for hardcopy terminals (terminals
  that print a line to display instead of drawing on the screen) or glass TTYs
  (display terminal that behaves like a teletype printing terminal without
  cursor support).

- *visual mode*, *text insertion mode* :: vi's modes
  + type =Q= to enter =ex= mode.

** Command Addressing

Addresses may be absolute line numbers, relative line offset, special symbols
indicating some special lines or search pattern as addresses and they may be
combined: two patterns may form a range with a comma; patterns with an offset
indicates a line relative to the matching line.

- =.= :: the current line

- =n= :: the nth line

- =$= :: the last line

- =%= :: the entire buffer, equal to =1,$=, unlike ed, where comma =,= addresses the
  whole buffer.

- =+n=, =-n= :: an offset relative to the line specified before it

- =/re/=, =?re?= :: scan forward or backward respectively for a line containing
  a regex, possibly with some commands to operate on these lines. The search wraps around the end of the buffer. Without the trailing
  =/= or =?=, the command simply prints the next matching line using the regex. =//= or =??= uses the last regex.

- ='"= :: the previous current line is marked by ="=.

- Null address specification :: defaults to the current line, =1,p= prints the
  first line through the current line. This is more consistent than in =ed=, where
  =,addr= denotes =1,addr= and =addr,= denotes =addr,addr=.

- =;= is also available in =vi= to set the first address as the current line.

** Commands

- =args= :: the members of the argument list of the =ex= process

- =(.){a}ppend= ::
  + =a!= toggles autoindent

- =cd=, =chdir= :: After a =chdir= the current file is not considered edited.

- =(.,.){c}hange count= ::
  + =c!= toggles autoindent

- =(.,){co}py addr flags=, also abbreviated as =t= :: copy and put the range after =addr=

- =(.,.){d}elete (buffer) count flags= :: If a buffer name is given, the deleted
  lines are saved (lower case buffer name)/append (upper case buffer name) there.

- =(.,.)yank buffer count= :: yank the specified lines in th named buffer, if
  any, for later retrieval via =put=.

- ={e}dit=, =ex= :: clear the current clean buffer and begin an editing session on a new file.
  + =e!= :: discards changes to the buffer and reload the file.

- ={f]ile filename=, =file= ::

- =(1,$) {g}lobal /re/ commands= :: the command list may span multiple lines and
  may include =append=, =insert=, =change= commands and their associated input
  text. The global command and the undo command are not allowed in the command list.
  + =g!=, abbr. =v= :: at each line not matching the pattern

- =(.){i}nsert= ::
  + =i!= :: the autoindent version

- =(.,.+1) {j}oin count flags= ::
  + =j!=

- =(.)k x=  or =(.)mark x= :: mark a line with a letter.

- =(.,.){m}ove addr= :: move (cut and paste) the specified lines to =addr=.

- ={n}ext= :: the next file from the command line arguments is edited

- ={rew}ind= :: the argument list is rewound and the first file is edited.

With =args=, =n= and =rew=, one may switch between multiple files without leaving vi.
=last=, =prev= (vim) enhanced support for multiple files. However, moving to
another file requires a save as the buffer is cleared. =vi= remembers the
current filename as =%= and the alternate filename as =#=. They may be used with =e=, =r=, =!cmd=.

- =(.,.){nu}mber count flags=, =#= :: print with line numbers

- =(.){o}pen (/re/) flags= :: enter intraline editing open mode at each
  addressed line. =Q= to exit.

- =(.,.){p}rint count= ::

- =(.){pu}t buffer= :: puts back deleted or yanked lines, possibly from a named buffer.

- ={q}uit= ::

- =(.){r}ead file= :: If no filename is given, the current filename is used. The
  current file name is not changed unless there is none, in which case the
  specified =file= becomes the current one.

- =recover file= ::

- ={sh}ell= :: start a new shell, resume editing after the shell exits

- ={so}urce file= :: reads and executes =ex= commands from the specified file

- =(.,.) {s}ubstitute /re/replacement/ options count flags= ::
  + =options= may be =g= global, =c= asking for confirmation
  + =&= repeats the previous substitute command with possibly different flags.
  + =~= repeat last substitute with the same replacement but with last used
    search pattern.

- =stop= :: suspends the editor

- =ta tag= :: switch the focus of editing to the location of =tag=, defined by
  the tags file, created by, for example, =ctags=.

- =! command= ::
  + =%= and =#= in the command are expanded as in filenames.
  + if a range address is appended before =!=, that range of lines are supplied
    as stdin to the command. The possible output then replaces the original lines.

- =($)== :: prints the line number of addressed line without changing the
  current line.

- =(.){vi}sual -/^/. windows_size flags= :: enters visual mode at the specified line

- =(1,$){w}rite (>>) file/!command= :: overwrite/appends (to file only) the specified lines (by
  default the entire buffer) to a filename/command stdin.
  + =w!= overwrite an existing file.

- ={x}it! file= :: exits with changes saved if modified.

- =preserve= :: write the current buffeer into its swap and the swap file will
  not be deleted after exiting so that changes may be recovered.

- =(.+1)z window_size= :: print the next count lines, the current line is
  changed. This command is basically scroll.

- =(.)z -/./ number_of_lines= :: prints a window of text with the specified line
  at the top.
  - =-= puts the line at the bottom, =.= at the center, === also at the center
    with surrounding =-= characters.

- =(.,.) >/< count flags= :: shift the specified lines.
  + Only whitespaces are shifted; no non-white characters are discarded with a left-shift.

- (.+1, .+1) :: an address alone causes the addressed line to be printed (and
  also change the curent line).

** Pattern Matching

Ex/Vi/Vim mostly uses POSIX basic regular expression. For syntax and rules of regular expressions, see [[./posix_regex.org][POSIX Regex.]]

- =~= in the replacement pattern stands for the defining text of the previous
  replacement pattern. In the search pattern, it matches the text which defined
  the replacement part of the last substitute command.

- =#= as the replacement pattern alone specifies the previous replacement pattern.

- =&= in the replacement is replaced by the characters matched by the search pattern.

- =\n= (backreference): matches the text that was matched by the n-th regular
  subexpression.
  + in the replacement pattern, it is replaced by the text matched by the corresponding subexpression.
  + For nested expression, =n= is determined by the counting occurrences of =\(=
    starting from the left.

- =\u= and =\l= cause the immediately following character in the replacement to
  be converted to upper- and lower-case respectively.
  + =\U= and =\L= turns on the conversion until =\E= and =\e= turns it off.


*** Some Pattern Matching Examples
 
- delete all blank lines plus any lines that contain only whitespace

#+begin_src 
:g/^[ tab]*$/d
#+end_src

- delete all leading spaces

#+begin_src 
:%s/^  *\(.*\)/\1/
#+end_src

- insert a ~>  ~ at the start of every line in a file

#+begin_src 
:%s/^/>  /
#+end_src

- reverse the order of lines in a file

#+begin_src 
:g/.*/mo0
#+end_src

- repeat a command

#+begin_src 
# copy lines 12-17 to the end of the file ten times
:1,10g/^/ 12,17t$
#+end_src

* Advanced Usage
** Read-Only Mode

=vim -R= or =view=. Use =w!= or =wq!= to force a write if necessary.

** Word Abbreviation

=:(un)abbrivate abbr expanded text=

** Recovery

- =vi -r name= :: recovery a file at the directory where a file is previously not written.

- Use =:{pre}serve= the buffer even if there is no crash, especially when the
  user cannot save the file, under which case preserving the file offers an
  alternative to backup the file.
  + for =vim=, it preserves the content in the =.swp= file.

** Options

#+begin_src
:set option
:set nooption
#+end_src

~:set all~ displays all options.

*** Useful Options

- =autoindent= :: supply indentation automatically

- =autowrite= :: automatic write before =:n=, =ta= etc.

- =ignorecase= :: ignore case in searching

- =number= :: display line numbers

- =showmatch= :: show matching punctuation

- =hardtabs= :: the boundaries on which terminal hardware tabs are set

- =shiftwidth= :: the width of a software tab stop.
  + used in shift commands and autoindent backtabbing.

- =tags= :: the tags file to be searched

- =shell= :: the shell used, by default =$SHELL=.

- =wrapmargin= :: the number of columns of a line before the line is
  automatically broken at a word boundary.

- =showmode= :: the modeline

** Key Macros

There are two flavors of macros:

- the macro body is put in a buffer register =x=, =@x= invokes the macro.

- =:map macro macro_body= defines a key macro
  + =:map!= causes the mapping to apply to input mode.
  + special characters are input with =^V= prefixed.
  + =:unmap= deletes a macro.
  + =#0= through =#9= mean function keys.

* VIM

** Command line options

- ~-b~: in binary mode

- ~-d~: diff mode

- ~-E~: improved ex mode, with extended regex

- ~-F~ / ~-A~: Farsi or Arabic mode

- ~view~: vim in read-only mode

- ~vimdiff~: diff mode

- ~ex~: ex mode, useful in scripts

** Extended Regex

- ~\|~: indicates alternation

- ~\+~

- ~\=~: matches zero or one of the preceding regex


- {-(n),(m)}: non-greed matching

** Multiwindows behavior

- ~-o~/~-oNumber~

- ~:split~, ~Ctrl-Ws~: split the window horizontally

- ~:vnew~ / ~:vsplit~, ~Ctrl-Wv~: vertically split the window

- ~:new~, ~Ctrl-Wn~: new window

- ~:close~, ~Ctrl-Wc~: close the current window; ~:only~: close all but the current window

- ~Ctrl-W~ + ~+, -~: increase/decrease the current windows, ~=~: resize all windows to equal size. + ~<, >~: decrease/increase, + ~|~: resizes the current window to the widest size possible

- ~Ctrl-W~ + ~h,j,k,l~, ~t~ (top), ~b~ (bottom), ~p~ (previous)

- ~Ctrl-W~ + ~r~: rotate windows, + ~x~: exchange two windows in a row or column

- ~Ctrl-W~ + ~K, J, H, L, T (tab)~: move the current window, full height

- ~Ctrl-W~ + ~q~: quit a window; + ~c~: close the current window

- ~Ctrl-W~ + ~o~: maximize a window

** Vimscripts

#+TODO
