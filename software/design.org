#+TITLE: Design

* Design Patterns

** Mediator Pattern

To promote loose coupling by keeping objects from referring each other explicitly when they interact.
This is done by define a separate mediator object that encapsulates the interaction between a set of
objects and the objects delegate the interaction to the mediator.

#+begin_src csharp
// a wikipedia example
public delegate void MessageReceivedEventHandler(string message, string sender);

public class Mediator
{
    public event MessageReceivedEventHandler MessageReceived;

    public void Send(string message, string sender)
    {
        if (MessageReceived != null)
        {
            Console.WriteLine("Sending '{0}' from {1}", message, sender);
            MessageReceived(message, sender);
        }
    }
}

public class Person
{
    private Mediator _mediator;

    public string Name { get; set; }

    public Person(Mediator mediator, string name)
    {
        Name = name;
        _mediator = mediator;
        _mediator.MessageReceived += new MessageReceivedEventHandler(Receive);
    }

    private void Receive(string message, string sender)
    {
        if (sender != Name)
            Console.WriteLine("{0} received '{1}' from {2}", Name, message, sender);
    }

    public void Send(string message)
    {
        _mediator.Send(message, Name);
    }
}
#+end_src

** Specification Pattern

A unit of /business logic/ inherits its functionality from an abstract aggregate /specification/ class, which is chained with other specifications. This encapsulates some piece of domain knowledge into a single specification and reuse it in different parts of the code base.

Generic specifications are a bad practice. If a specification allows you to indicate an arbitrary condition, it becomes just a container for the information which is passed to it by its client and doesn’t solve the underlying problem of domain knowledge encapsulation. Such specifications simply don’t contain any knowledge themselves.

https://enterprisecraftsmanship.com/posts/specification-pattern-c-implementation/

*** Main Use

- Looking up data in the database: finding records that match the specification

- Validating objects in the memory: checking that an object fits the spec

- Creating a new instance that matches the criteria.
