- vulnerability; a security bug. A vulnerability can be _exploited_.

- security: the overall problem

- protection mechanism: the specific OS mechanism used to safeguard information in the computer.

# Security Environment CIA

- confidentiality: to whom the data is available and how these rules should be enforced

- integrity: no unauthorized data modification

- availability: no one can disturb the system to make it unusable.

port-scan; dual use; botnet; zombie; attackers; intruders; adversaries; script-kid

# OS Security

_passive_ attempt to steal information; _active_ attempt to make a computer program misbehave;

- cryptography: shuffling a message or file in such a wawy that it becomes hard to recover the original data;

- hardening: adds protection mechanisms to programs to make it hard for attackers to make them misbehave

To build a secure system, have a security model at the core of the OS that is simple enough that the designers can actually understand it and resist all pressure to deviate from it in order to add new features.

- _trusted systems_: systems that have formally stated security requirements and meet these requirements. Each is a minimal **TCB** (**Trusted Computing Base**) consists of the hardware and software necessary for enforcing all the security rules. The TCB typically consists of most of the hardware, a portion of the OS kernel, and most or all of the user programs that have superuser power. Operating system functions that must be part of the TCB include process creation, process switching, memory management and part of file and I/O management. In a secure design, the TCB will be separate from the rest of the OS in order to minimize its size and verify its correctness. All syscalls involving security go through the _reference monitor_.

# Controlling Access to Resources

Security is easier to achieve if there is a clear model of what is to be protected and who is allowed to do what.

- _domain_: a set of (object, rights) pair. Each pair specifies an object and some subset of the operations that can be performed on it. 

- _right_: permission to perform one of the operations.

_Principle of Least Authority_: security works best when each domain has the minimum objects and privileges to do its work and no more.

Every process runs in some protection domain. There is some collection of objects it can access and for each object it has some set of rights.

e.g. in Unix, the domain of a process is defined by its UID and GID. Running a program with SETUID or SETGID is a domain switch. A syscall causes a domain switch.

The actual implementation is not a matrix that lists a collection of domains since that would be waste of resources.

- _Access Control List_: associating with each object an (ordered) list containing all the users that may access the object and how. The users in the list are called _subjects_/_principals_.

Many systems support the concept of a _group_ of users. A user has a different _role_ when in different groups.

- _Capability list_ (_C-list_): the individual items on it are called _capabilities_. associated with each process is a list of objects that may be accessed, along with an indication of which operations are permitted on each.

Capability lists are themselves objects and must be protected from user tampering.

- tagged architecture

- keep the C-list inside the OS e.g. Unix file descriptor table

- manage the capabilities cryptographically in user space, suited to distributed systems. The capability containing what the user can do, represented by a crypted field, is generated by the server and returned to the client. The check field is stored on the server. The last field is generated by a good one-way function and so it is hard to fabricate. (somewhat like a token?)

```
|server | object |rights | f(objects, rights, check)|
```

# Formal Models of Secure Systems

TODO

# Basics of Cryptography

_plaintext_ -> _ciphertext_: only authorized people know how convert it back to plaintext.

The encryption and decryption algorithms should always be public. Security by obscurity (keeping these algorithms secret) is employed only by security amateurs. The secrecy depends on parameters to the algorithms called _keys_.

```
            K_E                        K_D
            +                           +
            |                           |
            |                           |
            v                           v
         +--|--+                     +--|--+
         |     |      C=E(P, K_E)    |     |  P=D(C, K_D)
P+------>+  E  +-------------------->+  D  +----------> P
         |     |      Ciphertext     |     |
         +-----+                     +-----+
```

_Kerckhoffs' principle_: algorithms should all be public and the secrecy should reside exclusively in teh keys.

- Secret-key/symmetric-key cryptography: using the same key for encryption and decryption. The sender and receiver must both be in possession of the shared secret key.

- public-key/asymmetric-key cryptography: distinct keys are used for encryption and decryption. Given a well-chosen encryption key, it is virtually impossible to discover the corresponding decryption key. The encryption key can be made public and only the private decryption key kept secret. e.g. RSA: multiplying big numbers is much easier for a computer to do than factoring big numbers. (only some specific party can decrypt the message)

- _cryptographic hash function_

- digital signatures: 1. run the document through a one-way cryptographic hashing algorithm that is hard to invert, e.g. SHA-1, SHA-256, SHA-512, to produce a hash. 2. the owner then applied his private key to the hash to get $D(hash)$ 3. the value (signature blcok) is appended to the document and sent the the receiver. 4. the receiver computes the hash of the document using the same algorithm and then applies the sender's public key to the signature block to get $E(D(hash))$. The computed hash is expected to match the hash from the signature block (only some specific parties can sign). This method requires

$$
E(D(x)) = x 
$$

To get the signature property, the order of the application must not matter, that is $D$ and $E$ must be commutative. (RSA has this property).

To distribute public keys, a common method is for message senders to attach a _certificate_ to the message, which contains the user's name and public key and is digitally signed by a trusted third party (Certification Authority). _Public Key Infrastructure_ (_PKI_) is required to ensure this. All browsers come preloaded with the public keys of popular CAs.

_Trusted Platform Module_ (TPM), a specialized hardware, a cryptoprocessor with some nonvolatile storage inside it for keys, is used to store keys. One of the major use of TPM is _remote attestation_.  The one thing TPM does not do is make computers more secure against external attacks. What it really focuses on is using cryptography to prevent users from doing anything not approved directly or indirectly by whoever controls the TPM.

# Authentication

Most methods of authenticating users are baed on:

1. something the user knows

2. something the user has

3. something the user is

OS password is not much better than nothing. The attacker can always boot into another system.

weak passwords; ping and portscanning;

Hashed passwords are not as secure as they seem. The cracker can spend his time matching them as long as he has obtained the password file. Salt can be concatenated to a password and encrypted as the real password.

one-time passwords: a book of passwords changed each time after using

one-way hash chain:

TODO

# Exploiting Software

Red-queen effect

## Buffer Overflow 

```c
void A() {
    char B[128];
    printf("Type log message:);
    gets(B);
    writeLog(B);
}
```

An attacker can provide a tailored message specifically aimed at subverting the program's control flow. The buffer is allocated on stack, of which the bottom of the current frame is the return address. The attacker controls the buffer contents and can fill it with machine instructions and overwrite the return address to the beginning of the buffer. The program is now under the attacker's control, who would `exec` a shell in the buffer code. Such code is known as **shell code**. To ensure the return lands safely, the attacker can prepend the shellcode with a _nop sled_, a sequence of nop.

This trick works for any code that copies user-provided data in a buffer without checking for boundary violations.

- heap spraying: placing nop sleds and shellcode all over the heap.

_stack canaries_: at places where the program makes a function call, the compiler inserts code to save a random canary value on the stack, just below the return address. Upon a return from the function, the compiler inserts code to check the value of the canary. If the value changed, something is wrong.

```c
void A(char *date)
{
        int len;
        char B[128];
        char logMsg[256];

        strcpy(logMsg, date);
        len = strlen(date);
        gets(B);
        strcpy(logMsg + len, B);
        writeLog(logMsg);
}
```

The attacker can overflow `B` and overwrite `len`. The value of `len` will make sure that the place `B` will be written to is below the canary so that the canary will be bypassed.

Any function pointer that is reachable via an overflow can be exploited.

To prevent code injection attack, modern CPUs have a feature: NX bit, useful to distinguish between data segments and text segments. Many OSes try to ensure that data segments are writable but not executable and the text segment is executable but not writable (_DEP_, _Data Execution Prevention_).

- Code Reuse Attack: code injection may not be possible since the stack may not be executable. Constructing the necessary functionality out of the existing functions and instructions in the binaries and libraries.

return-to-libc is such a technique that the control flow is directed to a libc function such as `system`, `mprotect` (which can make part of the data segment executable).  The attacker may return to the PLT (Procedure Linkage Table).

Return-Oriented Programming: look for small sequences of code that do something useful and end with a return instruction. The attacker can string together theses sequences (called _gadgets_) by means of the return address he places on the stack. The attacker has to make do with gadgets that are perhaps less than ideal but enough for the job. ROP is one of the most important exploitation techniques used in the wild.

- _ASLR_ (_Address Space Layout Randomization_): randomize the addresses of functions and data between each every run of the program.

Randomization may not be random enough. The attacker can brute-force it. A more important attack against ASLR is formed by memory disclosures.

```c

void C()
{
        int index;
        int prime[16] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,13,14, 15, 16};
        index = read_user_input();
        printf("%d: %d\n", index, prime[index]);
}
```

The address may be discovered by setting `index` out of range and relative addresses between functions are generally fixed.

Canaries, DEP and ASLR form an important line of defense in modern operating systems.

- Noncontrol-flow diverting attacks
```c

void A()
{
        int authorized;
        char name[128];
        authorized = check_credentials();
        printf("Your name?\n");
        gets(name);
        if (authorized != 0) {
                printf("Welcome %s, here is all our secret data\n", name);
        } else
                printf("Sorry %s, but you are not authorized.\n");
        
}
```

Buffer overflows are some of the oldest and most important memory corruption techniques that are used by attackers. If is difficult to fix because there are so many existing C programs around that do not check for buffer overflow.

## Format String Attacks

TODO

## Dangling Pointers

The location to which dangling pointers point to may be occupied by a specific heap object placed by the attacker. 

Heap fengshui.

## Null Pointer Dereference Attacks

In Linux, the kernel is mapped into every process' address space and whenever the kernel starts executing to handle a syscall, it will run in the process' address space.

A null pointer in kernel is dereferenced to user space. The system may crash. Or page 0 is mapped to shellcode (no possible on modern operating systems anymore).

## Integer Overflow Attacks

## Command Injection Attacks

Getting the target program to execute commands without realizing it is doing so. e.g. the target program uses the `system()` function.

## Time of Check to Time of Use Attacks

```c
int fd;
if (access("./my_doc)", W_OK) != 0) 
    exit(1); // checks if the read ID can access  this file
fd = open ("./my_doc",O_WRONLY);
write(fd, user_input, sizeof(user_input));
```

The attacker manages to create a symbolic link with the same file name to the password file after the check by `access`.

