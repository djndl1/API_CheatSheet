- vulnerability; a security bug. A vulnerability can be _exploited_.

- security: the overall problem

- protection mechanism: the specific OS mechanism used to safeguard information in the computer.

# Security Environment CIA

- confidentiality: to whom the data is available and how these rules should be enforced

- integrity: no unauthorized data modification

- availability: no one can disturb the system to make it unusable.

port-scan; dual use; botnet; zombie; attackers; intruders; adversaries; script-kid

# OS Security

_passive_ attempt to steal information; _active_ attempt to make a computer program misbehave;

- cryptography: shuffling a message or file in such a wawy that it becomes hard to recover the original data;

- hardening: adds protection mechanisms to programs to make it hard for attackers to make them misbehave

To build a secure system, have a security model at the core of the OS that is simple enough that the designers can actually understand it and resist all pressure to deviate from it in order to add new features.

- _trusted systems_: systems that have formally stated security requirements and meet these requirements. Each is a minimal **TCB** (**Trusted Computing Base**) consists of the hardware and software necessary for enforcing all the security rules. The TCB typically consists of most of the hardware, a portion of the OS kernel, and most or all of the user programs that have superuser power. Operating system functions that must be part of the TCB include process creation, process switching, memory management and part of file and I/O management. In a secure design, the TCB will be separate from the rest of the OS in order to minimize its size and verify its correctness. All syscalls involving security go through the _reference monitor_.

# Controlling Access to Resources

Security is easier to achieve if there is a clear model of what is to be protected and who is allowed to do what.

- _domain_: a set of (object, rights) pair. Each pair specifies an object and some subset of the operations that can be performed on it. 

- _right_: permission to perform one of the operations.

_Principle of Least Authority_: security works best when each domain has the minimum objects and privileges to do its work and no more.

Every process runs in some protection domain. There is some collection of objects it can access and for each object it has some set of rights.

e.g. in Unix, the domain of a process is defined by its UID and GID. Running a program with SETUID or SETGID is a domain switch. A syscall causes a domain switch.

The actual implementation is not a matrix that lists a collection of domains since that would be waste of resources.

- _Access Control List_: associating with each object an (ordered) list containing all the users that may access the object and how. The users in the list are called _subjects_/_principals_.

Many systems support the concept of a _group_ of users. A user has a different _role_ when in different groups.

- _Capability list_ (_C-list_): the individual items on it are called _capabilities_. associated with each process is a list of objects that may be accessed, along with an indication of which operations are permitted on each.

Capability lists are themselves objects and must be protected from user tampering.

- tagged architecture

- keep the C-list inside the OS e.g. Unix file descriptor table

- manage the capabilities cryptographically in user space, suited to distributed systems. The capability containing what the user can do, represented by a crypted field, is generated by the server and returned to the client. The check field is stored on the server. The last field is generated by a good one-way function and so it is hard to fabricate. (somewhat like a token?)

```
|server | object |rights | f(objects, rights, check)|
```

# Formal Models of Secure Systems

TODO

# Basics of Cryptography

_plaintext_ -> _ciphertext_: only authorized people know how convert it back to plaintext.

The encryption and decryption algorithms should always be public. Security by obscurity (keeping these algorithms secret) is employed only by security amateurs. The secrecy depends on parameters to the algorithms called _keys_.

```
            K_E                        K_D
            +                           +
            |                           |
            |                           |
            v                           v
         +--|--+                     +--|--+
         |     |      C=E(P, K_E)    |     |  P=D(C, K_D)
P+------>+  E  +-------------------->+  D  +----------> P
         |     |      Ciphertext     |     |
         +-----+                     +-----+
```

_Kerckhoffs' principle_: algorithms should all be public and the secrecy should reside exclusively in teh keys.

- Secret-key/symmetric-key cryptography: using the same key for encryption and decryption. The sender and receiver must both be in possession of the shared secret key.

- public-key/asymmetric-key cryptography: distinct keys are used for encryption and decryption. Given a well-chosen encryption key, it is virtually impossible to discover the corresponding decryption key. The encryption key can be made public and only the private decryption key kept secret. e.g. RSA: multiplying big numbers is much easier for a computer to do than factoring big numbers. (only some specific party can decrypt the message)

- _cryptographic hash function_

- digital signatures: 1. run the document through a one-way cryptographic hashing algorithm that is hard to invert, e.g. SHA-1, SHA-256, SHA-512, to produce a hash. 2. the owner then applied his private key to the hash to get $D(hash)$ 3. the value (signature blcok) is appended to the document and sent the the receiver. 4. the receiver computes the hash of the document using the same algorithm and then applies the sender's public key to the signature block to get $E(D(hash))$. The computed hash is expected to match the hash from the signature block (only some specific parties can sign). This method requires

$$
E(D(x)) = x 
$$

To get the signature property, the order of the application must not matter, that is $D$ and $E$ must be commutative. (RSA has this property).

To distribute public keys, a common method is for message senders to attach a _certificate_ to the message, which contains the user's name and public key and is digitally signed by a trusted third party (Certification Authority). _Public Key Infrastructure_ (_PKI_) is required to ensure this. All browsers come preloaded with the public keys of popular CAs.

_Trusted Platform Module_ (TPM), a specialized hardware, a cryptoprocessor with some nonvolatile storage inside it for keys, is used to store keys. One of the major use of TPM is _remote attestation_.  The one thing TPM does not do is make computers more secure against external attacks. What it really focuses on is using cryptography to prevent users from doing anything not approved directly or indirectly by whoever controls the TPM.
