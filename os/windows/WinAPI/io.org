* [[https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file][File Naming]]
  :PROPERTIES:
  :CUSTOM_ID: file-naming
  :END:


A full pathname is either a DOS-style disk name (=DiskName:=) prefixed or a *Universal Naming
Convention* (=\\ServerName\sharename=) name. Both backslash and forward slash
are legal path separator. File names are case-insensitive but case-retaining.
Base names are seperated by a period from its extension (file type name).
Certain filenames are not allowed due to DOS compatibility.

Pathnames are subject to =MAX_PATH= length (260 currently, and the limitation may be removed
since Window 10 1607 through [[https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs=registry][some configuration]]). Extended-length paths are
prefixed with the Win32 File namespace prefix =\\?\= (=\\?\UNC\server\share= for UNC paths) to disable any
string parsing.
Thus extended-length paths are absolute paths and do not use forward slashes as
separators, or periods to denote the current or parnent directory. Also, they
are not supported by every file I/O API.

It is acceptable to specify a period as the first character of a name.
For example, ".temp".

A file name is not relative if:
- UNC =\\=
- starts with a disk designator =C:\=. =C:tmp.txt= is a relative path
   on =C:\=.
- a single backslash
On Windows, a fully-qualified path differs from an *absolute path* (*rooted*), which starts
from the root but does not specify on which disk this root is. A program may
have different current directories on different drives on Windows.

A short 8.3 DOS-style alias is generated by Windows for a file.
A directory path cannot be longer than =MAX_PATH - 12=,

** /namespaces/
   :PROPERTIES:
   :CUSTOM_ID: namespaces
   :END:

NT namespaces and Win32 namespaces. The NT namespace was designed to be
the lowest level namespace on which other subsystem and namespaces could
exist.

The =\\.\= prefix is used to access the Win32 Device Namespaces. Most API do not
support this prefix.

Under the NT namespace, =Global??= is the Win32 namespace. Symlinks are created
to allow Win32 subsystem to access certain devices. A =\\?\GLOBALROOT\= is also
created to allow access to the true root path.

** Unicode

Windows stores the long file names on disk in Unicode.

=TCHAR= is a legacy from the transitional period and should not be used anymore,
use =wchar_t= only. Always define =UNICODE= (Win32 API) and =_UNICODE= (C
runtime, MFC etc.)


* Opening, Reading, Writing and Closing
  :PROPERTIES:
  :CUSTOM_ID: opening-reading-writing-and-closing
  :END:

Windows File API can specify share mode while Unix files are always shareable.

[[https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew][CreateFile]], =ReOpenFile= (returns a new handle with different flags, access
rights etc.)

[[https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle][CloseHandle]]: closes and invalidates nearly all handle objects.

[[https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile][ReadFile]]:

[[https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile][WriteFile]]:

=GetLastError= (set by =SetLastError=) rather than =errno= ensures that
system errors are unique to the threads. =FormatMessage= turns the
message number into a meaning message.

A Windows process has three standard devices =STD_INPUT_HANDLE=,
=STD_OUTPUT_HANDLE=, =STD_ERROR_HANDLE=, retrieved by =GetStdHandle= and
redirected by =SetStdHandle=.

There are two reserved pathnames =CONIN$= and =CONOUT$= for console
input and output. Use =CreateFile= on them.

A number of filesystem management high-level (command-line tool level) functions
are also provided by Win32. =DeleteFile=, =CopyFile=, =CreateHardLink=,
=CreateSymbolicLink=, =MoveFile=, =MoveFileEx, =CreateDirectory=,
=RemoveDirectory=, =SetCurrentDirectory=, =GetCurrentDirectory=


* Console and unicode
  :PROPERTIES:
  :CUSTOM_ID: console-and-unicode
  :END:

http://archives.miloush.net/michkap/archive/2010/10/07/10072032.html

http://illegalargumentexception.blogspot.com/2009/04/i18n-unicode-at-windows-command-prompt.html

http://illegalargumentexception.blogspot.com/2009/04/java-unicode-on-windows-command-line.html

https://alfps.wordpress.com/2011/11/22/unicode-part-1-windows-console-io-approaches/

https://devblogs.microsoft.com/cppblog/new-options-for-managing-character-sets-in-the-microsoft-cc-compiler/

MSVC internally use UTF-8 for string literals. For unprefixed string
literals, MSVC would treat them based current on the current code page.

Normal strings are output as they are in execution charset (GCC or
MSVC). Execution character sets affect normal byte strings only.

For wide strings, =wprintf= would first convert them based on the set
code page and then output them into stdout.

The following code should have the commented standard-conformant result.

#+BEGIN_SRC C++
    setlocale(LC_ALL, "my_system_locale");
      printf("printf-s-1 %s\n", Test1); // Correct
      printf("printf-s-2 %s\n", Test2); // -N

      printf("printf-ls-1 %ls\n", Test1); // empty and no newline
      printf("printf-ls-2 %ls\n", Test2); // correct

    // For MSVC, these two lines should be the same as the last two
      wprintf(L"wprintf-s-1 %s\n", Test1); // correct output
      wprintf(L"wprintf-s-2 %s\n", Test2); // -N

      wprintf(L"wprintf-ls-1 %ls\n", Test1); // garbage output
      wprintf(L"wprintf-ls-2 %ls\n", Test2); // correct
#+END_SRC

GCC-MSVCRT cannot output wide strings in any meaningful way due to a
[bug][https://yongweiwu.wordpress.com/2016/05/27/msvcrt-dll-console-io-bug/]
in MSVCRT6, with or without =setlocale=, using =%ls= or =%s= on wide
strings or normal strings.

#+BEGIN_SRC C++
  printf-s-1 ?D??
  printf-s-2 -N?e
  printf-ls-2
  wprintf-s-1 ?D??
  wprintf-s-2 -N?e
  wprintf-ls-1
  wprintf-ls-2
#+END_SRC

However, with some perl redirection, GCC-MSVCRT6 works somewhat better,
with or without =setlocale=. Seems MSVCRT6 does some translation when
outputing to the console.

#+BEGIN_EXAMPLE
  printf-s-1 中文 
  printf-s-2 -N噀 
  printf-ls-2
  wprintf-s-1 中文
  wprintf-s-2 -N噀 # actually a UTF-16 "中文"
  wprintf-ls-1
  wprintf-ls-2
#+END_EXAMPLE

Even so, it still has some problems with =wprintf=

GCC-UCRT shows similar behavior to MSVC in that with =setlocale=, wide
strings are output as a converted MBCS and question marks without
=setlocale=.

#+BEGIN_EXAMPLE
  printf-s-1 中文
  printf-s-2 -N噀
  printf-ls-2 中文
  wprintf-s-1 中文
  wprintf-s-2 -N噀
  wprintf-ls-1 ??
  wprintf-ls-2 中文
#+END_EXAMPLE

and MSVC 19.30.30705 gives the following output

#+BEGIN_EXAMPLE
  printf-s-1 中文
  printf-s-2 -N噀
  printf-ls-2 中文
  wprintf-s-1 ??
  wprintf-s-2 中文
  wprintf-ls-1 ??
  wprintf-ls-2 中文
#+END_EXAMPLE

Without setting the locale, these are the results

- GCC-MSVCRT

#+BEGIN_EXAMPLE
  printf-s-1 中文
  printf-s-2 -N噀
  printf-ls-2
  wprintf-s-1 中文
  wprintf-s-2 -N噀
  wprintf-ls-1
  wprintf-ls-2
#+END_EXAMPLE

- GCC-UCRT64

#+BEGIN_EXAMPLE
  printf-s-1 中文
  printf-s-2 -N噀
  printf-ls-2
  wprintf-s-1 中文
  wprintf-s-2 -N噀 
  wprintf-ls-1 ??
  wprintf-ls-2 ??
#+END_EXAMPLE

- MSVC 19.30.30705

#+BEGIN_EXAMPLE
  printf-s-1 中文
  printf-s-2 -N噀
  printf-ls-2 wprintf-s-1 ??
  wprintf-s-2 ??
  wprintf-ls-1 ??
  wprintf-ls-2 ??
#+END_EXAMPLE

=std::cout= and =std::wcout= works in a similar way to =printf("%s")=
and =wprintf("%ls")=.
