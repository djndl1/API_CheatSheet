* The Basic Idea Behind COM

COM emphasizes *interface inheritance*, which provides support for polymorphism,
rather than *implementation inheritance*, simply a mechanism for reusing an
existing implementation that increases coupling between different components
(especially from different vendors) and causes information leak of the base
class.

Implementation inheritance should be restricted within
a component. COM provides *black-box binary reuse* suitable for the component marketplace.

The core concepts of COM are *interfaces*, *classes*, *apartments*, *security*.

* How C++ Library Can Be Binary Reusable
  :PROPERTIES:
  :CUSTOM_ID: the-problem-of-c
  :END:

C++, built on UNIX for monolithic applications using the compiler and
linker technology. Libraries does not always seem to be reusable and
sometimes requires the client user to understand the source code.

** Software Distribution: Not Used to Binary Reuse

Traditionally, C++ libraries have been distributed in source code form
and are expected to be linked into the executable code. The users may choose to
statistically link the code or even compile the code along with the client code.

*Use dynamic linking*!

** Dynamic Linking and Portability: No Standard Binary Reuse

Dynamic linking for C++ lacks standardization at binary level, making it hard to
distribute C++ libraries as dynamic shared libraries:

- *Different name mangling* schemes between compiler vendors prevent
   dynamic linking using different compilers for client code and
   libraries. (Might be worked around using aliases)

- Different compiler vendors implement *language features* in their own
   ways. e.g. exceptions.

** Encapsulation: Binary Reuse Failure Due to Implementation Leaking

C++ has no notion of *binary encapsulation*, only *syntactic encapsulation*.
Object layouts are exposed to the client code.

The compilation of C++ requires the client's compiler to have access to all the
information w.r.t. object layout in order to *instantiate an instance* of a class (e.g. the
change of size but the client code wouldn't know due to the use of
explicit/implicit =sizeof=)
or to *make nonvirtual method calls* (?), which includes info about the size and order
of the the object's private and protected data members.

Working around this with versioning on naming causes system bloat.

Simply exporting C++ class definitions from DLLs does not provide a reasonable
binary component architecture due to /lack of a /standard binary reuse convention/.

** Separating Interface From Implementation

One class as the interface and the other as the implementation. The interfaces
holds a pointer to the implementation (*Pimpl*). The interface class's layout
does not change.

- This approach has some performance implication.

- Pimpl may work for small classes, but may be error-prone in large projects due to the amount of
delegate functions.

- Pimpl does not solve the compiler/linker compatibility issue: non-virtual
  calls require symbol resolution.

To solve compiler incompatibilities (language feature implementation, name
mangling), we may use an *abstract class with pure virtual functions* as the
interface and let *the implementation inherit this interface*
The implementation is *created from a factory function*. An explicit special
*delete* function should be called manually instead of the compiler-dependent destructor.

Virtual calls are *immuned to name mangling* since they are called through
function pointers and the factory method is exposed as a C function.

Combined with dynamic loading, this creates a runtime polymorphism.

** Extensibility: Multiple Facades and Runtime Cast

Directly extending the interface by adding another virtual function breaks
compatibility because the newer client code may be using older library and cannot
find the newer functions.

The solution is to add an extension interface. =dynamic_cast<>()= should be
 prohibited here as it is dependent on
 compiler implemention, in favor of a semantically equivalent virtual
 function =Dynamic_Cast()=, which navigates the type hierarchy and
 =static_cast= the =this= pointer. An old implementation will return a =null= pointer for
 a new interface.

Note that casting to virtual base is another binary compatibility breaker.

** Resource Management: Use Refcount

With multiple multiple interface pointers (owners) to the same object, resource
management becomes error-prone.

Resource management can be done via explicit manual refcounting.
The client simply calls =DuplicatePointer=/=DestroyPointer=,
which can be easily wrapped into a smart pointer.

* Intefaces
  :PROPERTIES:
  :CUSTOM_ID: intefaces
  :END:

** Interface Definition Language

An indepedent interface description language (IDL) that generates
*C/C++ headers* (type definitions), *type library for other languges*.

IDL defines the logical (methods and operations) and physical part (network,
memory, stack frames) of an interface.

#+begin_src idl
[
    object,    // object is required for COM interface
    uuid(4af2d676-23c1-11ee-91bd-8780e5365440) // uuid as a physical name for the interface
]
interface IThisInterface : IBaseInterface {
    typedef1;
    typedef2;
    ..
    method1;
    method2;
    ..
}
#+end_src

*** Syntax

The basic syntax is C-like with annotations, supporting structures, unions, arrays, enums and
typedefs.

*** MIDL/WIDL

*** Result

- =*.h= :: C/C++ type definitions

- =*_i.c= :: GUID defintions

- =*_p.c= :: interface marshaler defintions

- =dlldata.c= :: interface marshaler in-process server code

- =*.tlb= :: type library, for VBA, etc.

** Physical Name

Each interface (=IID_*=) and each class =CLSID_*= have a unique physical name,
annotated by =uuid()=.

- =CoCreateGuid()=, =GUIDGEN.EXE= in SDK are used to generate this GUID.
- COM provides constant reference aliases for each GUID types

  #+begin_src cpp
  #define REFGUID const CUID&
  #define REFIID const IID&
  #define REFCLSID const CLSID&
  #+end_src

- Equivalence functions and C++ equivalence operator overloading

  #+begin_src cpp
  BOOL IsEqualGUID(rguid1, rguid2);
  BOOL IsEqualCLSID(rclsid1, rclsid2);
  BOOL IsEqualIID(riid1, riid2);
  #+end_src

** Parameters

Method parameter directions must be annotated with attributes =[in]=, =[out]=,
=[in, out]=, =[out, retval]= (return value).

** =HRESULT=

Virtually all COM methods return an error number of type =HRESULT=
(32-bit signed integer), which is partitioned by bit into
*Severity-Reserved-Facility-Information*.

=HRESULT= return values are converted exceptions in certain langauges.

- =MAKE_HRESULT= :: define a custom =HRESULT=

- =SUCEEDED=, =FAILED= :: test marcros

#+begin_src
E_ACCESSDENIED  	Access denied.
E_UNEXPECTED        Method Not Implemented
E_FAIL 	      	Unspecified error.
E_INVALIDARG 	    Invalid parameter value.
E_OUTOFMEMORY 	    Out of memory.
E_POINTER 	        NULL was passed incorrectly for a pointer value.
E_UNEXPECTED 	    Unexpected condition.
S_OK 	            Success.
S_FALSE 	        Success. logical false.
#+end_src

** =IUnknown=

The base interface of all COM interfaces (=import "unknwn.idl"=). The implementation is required to
provide an =IUnknown= implementation.

*** Resource Management
   :PROPERTIES:
   :CUSTOM_ID: resource-management
   :END:

**** Basic Refcount Rules

- Call =AddRef= when a non-null interface pointer is copied.

- Call =Release= prior to overwriting memory location that contains a
   non-null interface pointer.

- Redundant calls to =AddRef= and =Release= can be optimized away if
   there is special knowledge about the relationship between two or even
   more memory locations.

**** Returned RefCount

The return refcount by =AddRef= and =Release= are not thread-safe (remote-safe), only
for debugging. =Release= does not nullify the pointer, so the object
might still be valid (due to other interface pointers), even if the interface pointer shouldn't be used.

A zero return from =Release= guarantees the object is invalid.

**** Interface RefCount

=QueryInterface= can only return pointers to the same COM object.
=AddRef= and =Release= are opertions on /an interface pointer/ so that
an object may elect to perform per-interface reference counting to allow
aggressive reclamation of resources.

=QueryInterface= has a type-unsafe =out= =void**=, use =IID_PPV_ARG(Type, Expr)= to
reduce type errors.

** Implementing =IUnknown=
   :PROPERTIES:
   :CUSTOM_ID: implementing-iunknown
   :END:

Use =STDMETHODIMP= and =STDMETHODIMP_= to produce COM-compliant stack
frames.

Use atomic operations for =AddRef= and =Release=. Traverse the type
hierarchy of the object and use static typecasts to return the correct
pointer type for all supported interfaces.

** Data Types
   :PROPERTIES:
   :CUSTOM_ID: data-types
   :END:

- =OLECHAR=: =wchar_t=

- =BSTR=: length-prefixed =OLECHAR= string

- =string=: pointer to a null-terminated array of characters

- =VARIANT=: a common discriminated union

** Attributes and Properties
   :PROPERTIES:
   :CUSTOM_ID: attributes-and-properties
   :END:

- =[propget]=, =[progput]=: =get= =set=

** Exceptions
   :PROPERTIES:
   :CUSTOM_ID: exceptions
   :END:

The objects that throw COM exceptions must implement the
=ISupportErrorInfo= interface to indicate which interfaces support
exceptions. Create an error using =ICreateErrorInfo=, call
=SetErrorInfo= to throw it and =GetErrorInfo= to catch and clear it.

* Classes
  :PROPERTIES:
  :CUSTOM_ID: classes
  :END:

- /Interfaces/: abstract protocol for communicating with an object

- /Classes/ are named (after =CLSID=) implementations that represent
  concrete instantiable types. =ProgID=s are text-based aliases for
  =CLSID=, unique only by convention.

#+BEGIN_SRC C
  HRESULT CLSIDFromProgID();
  HRESULT ProgIDFromCLSID();;
#+END_SRC

A class object acts as the metaclass for a given implementation and the
methods it implements fill the role of static member functions. Class
objects are often used as brokers to create new instances of a class to
find existing instances based on some well-known object name.

** Object Activation
   :PROPERTIES:
   :CUSTOM_ID: object-activation
   :END:

/Object Activation/: Clients need a mechanism for finding class objects,
which may involve loading a DLL or starting a server process, to bring
an object to life.

Object activation is done by sending requests to the COM Service Control
Manager, a central rendezvous point for all activation requests, the
interface of which, called the COM library, is implemented in
=OLE32.DLL= on WinNT.

In-Process COM calls are mostly just virtual calls. Out-of-process COM
calls are called upon /proxies/, which translates between method
invocations and RPC requests.

*** Using SCM
    :PROPERTIES:
    :CUSTOM_ID: using-scm
    :END:

- =CoGetClassObject=: creates a class object, which in turn can be used
  to create instances of the class, most likely through =IClassFactory=.
  The function locates t he code associated with the =CLSID=. This
  function underlies all ofthe instance creation functions.
