#+TITLE: Sql General

* Background

** Relationnal Model

Data are represented as sets of tables. Redundant data is used to link records in different tables.

Normalization: refining a database design to ensure that each independent piece of information is in only one place

*** Terms

- *Entity*: something of interest to the database user community

- *Result Set*: a nonpersistent table, generally the result of an SQL query

- schema statement, data statement, transaction statement

*** Execution Process

1. Check permissions on the statement and data

2. Check the syntax

3. Query optimizer determines the most effective way to execute the query and picks an *execution plan*

* SQL

** Tables

- Permanent Tables (=create table=)

- Derived tables (rows returned by a subquery and held in memory)

- temporary tables (volatile data held in memory)

- Virtual tables (=create view=)

** Advanced SQL

- =order by position_number=

 #+begin_src sql
select c.first_name, c.last_name,r.rental_date
from customer c
inner join rental r
on c.customer_id = r.customer_id
ORDER BY 3 asc;
 #+end_src

- =REGEXP=: oracle =regexp_like=, MSSQL allows =like= used with regex

- An expression can be (IS) =null=, but can never == NULL=.

- =order by= is directly appended to =union all= without an outer query.

- The intersect operator to have precedence over the other set operators.

- =rollup=, =cube= (all column combinations): to aggregate over subgroups, groups and the entirety.

- =all=, =any=/=some= with subqueries: comparison and then and/or

When using not in or <> all to compare a value to a set of values, be careful to ensure that the set of values does not contain a null value. Using == any= is equivalent to using the in operator.

- tuple =IN=: without writing multiple subqueries and =IN= clauses

Subqueries are used heavily in update, delete, and insert statements as well, with correlated subqueries appearing frequently in update and delete statements.

- Avoid natural join.

*** Common Table Expressions

Each subquery can refer to any other subquery defined previously

*** Conditional Logic

#+begin_src sql
--- Pivot a result set
SELECT
  SUM(CASE WHEN monthname(rental_date) = 'May' THEN 1
        ELSE 0 END) May_rentals,
  SUM(CASE WHEN monthname(rental_date) = 'June' THEN 1
        ELSE 0 END) June_rentals,
  SUM(CASE WHEN monthname(rental_date) = 'July' THEN 1
        ELSE 0 END) July_rentals
FROM rental
WHERE rental_date BETWEEN '2005-05-01' AND '2005-08-01';

--- conditional update
UPDATE customer
SET active =
  CASE
    WHEN 90 <= (SELECT datediff(now(), max(rental_date))
                FROM rental r
                WHERE r.customer_id = customer.customer_id)
      THEN 0
    ELSE 1
  END
WHERE active = 1;
#+end_src

* Transactions

*** Locking

Two strategies employed by different DBs:

- read-write lock

- versioning: the reader is not required to acquire a reader lock, the versioning mechanism ensures that the reader sees a consistent view of the data

*** Lock granularities

- table locks

- page locks

- row locks
