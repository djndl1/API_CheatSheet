#+title: ADO.NET

A family of .NET technologies to interact with data in standard, structured,
and primarily /disconnected/ ways. ADO.NET concepts are based loosely on their
relational databvase counterparts.

- The Two Parts
  + /DataSet/:
    - =DataTable=: the core; tables can be grouped into =DataSet=
      + =DataColumn=: defines the data type
      + =DataRow=: CRUD
    - =DataRelation=: links between the tables of data
    - =DataView=: a limited or modified view of the rows in =DataTable=
    - =Constraint=: unique, foreign key
  + /Data Provider/: DataAdapter, DataReader: part that
    provides DataSet.
    - Connection: communcation with external data sources
    - Command: SQL queries and data management
    - DataAdapter: stores standard query defintions for interacting with a
      database, removing the tedium of constantly needing to build SQL
      statements.
    - DataReader: fast, read-only access to the results of a query.

* Data Set

Visual Studio provides a visual DataSet designer that can define and store a =DataSet=
inside an =.xsd= file rather than using code.

** DataTable

A /logical implementation/ of a table of data.

- =DataTable=
  + a few events are provided. Triggers can be simulated with these events.
  + =AcceptChanges()= commits a logical transaction or =RejectChanges()= to roll
    back. Transcations are automatically started for CRUD methods.


- =DataColumn=: included within =DataTable.Columns=. Types allowed are limited,
  similar to how a RDBMS provides.
  + =AutoIncrement=, =AutoIncrementSeed=, =AutoIncrementStep=

- =DataRow=:
  - States are maintained for each row: =Detached=, =Added=, =Unchanged=,
    =Deleted=, =Modified=. =Rows.Remove()=, =Rows.RemoveAt()= circumvents this
    state tracking (Use =DataRow.Delete()= for transaction).
  - be careful when working with items since they are not strongly typed.
  - =DataTable.NewRow()= only creates a =DataRow=, use =.Add()= to add it to the
    table.
  - ADO.NET keeps multiple copies of each changed value of a row =DataRowVersion=
    + =Proposed=, =Original=
    + =Current=: based on the state, might be =Proposed= or =Original=
    + =Default=: based on whether a row is attached to a =DataTable=.

*** Validation

Data exceptions are thrown on =DataRow.EndEdit()=, including type mismatch, data
length, nullability issues, constraint violation.

The user may also take advantage of =DataTable='s events for data validation.
The client check =DataRow.HasErrors= and =DataTable.HasErrors= for any error and
then retrieve them with =DataTable.GetErrors()=, =DataRow.GetColumnsInError()=,
=DataRow.GetColumnError()=, =DataRow.RowError=

*** Search, Sorting and Expression

- =DataRowCollection.Find()= by primary key

- =DataTable.Select()= with SQL-like syntax

- =DataColumn.Expression= for virtual columns

** =DataSet=

Schema-like object that links multiple tables together.

*** Relations

- One-to-One (the optional one is the child)

- One-to-Many (parent-to-childs). =GetParentRow()=, =GetChildRows()=

- Many-to-Many: there may be a go-between table that has a composite primary key
  as the child. Or the foreign key
  may not be unique (mutually one-to-many). =GetParentRows()=

#+begin_src csharp
DataTable studentTable = new DataTable("Student");

studentTable.Columns.Add("ID", typeof(long));
DataTable classTable = new DataTable("Class");

classTable.Columns.Add("ID", typeof(long));
DataTable interimTable = new DataTable("StudentClassInterim");

interimTable.Columns.Add("StudentID", typeof(long));
interimTable.Columns.Add("ClassID", typeof(long));

// ----- Make the linking fields unique.
Constraint interimKey = new UniqueConstraint(
new DataColumn[] { interimTable.Columns["StudentID"],
                   interimTable.Columns["ClassID"] }, true);
interimTable.Constraints.Add(interimKey);

// ----- Relations exist within a data set context.
DataSet registration = new DataSet("Registration");
registration.Tables.Add(classTable);
registration.Tables.Add(studentTable);
registration.Tables.Add(interimTable);

// ----- Add standard joins between the core tables and the interim.
DataRelation joinPart = new DataRelation("ClassToStudent",
                                         classTable.Columns["ID"],
                                         interimTable.Columns["ClassID"], true);
registration.Relations.Add(joinPart);
joinPart = new DataRelation("StudentToClass",
                            studentTable.Columns["ID"],
                            interimTable.Columns["StudentID"], true);
registration.Relations.Add(joinPart);
#+end_src

*** Constraint

- =UniqueConstraint=

- =ForeignKeyConstraint=: by default also sets the linking columns unique.

*** Aggregation

- =DataTable.Compute=

** Indexed View =DataView=

An indexed reference to each row in the linked =DataTable=.
A =DataView= can be filtered, sorted.

** Serialization With XML

ADO.NET includes full schema definition support using Schema Definition
Language (XSD).

* External Data Sources

Four crucial classes of an ADO.NET provider: Connection, Command, DataAdapter, DataReader

** Connection

Connections are pooled. The ODBC provider relies on the underlying ODBC manager to provide pooling capability.

- =Open()= the connection before anything else; =Dispose()= or =Close()= it after using.

** Command

Executes SQL or stored procedures.

A command must be associated with a Connection. It may supports text SQL, stored procedure.

** Parameter

=Command.Parameters= can define the data type for simple data. For ODBC and OLE providers, named parameters are not supported.

** DataAdapter

Links external database tables and local =DataSet=-managed tables by issuing SQL statements.

*** Data Retrieval

- =DataAdapter.Fill()=  requests data using a valid =SELECT= statement or a stored procedure using =DataAdapter.SelectCommand=.

*** Data Modification

- =DataAdapter.InsertCommand=, =DataAdapter.UpdateCommand=, =DataAdapter.DeleteCommand=: the client adds these commands and fills them with appropriate parameters and call =DataAdapter.Update()= to persist the changes back to the data store.

- =DataAdapter= can be used with =CommandBuilder= to automatically generate the three modification commands that handles rows dynamically.
  + used only with single-table queries
  + requires the table have at least one primary key or a unique value.
  + non-standard names (e.g. with space characters) are not supported.

*** Table-Column Name Mapping

- =DataTableMapping= added to =DataAdapter.TableMappings=

- =DataColumnMapping= added to =DataTableMapping=;

Missing mappings can be handled by the adapter automatically
with =DataAdapter.MissingMappingAction= and =DataAdapter.MissingSchemaAction=

