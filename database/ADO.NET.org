#+title: ADO.NET

A family of .NET technologies to interact with data in standard, structured,
and primarily /disconnected/ ways. ADO.NET concepts are based loosely on their
relational databvase counterparts.

- The Two Parts
  + /DataSet/:
    - =DataTable=: the core; tables can be grouped into =DataSet=
      + =DataColumn=: defines the data type
      + =DataRow=: CRUD
    - =DataRelation=: links between the tables of data
    - =DataView=: a limited or modified view of the rows in =DataTable=
    - =Constraint=: unique, foreign key
  + /Data Provider/: DataAdapter, DataReader: part that
    provides DataSet.
    - Connection: communcation with external data sources
    - Command: SQL queries and data management
    - DataAdapter: stores standard query defintions for interacting with a
      database, removing the tedium of constantly needing to build SQL
      statements.
    - DataReader: fast, read-only access to the results of a query.

* Data Set

Visual Studio provides a visual DataSet designer that can define and store a =DataSet=
inside an =.xsd= file rather than using code.

** DataTable

A /logical implementation/ of a table of data.

- =DataTable=
  + a few events are provided. Triggers can be simulated with these events.
  + =AcceptChanges()= commits a logical transaction or =RejectChanges()= to roll
    back. Transcations are automatically started for CRUD methods.


- =DataColumn=: included within =DataTable.Columns=. Types allowed are limited,
  similar to how a RDBMS provides.
  + =AutoIncrement=, =AutoIncrementSeed=, =AutoIncrementStep=

- =DataRow=:
  - States are maintained for each row: =Detached=, =Added=, =Unchanged=,
    =Deleted=, =Modified=. =Rows.Remove()=, =Rows.RemoveAt()= circumvents this
    state tracking (Use =DataRow.Delete()= for transaction).
  - be careful when working with items since they are not strongly typed.
  - =DataTable.NewRow()= only creates a =DataRow=, use =.Add()= to add it to the
    table.
  - ADO.NET keeps multiple copies of each changed value of a row =DataRowVersion=
    + =Proposed=, =Original=
    + =Current=: based on the state, might be =Proposed= or =Original=
    + =Default=: based on whether a row is attached to a =DataTable=.

*** Validation

Data exceptions are thrown on =DataRow.EndEdit()=, including type mismatch, data
length, nullability issues, constraint violation.

The user may also take advantage of =DataTable='s events for data validation.
The client check =DataRow.HasErrors= and =DataTable.HasErrors= for any error and
then retrieve them with =DataTable.GetErrors()=, =DataRow.GetColumnsInError()=,
=DataRow.GetColumnError()=, =DataRow.RowError=

*** Search, Sorting and Expression

- =DataRowCollection.Find()= by primary key

- =DataTable.Select()= with SQL-like syntax

- =DataColumn.Expression= for virtual columns

** =DataSet=

Schema-like object that links multiple tables together.

*** Relations

- One-to-One (the optional one is the child)

- One-to-Many (parent-to-childs). =GetParentRow()=, =GetChildRows()=

- Many-to-Many: there may be a go-between table that has a composite primary key
  as the child. Or the foreign key
  may not be unique (mutually one-to-many). =GetParentRows()=

#+begin_src csharp
DataTable studentTable = new DataTable("Student");

studentTable.Columns.Add("ID", typeof(long));
DataTable classTable = new DataTable("Class");

classTable.Columns.Add("ID", typeof(long));
DataTable interimTable = new DataTable("StudentClassInterim");

interimTable.Columns.Add("StudentID", typeof(long));
interimTable.Columns.Add("ClassID", typeof(long));

// ----- Make the linking fields unique.
Constraint interimKey = new UniqueConstraint(
new DataColumn[] { interimTable.Columns["StudentID"],
                   interimTable.Columns["ClassID"] }, true);
interimTable.Constraints.Add(interimKey);

// ----- Relations exist within a data set context.
DataSet registration = new DataSet("Registration");
registration.Tables.Add(classTable);
registration.Tables.Add(studentTable);
registration.Tables.Add(interimTable);

// ----- Add standard joins between the core tables and the interim.
DataRelation joinPart = new DataRelation("ClassToStudent",
                                         classTable.Columns["ID"],
                                         interimTable.Columns["ClassID"], true);
registration.Relations.Add(joinPart);
joinPart = new DataRelation("StudentToClass",
                            studentTable.Columns["ID"],
                            interimTable.Columns["StudentID"], true);
registration.Relations.Add(joinPart);
#+end_src

*** Constraint

- =UniqueConstraint=

- =ForeignKeyConstraint=: by default also sets the linking columns unique.

*** Aggregation

- =DataTable.Compute=

** Indexed View =DataView=

An indexed reference to each row in the linked =DataTable=.
A =DataView= can be filtered, sorted.

** Serialization With XML

ADO.NET includes full schema definition support using Schema Definition
Language (XSD).

* External Data Sources

Four crucial classes of an ADO.NET provider: Connection, Command, DataAdapter, DataReader

** Connection

Connections are pooled. The ODBC provider relies on the underlying ODBC manager to provide pooling capability.

- =Open()= the connection before anything else; =Dispose()= or =Close()= it after using.

** Command

Executes SQL or stored procedures.

A command must be associated with a Connection. It may supports text SQL, stored procedure.

** Parameter

=Command.Parameters= can define the data type for simple data. For ODBC and OLE providers, named parameters are not supported.

** DataAdapter

Links external database tables and local =DataSet=-managed tables by issuing SQL statements.

*** Data Retrieval

- =DataAdapter.Fill()=  requests data using a valid =SELECT= statement or a stored procedure using =DataAdapter.SelectCommand=.

*** Data Modification

- =DataAdapter.InsertCommand=, =DataAdapter.UpdateCommand=, =DataAdapter.DeleteCommand=: the client adds these commands and fills them with appropriate parameters and call =DataAdapter.Update()= to persist the changes back to the data store.

- =DataAdapter= can be used with =CommandBuilder= to automatically generate the three modification commands that handles rows dynamically.
  + used only with single-table queries
  + requires the table have at least one primary key or a unique value.
  + non-standard names (e.g. with space characters) are not supported.

*** Table-Column Name Mapping

- =DataTableMapping= added to =DataAdapter.TableMappings=

- =DataColumnMapping= added to =DataTableMapping=;

Missing mappings can be handled by the adapter automatically
with =DataAdapter.MissingMappingAction= and =DataAdapter.MissingSchemaAction=

** Transaction

- Atomicity (unit of work), Consistency (valid state),
  isolation (from other transactions, often implemented as a record-locking function, not efficient for scalable distributed systems),
  durability (data are recoverable)

- /Concurrency/
  + /pessimistic concurrency/: records in question are locked when first accessed and released after modification.
  + /optimistic concurrency/: lcoked only at the moment of update; good for records that are rarely or neven accessed by two users.
  + ADO.NET, which focus on disconnected data processing, uses optimistic concurrency.

- .NET Framework supports distributed transactions through Microsoft Distributed Transaction Coordinator, which allows an ACID-enabled
   transaction to span multiple databases on different servers.
   + =System.Transactions.TransactionScope= provides automatic distributed transactions.


* Provider-Specific Features

** ODP.NET

*** Parameter Binding

- =OracleCommand.BindByName= defaults to =false=. The DapperLib tries hard to set it.

**** Array Binding

The array bind feature enables applications to bind arrays of a type using the OracleParameter class.
Using the array bind feature, an application can insert multiple rows into a table in a single database round-trip.

- =OracleParameter.ArrayBindCount=: set to the count of parameters.

- =OracleParameter.ArrayBindSize=: the maximum size for each corresponding value in an array, used only for =Clob=, =Blob=, and =Varchar2=.
  Inferred from the actual size of the value if not explicitly set.

- =OracleException.Errors=: contains the errors of the related bound parameters.

* EntityFramework

Focus on the conceptual view of how data fits together instead of on the phsical view of how it is stored
in the database and mmove away from the database-centric reality of independent tables joined in relationship towards a OO model.

EF works with flat, relational and hierarchical data sources.

** EF6

- /Model/

- /entity/: similar to a record, a row but in a more conceptual manner

- /entities/: a generic collection of a specific entity.
  + /entity set/: the logical container for an entity and any other entities derived form that first entity.
  + /entity container/: a context, similar to =DataSet= or a database.
    An entity container includes entity sets and association sets.

- /property/
  + /navigation property/: exposes the available data at the other end of an association.

- /association/: a relationship between two entities. True bidirectional access points between entity instances.
  + /association ends/: the properties on the ends of the relationship
  + /multiplicity/: one-to-one, one-to-many and so on
  + /association set/: all association instances for a defined association type

*** Layers

- /Conceptual Layer/: entity data model
  + /Conceptual Schema Definition Language/

- /storage model/ or /logical model/: defines the application-side experience of a database-side logical implementation.
  + includes entity and association definitions.
  + /Store Schema Definitiion Language/

- /Model Mapping/: the glue between conceptual model and the storage model.
  + /Mapping Specification Language/

*** Use

1. Write/Design the XML model. Full XML documentation is available.

2. Generate code from the model. =edmgen.exe=, =EntityObject=

3. Instantiate a context =System.Data.Objects.ObjectContext=

4. Query
   + Entity SQL language: fully string-based query language with =System.Data.Objects.ObjectQuery=, similar to ADO.NET and primitive
   + Query builder: partially finished LINQ still with some strings that returns =ObjectQuery<T>=, which implements =IQueryable=
   + LINQ
   + queries via HTTP requests using WCF

*** Object Services

**** Entities

- =EntityObject=: base class for all entities

- =ComplexObject=

- =ObjectSet<TEntity>=

- =ObjectQuery<T>=

- =ObjectContext=: entity container

