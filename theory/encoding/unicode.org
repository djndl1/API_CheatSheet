#+TITLE: Unicode

* Prerequisites

** Endianness

Normally this refers to byte endianness, but information can be stored in small or large groups of binary bits. So endianness might refer to endianess of bits (bit numbering, typically used in low-level transmission protocol), octets, hextets, words, etc. The most common positional notation used in mathematics is digit-big-endian: =123456=, with the most significant digit at the first place.

In computing, endianness refers to the ordering of a sequence of storage cells (usually in octets) that represents a primitive data type that can be manipulated by a single hardware instruction. Typically, the first storage cell would be at the lower address of memory. The relation between "significance" of a storage cell in the data and its order determines the endianness.

- /big-endianness/: decreasing numeric significance with increasing memory addresses (or increasing time)

- /little-endianness/: increasing numeric significance with increasing memory addresses (or increasing time)

Some architectures uses different byte endianness for integers and floating-point numbers. Some even has different endianness conventions for words and bytes inside a double-precision number.

Side note: in C, the index of an array member increases with its pointer
(virtual memory address).

** Writing Systems

- /Alphabetic scripts/

- /Consonant scripts/, /abjads/

- /Abugida scripts/

- /Syllabic scripts/

- /Ideographic scripts/

** Font

An organized set of glyphs.

A font may have the same glyph for different characters or multiple glyphs for
the same character.

Font data may be embedded into a document so that the document can be presented
as designed.

- *typeface*: the basic design of glyphs, the word "font" for particular
  implementations and variants.

*** Classification

- *Serif*

- *Sans Serif*

- *Monospace*, contrast with *proportional*

- *Cursive*

- *Fantasy*

*** Implementations

- Bitmap/raster fonts

- Postscript Type 1

- TrueType =ttf=

- OpenType: unicode oriented and more platform-independent.

** Character Encodings

The process of presenting characters in digital form as sequences of octets.

All these code points make up a /code space/, /code page/ (originally coded in
graphics hardware in IBM PC) or a /character map/.

The word /character set/ should be understood as the set of internal
representation of characters, a.k.a character encoding instead of character repertoire.

- /grapheme/: the smallest functional unit of a writing system in linguistics.
  Not every grapheme is represented in Unicode as a single code point. Some are
  represented by a sequence of two or more Unicode characters.

- /glyph/: a specific shape that represents any particular grapheme in a given
  typeface, a visible manifestation of a character.

- /character/:  a minimal unit of text with semantic value

- /character set/: a collection of characters that might be used by multiple languages

- /coded character set/: a character set in which each character corresponds to a unique number

- /code point/: any allowed value in a coded character set, consisting of one or more code units.

- /code space/: a set of code points

- /code unit/ or /code value/: a bit sequence to encode each character of a repertoire (the abstract set of characters of concern) within a given encoding form.

* [[https://home.unicode.org/][Unicode]]

A standard for the consistent encoding, representation, and handling of text expressed in most of the world's writing systems. Maintained by the Unicode Consortium.

Unicode can be implemented by different character encodings: UTF-8, UTF-16,
UTF-32 and even GB18030.

** Abstract Character

A Unicode character is an abstract concept, not defined by a glyph, a name, a
phoneme but a symbol whose various representations are understood to mean the
same thing by a community of people.

- Has no particular stylistic appearance as long as the designs can be
  recognized by the same character.

- Has an official name but no fixed name across languages.

- Has no fixed pronunciation.

- May have very specific usage or a broad range of different uses.

The intuitive concept of character varies by language and cultural background.
Similar characters in different writing systems are not merged and some special
forms in shape are not considered the same character.

A character is ultimately rendered by an image, but an image is not necessarily
encoded into a Unicode character.

Encoding a character is not just about assigning a number to it: it is about
giving it an /identity/. The unicode name of a character is also its unique
identity. Such identities can be extended to traditional text processing so that
a character can be unmistakenly specified.

*** Character Processing Operations

- searching, replacing, sorting, copying, indexing, modifying, computing
  statistics, spelling and grammar checks; automatic translation

- rendering with fonts; bolding, italics and other features; forming ligature;
  adjusting spacing;

** Notation

Uppercase for Unicode names; =U+XXXX= for code points.

** Character definition

- [[https://unicode.org/charts/][Code Charts]]

- Many different characters may look similar, but mixing them may cause issues
  with computerized text processing. Unicode sometimes even uses the same glyph for
  different characters.

- Some characters are defined to be variants of other characters e.g.
  compatibility equivalence.

** [[https://www.rfc-editor.org/rfc/rfc2130.txt][IAB Model]]

- Coded Character Set

- Character Encoding Scheme

- Transfer Encoding Syntax: e.g. Base64, BinHex, Quoted Printable, uuencode, since the recipient may not be able to
  handle all octets properly (having inappropriate assumptions about the underlying charsets).

** Unicode Model

- Abstract Character Repertoire

- Coded Character Set

- Character Encoding Form

- Character Encoding Scheme

/Character Map/: A mapping of character strings (sequences of abstract
characters) to sequences of octets, ignoring the intermediate levels.

** Terminology

- /Code plane/: divided into seventeen planes.
  + /Basic Multilingual Plane/ (BMP): accessed as a single code unit in UTF-16.
  + the latter planes are encoded in four bytes in UTF-8 and surrogate pairs in
    UTF-16.
  + /block/: further division within a plane.

- /General Category/: a property of code points.
  + Letter, Mark, Number, Punctuation, Symbol, Separator, Other

** Issues

- Han Unification, alternative CJK encoding, Unicode variation sequences.

- Combining characters are often not rendered correctly.

** ISO 10464 (UCS)

A standard set of character originally defined by ISO, later synchronized with Unicode, currently a subset of Unicode.

** UTF-16

The original Unicode encoding scheme (UCS-2) was not sufficient and UCS-4 was too space-inefficent.

BMP code points can be directly encoded with 2 bytes. Supplementary planes are encoded as two 1-bite code units called /surrogate pair/, following a certain algorithm (which requires subtraction, bit-shift and addition).

#+begin_quote
U+10437

1. subtracting 0x10000 leaves 0x0437
2. right shift by 10 and add 0xD800 = 0xD801 (high surrogate)
3. take the lower 10 bits and add 0xDC00 = 0xDC37
#+end_quote

** UTF-8

The one-byte part are the same as US-ASCII.

The multibyte-byte parts starts with a header byte and several continuation bytes with =10= as their markers. There are three types of bytes: leading bytes (starts with several =1= and then a =0=), continuation bytes (starts with =10=) and ascii bytes (starts with a =0=)

#+begin_src python
A # 0_1100001
α # 110_01110 10_110001
中 # 1110_0100 10_111000 10_101101
#+end_src

*** Advantages

- Backward compatibility with ASCII and thus related technology. ASCII-related algorithms can be easily applied to UTF-8 (character searching in UTF-8 is just a word-searching of the ASCII version)

- Fallback and auto-detection: it can efficiently detect some error values and successful in the majority of cases.

- Prefix Code: the leading byte can indicate the length of the encoded character.

- Self Synchronization: easy to find and synchronize with the start of a character byte sequence

- Ignore UTF-16 byte order mark

- No special locale and language settings needed

*** Disadvantages

- Less space efficient than specilized local encodings.

** UTF-32

Mainly used where the data is a single code units or glyph rather than string of
characters.
