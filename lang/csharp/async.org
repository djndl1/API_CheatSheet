[[https://dschenkelman.github.io/2013/11/29/asynchronous-io-in-c-why-tasks-a-k-a-promises-futures/][C# Futures]]

* Asynchronous Programming Model
  :PROPERTIES:
  :CUSTOM_ID: asynchronous-programming-model
  :END:

=IAsyncResult= and =BeginOperationName=/=EndOperationName= method pairs

1. =BeginOperationName= starts the async operation and returns an
   =IAsyncResult= which stores information about an asynchronous
   operation. It returns control to the calling thread immediately. A
   callback on completion may be supplied.

2. The =IAsyncResult= is supplied to =EndOperationName=. If the async
   operations hasn't been completed, the method call blocks.

#+BEGIN_EXAMPLE csharp
        public interface IAsyncResult
        {
            bool IsCompleted { get; }

            WaitHandle AsyncWaitHandle { get; }


            object? AsyncState { get; }

            bool CompletedSynchronously { get; }
        }
#+END_EXAMPLE

** Typical Usage
   :PROPERTIES:
   :CUSTOM_ID: typical-usage
   :END:

#+INCLUDE: "async/ProgramWithAPM.cs" src csharp

1. Blocking execution by ending an async operation: the app cannot
   continue to do other work without getting the result of the async
   operation.
   - =EndOperationName(IAsyncResult)=
   - =IAsyncResult.AsyncWaitHandle.WaitOne()=, =WaitHandle.WaitAll()=,
     =WaitHandle.WaitAny()=

2. Use =IsCompleted= to poll for the status of an asynchronous operation

3. Use an =AsyncCallback= delegate with =EndOperationName()= inside to end an asynchronous operation.

** Async Delegate with =BeginInvoke()= and =EndInvoke()=

- =BeginInvoke= initiates the async call with an =AsyncCallback= and an object passed to the callback in addition to its normal parameters. The callback is executed on a =ThreadPool= thread.

- =EndInvoke()= retrieves the results of the asynchronous call.


* Event-Based Asynchronous Patterns
  :PROPERTIES:
  :CUSTOM_ID: event-based-asynchronous-patterns
  :END:

A single async method and a corresponding MethodNameCompleted event.
Classes can optionally support cancellation, progress reporting and
incremental results for each asynchronous method. An asynchronous method
may also support multiple pending calls (multiple concurrent
invocations), allowing your code to call it any number of times before
it completes other pending operations (/multiple-invocation/, which can
be queried through an extra parameter =userState=).

#+INCLUDE: "async/ProgramWithEvents.cs" src csharp


a =Task= is control flow running in another dimension, in a more
abstract level than threading.


[Task.Wait and Inlining][https://devblogs.microsoft.com/pfxteam/task-wait-and-inlining/]

* Task-Based Asynchronous Programming

#+INCLUDE "async/TaskWrapper.cs" src csharp

Overrall, this model is still event-based, the code inside =ContinueWith= or after =await= is the callback, that is, called after the task's
is completed (faulted, cancelled or successfully ran to completion).

* Error Handling

 An Exception that occurred in the task's code does not interrupt the execution flow. The task's status and other properties must be checked to see the task's consequence. Thus A try-catch-block does not work on =Task.Start()= since the control flow possibly moves out of the block long before the exception occurs.

For an asynchronous task, any exception is aggregated into
=AggregateException=. A continuation on fault can act as an exception
handler, otherwise, waiting on a faulted task or trying to get the
result will throw an =AggregationException=.

If an exception that occurs within a task goes entirely
unobserved---that is, (1) it isn't caught from within the task; (2) the completion of the task is never observed, via =Wait()=, =Result=, or accessing the Exception property, for example; and (c) the faulted
=ContinueWith()= is never observed---then the exception is likely to go unhandled entirely, resulting in a process-wide unhandled exception.

* Cancellation

It is a bad idea to rudely abort a thread. Cancel any unfinished tasks rather than allow them to run during application shutdown.
The cancellation token used by the task operation must be the same as
the one passed to the task instance to guarantee a successful cancellation, otherwise it's a faulted task.

A task must throw =OperationCanceledException= when cancelled to mark the task canceled.

For simple tasks, =CancellationToken= isn't much different from a simple atomic boolean. =CancellationToken= supports callbacks (=Register= a callback on cancellation) and =WaitHandle= (used for a cancellable wait), a tool with much more advanced functionality and uses.

* Async/Await

TAP was created to address these key problems:

• There is a need to allow long-running activities to occur without
blocking the UI thread.

• Creating a new thread (or Task) for non CPU-intensive work is
relatively expensive when you consider that all the thread is doing is
waiting for the activity to complete.

• When the activity completes (either by using a new thread or via a
callback), it is frequently necessary to make a thread synchronization
context switch back to the original caller that initiated the activity.

From an even-based POV, anything after =await= is the callback code executed when the awaited async operation is done. A series of await is the same as a series of continued and wrapped tasks. In this example, async/await seems more of syntax sugar with exceptions and results automatically unwrapped and a few synchornization stuff.

#+begin_src csharp
static void DownloadAndBlur()
{
  var url = "https://...jpg";
  var fileName = Path.GetFileName(url);
  DownloadImage(url).ContinueWith(task1 =>
  {
    var originalImageBytes = task1.Result;
    var originalImagePath = Path.Combine(ImageResourcesPath, fileName);
    SaveImage(originalImageBytes, originalImagePath).ContinueWith(task2 =>
    {
      BlurImage(originalImagePath).ContinueWith(task3 =>
      {
        var blurredImageBytes = task3.Result;
        var blurredFileName = $"{Path.GetFileNameWithoutExtension(fileName)}_blurred.jpg";
        var blurredImagePath = Path.Combine(ImageResourcesPath, blurredFileName);
        SaveImage(blurredImageBytes, blurredImagePath).ContinueWith(task4 =>
        {
          done = true;
        });
      });
    });
  });
}

static async void DownloadAndBlur()
{
  var url = "https://...jpg";
  var fileName = Path.GetFileName(url);
  var originalImageBytes = await DownloadImage(url);
  var originalImagePath = Path.Combine(ImageResourcesPath, fileName);
  await SaveImage(originalImageBytes, originalImagePath);
  var blurredImageBytes = await BlurImage(originalImagePath);
  var blurredFileName = $"{Path.GetFileNameWithoutExtension(fileName)}_blurred.jpg";
  var blurredImagePath = Path.Combine(ImageResourcesPath, blurredFileName);
  await SaveImage(blurredImageBytes, blurredImagePath);
  done = true;
}
#+end_src

=async= methods are not the same as normal =Task=s. An async task is
already started by the time a =Task= is returned. =await= only signifies the execution yieding and the result unwrapping. However, the control will return to the first calling method without =await= (looks similar to how a =Task= is run) on its firsts opportunity.
The underlying implementation is to string them together in the semantic equivalent of =Task.ContinueWith()= except that all of the code between the await operators will execute in the caller's synchronization context. =async=/=await= is a superior =Task.ContinueWith= with similar semantics, execution flow, better synchornization and exception handling.

For an async task invoked on the UI thread, regardless of whether the
await statements occur within an iteration or as separate entries, they will execute serially, one after the other and in the same order they were invoked from the calling thread.

However, =await= is not suitable for fire-and-forget, since there's no way to execute the code after the await before the async method compeletes. Continue a =Task= with =TaskContinuationOptions.OnlyOnFaulted= instead.

An asynchronous task is not necessarily on a new thread, IO-bound async tasks are inheritantly asynchronous without a new thread since they are handled by the OS and the low-level hardware interrupt mechanism.

** Async Streams (C# 8.0)
   :PROPERTIES:
   :CUSTOM_ID: async-streams-c-8.0
   :END:

Asynchronous streams are supported to enable asynchronous iteration and
the building of asynchronous collections and enumerable type methods
using yield return.

TODO

** Task Scheduler and The Synchrnonization Context
   :PROPERTIES:
   :CUSTOM_ID: task-scheduler-and-the-synchrnonization-context
   :END:

=TaskScheduler= by default uses the thread tool to schedule tasks
appropriately, determining how to safely and efficiently execute them,
when to reuse them, dispose them or create them.

The synchronization context: a task executes and in turn the
continuation tasks execute. The awaiting task consults the
synchronization context so that a task can execute efficiently and
safely.

The Synchronization context gets set automatically for types of
applications where that is critical.

* =async void=: Non-Option
  :PROPERTIES:
  :CUSTOM_ID: async-void-non-option
  :END:

The guideline is to avoid =async void= methods unless they are
subscribers to an event handler.

Without a returned handle, an =async void= gives no way to know if it
has been completely executed and to handle an exception. Any exception
thrown on an =async void= method likely ends up on the UI
=SynchronizationContext= effectively an unhandled exception.

* Async/Await with the Windows UI
  :PROPERTIES:
  :CUSTOM_ID: asyncawait-with-the-windows-ui
  :END:

One of the key advantages of the =async=/=await= pattern is that it
leverages the synchronization context to ensure that continuation
work---work that appears after the await statement---will always execute
on the same synchronization task that invoked the await statement. This
approach is of significant value because it eliminates the need to
explicitly switch back to the UI thread to update a control.

#+INCLUDE


* =Task.Yield=

Basically just attempting an empty task for a potential task scheduler intervention
to redirect the execution flow.
Since some UI messages are of lower priority than user's input messages, calling
=await Task.Yield()= might not keep the UI responsive at all. For a non-UI thread,
it's probably just a thread switch.

#+begin_src csharp
await Task.Factory.StartNew(
    () => {},
    CancellationToken.None,
    TaskCreationOptions.None,
    SynchronizationContext.Current != null?
        TaskScheduler.FromCurrentSynchronizationContext():
        TaskScheduler.Current);
#+end_src
