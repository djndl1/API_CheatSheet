# Threading

- /Thread/: the basic unit to which an operating system allocated processor time.

- /Thread Context/: all the information the thread hnneds to seamlessly resume execution, including the thread's set of CPU registers and stack.

* Thread

** =System.Threading.Thread=

- =ThreadState=: of interest only in a few debugging scenarios.
  + thread abortion is not longer supported in new dotnet, better use a process for such code.

- =IsBackground=: Either foreground threads or background threads: foreground threads keep the process alive.
  + the main application thread is a foreground thread
  + any thread created by a =Thread= class constructor without setting it to background later is a foreground one
  + all threads that enter the managed execution environment from unmanaged code is by default background
  + thread pool threads are by default background.

- External unmanaged threads in COM: the CLR checks in its TLS if the thread is already a CLR thread, if not, a new =Thread= object is created and installed in the TLS of that thread.

- Thread Procedure Parameters: =ParameterizedThreadStart= might do, but a more type-safe way is to encapsulate both the thread procedure and the data fields into a worker object, and pass the thread procedure that uses the internal state of the worker object to the =Thread= object.

- Thread Return value:
  + pass a callback to the thread procedure to call.

- =CurrentCulture= (culture-sensitive oprations as parsing and formatting, string comparison and sorting and also controls the writing system and calendar used by a thread), =CurrentUICulture= (culture-sensitive retrieval of resources in resource files)
  + initialized by the current system culture =CultureInfo.DefaultThreadCurrentCulture= and UI culture (not true for TAP async operations).

- Thread Information
  + Managed Thread id and hash code. Managed Threads do not directly map to unmanaged threads in a one-to-one way.
  + =Name=
  + =ThreadState=
  + =ThreadPriority=
  + =IsThreadPool=
  + =IsBackground=

- Pausing and Interrupting
  - =Thread.Sleep()=
  - =.interrupt()=: interrupt a blocking (sleeping, waiting, joining) thread by throw a =ThreadInterruptedException= in the interrupted thread.

- Cancellation: use =CancellationToken= for cooperative cancellation.
  + the canceled operation should better throw an =OperationCanceledException= if needed.
  + Operations can cancel itself by
    + polling =CancellationToken.IsCancellationRequested= for long-running operations.
    + registering a callback =CancellationToken.Register= if the operations becme blocked that they cannot check the value of the token in a timely manner. The registered method is called synchronously. Performing manual threading in a callback can cause deadlock.
    + in case the async operation is using a wait handle and has no way to check the token. Synchronization prititives can be awaited but can be waken up by a cancellation.
  + To listen to multiple cancellation tokens, =CancellationTokenSource.CreateLinkedTokenSource=.

#+begin_src csharp
int eventThatSignaledIndex =
       WaitHandle.WaitAny(new WaitHandle[] { mre, token.WaitHandle },
                          new TimeSpan(0, 0, 20));
#+end_src

** =System.Threading.ThreadPool=

provides a pool of threads but not really a pool of threads in the OOP sense.

Examples
  - When creating a default =Task=.
  - Asynchronous timer =System.Threading.Timer= and =System.Timer.Timer=
  - wait handle callback =ThreadPool.RegisterWaitForSingleObject=: call a method in a thread-pool thread when signaled.
  - =ThreadPool.QueueUserWorkItem=

- One thread pool per process. The default size is determined by various factors such as the size of the virtual address space. The actual size can change during the lifetime of the process. The thread pool creates and destroys worker threads in order to optimize throughput.

- The managed thread pool does not clear the TLS used when reusing a thread.

- Not for Single-threaded apartment.

** Thread Local Storage

- TLS static field: best performance, compile-time needs anticipated
  + =[ThreadStatic] static=: not shared between threads. Field intialization occurs only once on the first thread thus not reliable: the same TLS fields on other threads will not be initialized as expected.

- Lazily Initialized =ThreadLocal<T>= class, recommended.

- Data Slots =System.LocalDataStoreSlot=: flexible, slower and more awkward to use.
  + A slot is a key to the value
  + named and unnamed slots
  + =Thread.AllocateNamedDataSlot()= (a slot for all threads), =GetNamedDataSlot=, =FreeNamedDataSlot=, =Thread.AllocateDataSlot=
  + =Thread.SetData=, =Thread.GetData=
  + Any slots can still be used even if =FreeNamedDataSlot= has freed it, as long as any =LocalDataStoreSlot= to it is still used. However, a new one is used if the slot name is used after freeing.
