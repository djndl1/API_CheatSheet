# Threading

- /Thread/: the basic unit to which an operating system allocated processor time.

- /Thread Context/: all the information the thread hnneds to seamlessly resume execution, including the thread's set of CPU registers and stack.

* Thread

** =System.Threading.Thread=

- =ThreadState=: of interest only in a few debugging scenarios.
  + thread abortion is not longer supported in new dotnet, better use a process for such code.

- =IsBackground=: Either foreground threads or background threads: foreground threads keep the process alive.
  + the main application thread is a foreground thread
  + any thread created by a =Thread= class constructor without setting it to background later is a foreground one
  + all threads that enter the managed execution environment from unmanaged code is by default background
  + thread pool threads are by default background.

- External unmanaged threads in COM: the CLR checks in its TLS if the thread is already a CLR thread, if not, a new =Thread= object is created and installed in the TLS of that thread.

- Thread Procedure Parameters: =ParameterizedThreadStart= might do, but a more type-safe way is to encapsulate both the thread procedure and the data fields into a worker object, and pass the thread procedure that uses the internal state of the worker object to the =Thread= object.

- Thread Return value:
  + pass a callback to the thread procedure to call.

- =CurrentCulture= (culture-sensitive oprations as parsing and formatting, string comparison and sorting and also controls the writing system and calendar used by a thread), =CurrentUICulture= (culture-sensitive retrieval of resources in resource files)
  + initialized by the current system culture =CultureInfo.DefaultThreadCurrentCulture= and UI culture (not true for TAP async operations).

- Thread Information
  + Managed Thread id and hash code. Managed Threads do not directly map to unmanaged threads in a one-to-one way.
  + =Name=
  + =ThreadState=
  + =ThreadPriority=
  + =IsThreadPool=
  + =IsBackground=

- Pausing and Interrupting
  - =Thread.Sleep()=
  - =.interrupt()=: interrupt a blocking (sleeping, waiting, joining) thread by throw a =ThreadInterruptedException= in the interrupted thread.

- Cancellation: use =CancellationToken= for cooperative cancellation.
  + the canceled operation should better throw an =OperationCanceledException= if needed.
  + Operations can cancel itself by
    + polling =CancellationToken.IsCancellationRequested= for long-running operations.
    + registering a callback =CancellationToken.Register= if the operations becme blocked that they cannot check the value of the token in a timely manner. The registered method is called synchronously. Performing manual threading in a callback can cause deadlock.
    + in case the async operation is using a wait handle and has no way to check the token. Synchronization prititives can be awaited but can be waken up by a cancellation.
  + To listen to multiple cancellation tokens, =CancellationTokenSource.CreateLinkedTokenSource=.

#+begin_src csharp
int eventThatSignaledIndex =
       WaitHandle.WaitAny(new WaitHandle[] { mre, token.WaitHandle },
                          new TimeSpan(0, 0, 20));
#+end_src

** =System.Threading.ThreadPool=

provides a pool of threads but not really a pool of threads in the OOP sense.

Examples
  - When creating a default =Task=.
  - Asynchronous timer =System.Threading.Timer= and =System.Timer.Timer=
  - wait handle callback =ThreadPool.RegisterWaitForSingleObject=: call a method in a thread-pool thread when signaled.
  - =ThreadPool.QueueUserWorkItem=

- One thread pool per process. The default size is determined by various factors such as the size of the virtual address space. The actual size can change during the lifetime of the process. The thread pool creates and destroys worker threads in order to optimize throughput.

- The managed thread pool does not clear the TLS used when reusing a thread.

- Not for Single-threaded apartment.

** Thread Local Storage

- TLS static field: best performance, compile-time needs anticipated
  + =[ThreadStatic] static=: not shared between threads. Field intialization occurs only once on the first thread thus not reliable: the same TLS fields on other threads will not be initialized as expected.

- Lazily Initialized =ThreadLocal<T>= class, recommended.

- Data Slots =System.LocalDataStoreSlot=: flexible, slower and more awkward to use.
  + A slot is a key to the value
  + named and unnamed slots
  + =Thread.AllocateNamedDataSlot()= (a slot for all threads), =GetNamedDataSlot=, =FreeNamedDataSlot=, =Thread.AllocateDataSlot=
  + =Thread.SetData=, =Thread.GetData=
  + Any slots can still be used even if =FreeNamedDataSlot= has freed it, as long as any =LocalDataStoreSlot= to it is still used. However, a new one is used if the slot name is used after freeing.

* Synchronization

** Synchronized Code Region

=Monitor= locks objects not value types. The monitor box every value object passed to it for each call, making the code unable to synchronize with other threads and unable to exit the critical region. The monitor maintains for each synchronized object

- the thread the owns the lock

- the threads ready to take the lock if available

- the thread waiting for signaling to enter the ready queue

  The =Monitor= is pure managed full portable and possibly more efficient synchronization mechanism.

*** Operations

- =Enter=, =TryEnter=: enter a critical section. Recursive locking is supported. Waiting on a lock can be =Thread.Interrupt=-ed.

- =Exit=: release the lock on the object, the end of a critical section protected by the locked object.

- =Wait=, =Pulse=, =PulseAll=: similar to the semantics of a conditional variable but with one cv per lock. Callable only within the critical section.

** =System.Collections.Concurrent=: builtin synchronized add/remove operations

The traditional sync wrapper provides a [[https://docs.microsoft.com/en-us/archive/blogs/bclteam/synchronization-in-generic-collections-brian-grunkemeyer][false image]] that the threading problem can be easily solved by just using that wrapper.

Insteead of traditional locking on =.SyncRoot= using a thread-safe wrapper from =.Synchronized()=, thread-safe collections use lightweight synchronization mechanism such as
=SpinWait=, =SpinLock=, =SemaphoreSlim=, =CountdownEvent=. Some doesn't even use lock at all, =Interlocked= lock-free operations are used.

** =IProducerConsumerCollection<T>=

Thread-safe collections intended for producer/consumer usage.

*** =BlockingCollection<T>=

- An implementation of producer/consumer pattern
  - concurrent addition and removal of items from multiple threads
  - a bounded colletion (with a predefined limited maximum capacity) that blocks =Add= and =Take= operations when the collection is full or empty.
    + This prevents the producer from moving too far ahead of the consumers.
  - Addition and removal are cancellable to allow unblocking.
  - =GetConsumingEnumerable=: the client can consume (take elements from) the collection with an =IEnumerable<T>=
  - One can use multiple such =BlockCollection<T>= as a resource pool with =TakeFromAny= and =AddToAny=

- Warning! =IDiposable= (and not thread-safe to dispose)

#+begin_quote
A producing thread can call =CompleteAdding= to indicate that no more items will be added. Consumers monitor the =IsCompleted= property to know when the collection is empty and no more items will be added (so that both the producer and consumer can gracefully shutdown). A producer task adds items to the collection as long as some external condition is true, and then calls =CompleteAdding=. The consumer task takes items until the =IsCompleted= property is true.
#+end_quote

=CompleteAdding= means the production will end and no more items will be available from this collection.

This collection uses an underlying =IProducerConsumerCollection= as the data store. The default one is a =ConcurrentQueue<T>=.
