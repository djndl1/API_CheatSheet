#+TITLE: Wcf

* Prerequisite

https://www.karllhughes.com/posts/plumbing

https://dzone.com/articles/being-joe-software-plumber

** Service Orientation

*** OOP

Source code reusability of C++ was not enough and OOP programming alone couples the application with the language that is used. Everything was incorporated into a single process, which imnpedes security, scalability, availability, throughput and robustness. There is no native remote call in C++ to support distribution.

*** Component Orientation

Libraries which culminated in Component Object Model, which provided interchangeable, interoperable binary components. The components are discovered and loaded at runtime. The client and server agrees only on a contract. COM enables cross-language interoperability. The basic unit of reuse is the interface.

**** Plumbing Problems

- Coupled to the technology that is used to implement component mechanism.

- Concurrency: a component might or might not be used concurrently.

- Transactions: the app itself must coordinate the atomic transaction

- Communication Protocols: prescribed by the underlying technology

- Communication Patterns: Async/Sync

- Versioning: DLL hell

- Security: Components may need to authenticate and authorize their callers.

**** Service Orientation

Business coupling is good, plumbing coupling is bad. Standardized message exchange decouples plumbing technology.

A /Service/ is a unit of functionality exposed to the world over standard plumbing. A SOA (Service Oriented Application) is an aggregate of such /services/.

***** Tenets

- Service boundaries are explicit in that only those opted-in should be exposed. (information hiding and encapsulation)

- Service are autonomous, independent of other services and any client.

- Opted-ins of a service should be type-neutral. The service should only expose logical operations.

- Services are compatible based on policy.

***** Practical Principles

- Secure communication, authentication and authorize.

- Services leave the system in a consistent state

- Services are thread-safe: the service must be able to sustain concrrent access from multiple clients.

- Services are reliable: the client will always know whether the service received the message.

- Services are robust: isolate its faults to prevent them from taking itself or other services down.

***** Optional Principles

- Interoperable from any client.

- Scale-invariable: the same code can be used regardless of the number of clients and the load on the service.

- Always available

- Responsive

- Disciplined: should not block the client.

* WCF Essentials

A runtime environment to expose CLR types as services and consume other services as CLR types.

Unlike DCOM and .NET Remoting, which tries to make a remote object a local one, WCF tries to make every service a remote one: all interactions are done via a proxy, requiring the same configuration and hosting.

- ABC(Address, Binding, Contract): an address defines where the service is; a binding defines how to communicate with the service; a contract defines what the service does

** Addressing

#+begin_src
# [transport]://[machine or domain][:optional port]/[optional URI]

http://localhost:8001
http://localhost:8001/MyService
net.tcp://localhost:8002/MyService
net.pipe://localhost/MyPipe
net.msmq://localhost/private/MyQueue
net.msmq://localhost/MyQueue
ws://localhost/MyService
soap.udp://localhost:8081/MyService
#+end_src

** Contracts

Platform-neutral and standard way of describing what the service does.

*** Service Contracts

what operations the client can perform on the service. =ServiceContract= maps a CLR interface or a class to a technology-neutral service contract. =OperationContract= opts in a method of that interface as a logical function of the service.

- The =Namespace= property should be provided to avoid collision.

#+begin_src csharp
[ServiceContract]
interface IMyContract
{
    [OperationContract]
    string MyMethod();
}

// Only the default constructor is used by WCF
class MyService : IMyContract
{
    public string MyMethod()
    {
        return "Hello WCF";
    }
}
#+end_src

*** Data Contracts

Explicitly opt in custom types.

*** Fault Contracts

Define errors and how the service handles and propagates errors to its clients.

*** Message Contracts

 Allo the service to interact directly with message. Not the usual case for common WCF applications.

** Hosting

*** IIS Hosting

Http-only. Services are  described by generated =.svc= files or in the =web.config= file.

*** WAS Hosting

A general purpose hsoting engine that supports any transport protocols, unlike IIS.

*** Self-Hosting

Any processes and any WCF transport protocols. The host process must explicitly register the service types at runtime and open the host for client calls. Each =ServiceHost= is associated with a particular service type. Multiple base addresses can be passed into the hosting instances instead of using the configuration file.

An opened host loads the WCF runtime and launches worker threads to monitor incoming requests.

#+begin_src csharp
public class ServiceHost<T> : ServiceHost
{
    public ServiceHost() : base(typeof(T))
    {}
    public ServiceHost(params string[] baseAddresses) : base(typeof(T),
                                                             baseAddresses.Select(address=>new Uri(address)).ToArray())
                                                             {}
    public ServiceHost(params Uri[] baseAddresses) : base(typeof(T),baseAddresses)
    {}
}
#+end_src

** Binding

WCF groups together sets of communication aspects in /binding/: a consistent, canned set of choices regarding the /transport protocol/, /message encoding/, /communication pattern/, /reliability/, /security/, /transaction propagation/ and /interoperability/. Bindings allow using the same service logic over drastically different plumbing. A single service can support multiple bindings on separate addresses.

*** Basic Binding =BasicHttpBinding=

A legacy ASMX web service.

- http(s), text/MTOM

*** TCP Binding =NetTcpBinding=

Requires both the client and the service to use WCF.

- tcp, binary

*** IPC Binding =NetNamedPipeBinding=

Uses named pipes as a transport for same-machine communication.

- ipc, binary

*** Web Service (WS) Bindign =WSHttpBinding=

Uses Http/Https for transport, designed to interoperate with any party that supports the WS-* standards

- http(s), text/MTOM

*** MSMQ Binding =NetMsmqBinding=

MSMQ offers support for disconnected queued calls.

- binary

*** Additional Bindings

- Context bindings: =BasicContextBinding=, =WSHttpContextBinding=, =NetTcpContextBinding=, able to pass out-of-band parameters to the service

- =WSDualHttpBinding=: two =WSHttpBinding= wired up against each other to support bidirectional duplex communication.

- =NetHttpBinding=: WebSocket but with limited interoperability with the industrial standard, not recommended.

- =UdpBinding=

- =WebHttpBinding=: accept simple calls over web protocols such as HTTP-GET using REST/POX/JSON patterns.

- =WSFederatedHttpBinding=, =WS2007FederationHttpBinding=, =MsmqIntergrationBinding=, =WS2007HttpBinding=

** Endpoint: the Fusion of the ABC

The endpoint is service's interface and is analogous to a CLR or COM interface. Each endpoint must expose at least one business endpoint, and each endpoint has exactly one contract. A single service can expose multiple endpoints.

*** Configuration File

#+begin_src xml
<system.serviceModel>
  <services>
    <service name = "MyService">
      <endpoint
          address = "net.tcp://localhost:8000/MyService"
          bindingConfiguration = "TransactionalTCP"
          binding = "netTcpBinding"
          contract = "IMyContract"
          />
      <endpoint
          address = "net.tcp://localhost:8001/MyService"
          bindingConfiguration = "TransactionalTCP"
          binding = "netTcpBinding"
          contract = "IMyOtherContract"
          />
    </service>
  </services>
  <bindings>
    <netTcpBinding>
      <binding transactionFlow = "true"/> <!-- nameless default binding -->

      <binding name = "TransactionalTCP"
               transactionFlow = "true"
               />
    </netTcpBinding>
  </bindings>
  <protocolMapping>
    <add scheme = "http" binding = "wsHttpBinding" />
  </protocolMapping>

</system.serviceModel>
#+end_src

*** Programmatic Configuration

#+begin_src csharp
ServiceHost host = new ServiceHost(typeof(MyService));
Binding wsBinding = new WSHttpBinding();
Binding tcpBinding = new NetTcpBinding();
host.AddServiceEndpoint(typeof(IMyContract),wsBinding,
                        "http://localhost:8000/MyService");
host.AddServiceEndpoint(typeof(IMyContract),tcpBinding,
                        "net.tcp://localhost:8001/MyService");
host.AddServiceEndpoint(typeof(IMyOtherContract),tcpBinding,
                        "net.tcp://localhost:8002/MyService");
host.Open();
#+end_src

** Metadata Exchange and Behavior Configuration

- Enable HTTP-GET to publish metadata

#+TODO
