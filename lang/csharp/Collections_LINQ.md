.NET Standards and .NET Core don’t even include the nongeneric collections.


# Collection Initializers

the `Add()` calls are generated by the C# compiler, requirement `System.Collections.Generic.ICollection<T>`.  a relaxed version of the requirement also exists and simply demands that one or more `Add()` methods exist either as an extension method (C# 6.0) or as an instance method on a type that implements `IEnumerable`—even if the collection doesn’t implement `ICollection<T>`. A collection is a class that at a minimum implements `IEnumerable` so that it supports iterating over the collection (`foreach` for example).

 the collection classes do not support `IEnumerator<T>` interfaces directly. Instead of the collection class maintaining the state, a different class—usually a nested class, so that it has access to the internals of the collection—will support the `IEnumerator<T>` interface and will keep the state of the iteration loop.

The actual implementation of `foreach` is conceptually like:

```csharp
System.Collections.Generic.Stack<int> stack = new System.Collections.Generic.Stack<int>();
int number;

using(
  System.Collections.Generic.Stack<int>.Enumerator
    enumerator = stack.GetEnumerator())
) {
    while (enumerator.MoveNext())
    {
        number = enumerator.Current;
        Console.WriteLine(number);
    }
}
```

`foreach` uses duck typing instead of requiring full `IEnumerable<T>` support. Neither the element count within a collection nor the items themselves can generally be modified during the execution of a foreach loop. 

# Stnadard Query Operators

Each method on `IEnumerable<T>` is a standard query operator (In Java stream); it provides querying capability over the collection on which it operates. In the context of LINQ and standard query operators, each lambda expression forms part of the overall query to be executed.  The query object represents the query, not the results. When you ask the query for the results, the whole query executes (perhaps even again) because the query object doesn’t know that the results will be the same as they were during a previous execution (if one existed). To avoid such repeated execution, you must cache the data that the executed query retrieves (using `ToCollectioName()`).

```csharp
      IEnumerable<Patent> patents = PatentData.Patents;
      IEnumerable<Patent> patentsOf1800 = patents.Where(
          patent => patent.YearOfPublication.StartsWith("18"));
      IEnumerable<string> items = patentsOf1800.Select(
          patent => patent.ToString());      
          
          
    IEnumerable<string> fileList = Directory.EnumerageFiles(
    rootDirectory, searchPattern);
    var items = fileList.AsParallel().Select( // PLINQ
    file =>
    {
        FileInfo fileInfo = new FileInfo(file);
        return new
        {
            FileName = fileInfo.Name,
            Size = fileInfo.Length
        };
    });
```

- `Where(predicate)`: filtering, deferred execution

- `Select(mapping)`: project, transform

- `Count()`: including `count()` and `count_if`. 

- `Any()`: see if the collection is greater than zero

- `OrderBy()` (returns `IOrderedEnumerable<T>`), `ThenBy()` (works on `IOrderedEnumerable`) and there descending variants.  Repeated calls to OrderBy() would undo the work of the previous call such that the end result would sort by only the keySelector in the final OrderBy() call.

- `Join()`: inner join.

- `GroupBy()`

- `GroupJoin()`: one-to-many

```csharp
Department[] departments = CorporateData.Departments;
      Employee[] employees = CorporateData.Employees;

      IEnumerable<(int Id, string Name, string Title, Department Department)> items =
          employees.Join(
              departments,
              employee => employee.DepartmentId,
              department => department.Id,
              (employee, department) => (
                  employee.Id,
                  employee.Name,
                  employee.Title,
                  department
              ));
```

- `SelectMany`

# Anonymous Types

A pure C# feature, not a new kind of type in the runtime. When the compiler encounters the anonymous type syntax, it generates a CIL class with properties corresponding to the named values and data types in the anonymous type declaration.

TODO

# Query Expressions

With query expressions, many standard query operator expressions are transformed into more readable code, much like SQL. The C# query expression order also more closely matches the order in which operations are logically performed.

TODO
