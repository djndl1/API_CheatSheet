#+title:Modern C

* Language Features

- Identifiers can be unicode characters (but with restriction) written in
  escaped notation (support for non-escaped raw characters are
  implementation-defined, but they do work in recent GCC and Clang).
  + See https://github.com/rurban/libu8ident/blob/master/doc/c11.md

** Data Types

- (C99) =_Bool= and its macro =bool=: any nonzero value is =true= (=nullptr= is
  zero)
  + (C23): =bool=, =true=, =false= are keywords now.

- (C99) =(unsigned) long long=: guaranteed to be at least 64-bit

- (C99) Optional Complex number: =_Complex= (=complex=), =_Imaginary= (=imaginary=) in
  =<complex.h>=

- (C99): integers with exact width =intN_t= and =uintN_t=.

- (C99): integers that can hold a pointer. =intptr_t=, =uintptr_t=

** Operators

- (C99): division are defined to be /truncated/ division: the quotient rounds
  to zero and the remainder =r = a - n * (a / n)=.

** Syntax

- (C99) non-constant and designated initialization for array, struct and union.

- (C99) hexadecimal floats

- (C99) compound literals: *unnamed* objects of a specified array/struct/union type used typically in place
  so that the user does not have to first define a variable and initialize it
  just to use its value but it's also an *lvalue*. Somewhat similar to C#'s
  initializer list but with automatic storage and lvalue semantics.

#+begin_src c
void drawline1(struct point from, struct point to);
void drawline2(struct point *from, struct point *to);

    drawline1(
        (struct point){.x=1, .y=1},  // creates two structs with block scope and
        (struct point){.x=3, .y=4}); // calls drawline1, passing them by value
    drawline2(
        &(struct point){.x=1, .y=1},  // creates two structs with block scope and
        &(struct point){.x=3, .y=4}); // calls drawline2, passing their addresses
#+end_src

** Keywords

- (C99) =inline=: hint about inlining. The compiler may use it to prevent the
  author from writing code that cannot be inlined.
  + =static inline=: used internally, not so much different from a pure
    =static=. Using =static inline= in a header may cause every translation unit
    to contain a copy of the function if not inlined.
  + Bare =inline=: intended for inlining only; used only in the same translation
    and not externally visible (undefined but has a symbol), and requires an
    external version in case the compiler decides not to inline it.
    typically used in headers along with a full function definition.
  + =extern inline=: used to provide an extern-linkage implementation of the
    same function with bare =inline=.
  + the typical usage is to combine a bare =inline= and an =extern inline=,
    =static inline= or =extern inline= are not something special, but they
    provide some hint so that the compiler may catch some errors that makes them
    unable to inline the functions like an =extern inline= calls some =static=
    function.

- (C99) =restrict=: used only for non-function lvalue pointers. During each
  execution of a block in which a restricted pointer =P= is declared (typically
  each execution of a function body in which =P= is a function parameter), if some
  object that is accessible through =P= (directly or indirectly) is modified, by
  any means, then all accesses to that object (both reads and writes) in that
  block must occur through =P= (directly or indirectly), otherwise the behavior is
  undefined. If the object is never modified, it may be aliased and accessed
  through different restrict-qualified pointers
  + The intended use of the restrict qualifier (like the register storage class)
    is to promote optimization. The compiler is then free to optimize or do
    whatever it can with this assumption.
  + In general, it is best to explicitly annotate all non-aliasing pointers in a
    function's prototype with restrict.


** Special Variables/Constants

- (C99) =__func__=: function name constant within a function.

* Library

- =gets= is removed in C23 due to potential buffer overflow.
