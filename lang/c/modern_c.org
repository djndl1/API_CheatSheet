#+title: Modern C

Just like modern C++, Modern C is not C in the latest language standard, but a
set of encouraged conventions and practices that are used in modern C development.

- Declarative and Functional

- Value-Oriented and Less Pointers

- Heavy Zero Initializtion

- Centralized Resource Management

- Allocator-aware

* Struct Initialization

Designated initialization, nested initialization and compound literals leads API
reforms in C.

* =_Generic= and Overloading

Useful for math functions.

* Macro Use

** =defer=

A scope that upon entering sets up something and tears it down when leaving it.

#+begin_src c
#define CONCAT(a, b) a##b
#define CONCAT2(a, b) CONCAT(a, b)
#define INTERNAL_VAR(v) CONCAT2(v, __LINE__)

// both begin and end are required to be expressions
// function calls, even void functions, are valid expressions.
#define scoped(begin, end) for ( \
        int INTERNAL_VAR(_i_) = (begin, 0);  \
        !INTERNAL_VAR(_i_);                  \
        ((INTERNAL_VAR(_i_)) += 1), end)

bool entered = false;

void begin_func()
{
    entered = true;
}

void end_func()
{
    entered = false;
}

int main(void)
{
    printf("Before enter: Entered %d\n", entered);
    scoped(begin_func(), end_func()) {
        printf("Entered %d\n", entered);
    }
    printf("After entered: Entered %d\n", entered);
}
#+end_src

* Parameters & Return Values

Out parameters are discouraged, use return value with structures.
Value passing rather than pointers are more preferred
and can be used with compound literals.

* Union as a way to give members different styles of name.

#+begin_src c
typedef union _pair {
    struct { float X, Y; };
    struct { float Left, Right; };
    float Elements[2];
} pair;
#+end_src

* Error Handling

Return the result data along with the error in a struct.
The error may be even propagated through multiple function calls without being
checked before the final check.

#+begin_src c
result_t a = read_data();
result_t b = process_data();
result_t c = write_data();

if (c.succeeded) {
    ...
}
#+end_src

* Generic APIs

[[https://github.com/nothings/stb/blob/master/stb_ds.h][stb_ds.h]] and [[https://github.com/stclib/STC][STC]] offer examples of mixing macros and functions.

* Single-Header Library

A header of the interface and the implementation separated by a macro definition.

* Writing Libraries

- Avoid allocations and request allocators or buffers from the user.

- Try to make libraries freehosted.

#+begin_src c
typedef struct allocator_t {
    void *user_data; // some additional data that may be used by the allocator
    void *(*proc)(allocator_t *this_allocator, size_t amount_to_alloc, void *ptr_to_free);
} allocator_t;

#+end_src

* Memory Management

- Make an temporary allocator and use it to create a few objects and free the
  allocator to release the memory altogether, basically a simple GC.

* Avoid Libc

Terrible and confusing API design that often causes misunderstanding and misuse.
Only a few like =stdint.h=, =memmove=, =memcpy=, =memset=, =math.h= are useful.

Null-terminated strings are slow. String handling functions in libc are badly
designed: =strtok= is not only non-reentrant, it even modifies the input string
by replacing the first character of the delimiter with a ='\0'=.

* String Handling

Differentiate owning strings (=StringBuilder=) and non-owning strings (=string=)
