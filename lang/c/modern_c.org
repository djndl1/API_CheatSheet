#+title: Modern C

Just like modern C++, Modern C is not C in the latest language standard, but a
set of encouraged conventions and practices that are used in modern C development.

- Declarative and Functional

- Value-Oriented and Less Pointers

- Heavy Zero Initializtion

- Centralized Resource Management

- Allocator-aware

* Struct Initialization

Designated initialization, nested initialization and compound literals leads API
reforms in C.

* =_Generic= and Overloading

Useful for math functions.

* Macro Use

** =defer=

A scope that upon entering sets up something and tears it down when leaving it.

#+begin_src c
#define CONCAT(a, b) a##b
#define CONCAT2(a, b) CONCAT(a, b)
#define INTERNAL_VAR(v) CONCAT2(v, __LINE__)

// both begin and end are required to be expressions
// function calls, even void functions, are valid expressions.
#define scoped(begin, end) for ( \
        int INTERNAL_VAR(_i_) = (begin, 0);  \
        !INTERNAL_VAR(_i_);                  \
        ((INTERNAL_VAR(_i_)) += 1), end)

bool entered = false;

void begin_func()
{
    entered = true;
}

void end_func()
{
    entered = false;
}

int main(void)
{
    printf("Before enter: Entered %d\n", entered);
    scoped(begin_func(), end_func()) {
        printf("Entered %d\n", entered);
    }
    printf("After entered: Entered %d\n", entered);
}
#+end_src

* Parameters & Return Values

Out parameters are discouraged, use return value with structures.
Value passing rather than pointers are more preferred
and can be used with compound literals.

* Union as a way to give members different styles of name.

#+begin_src c
typedef union _pair {
    struct { float X, Y; };
    struct { float Left, Right; };
    float Elements[2];
} pair;
#+end_src

* Error Handling

Return the result data along with the error in a struct.
The error may be even propagated through multiple function calls without being
checked before the final check.

#+begin_src c
result_t a = read_data();
result_t b = process_data();
result_t c = write_data();

if (c.succeeded) {
    ...
}
#+end_src

* Generic APIs

[[https://github.com/nothings/stb/blob/master/stb_ds.h][stb_ds.h]] and [[https://github.com/stclib/STC][STC]] offer examples of mixing macros and functions.

* Single-Header Library

A header of the interface and the implementation separated by a macro definition.

* Writing Libraries

- Avoid allocations and request allocators or buffers from the user.

- Try to make libraries freehosted.

#+begin_src c
typedef struct allocator_t {
    void *user_data; // some additional data that may be used by the allocator
    void *(*proc)(allocator_t *this_allocator, size_t amount_to_alloc, void *ptr_to_free);
} allocator_t;

#+end_src

* Memory Management

- Make an temporary allocator and use it to create a few objects and free the
  allocator to release the memory altogether, basically a simple GC.

* Avoid Libc

#+begin_quote
The C stdlib is essentially an SDK for very simple 70's UNIX-style command line
tools, but operating systems have moved on, while the C standard library is
unfortunately stuck in the past.
#+end_quote

- Terrible and confusing API design that often causes misunderstanding and misuse.
    Only a few like =stdint.h=, =memmove=, =memcpy=, =memset=, =math.h= are useful.

- Character functions are defined for use with =fgetc=. They accepts =int=, which
in unintuitive, and the domain is =unsigned character= and =EOF=: they do not
accept most values. Use them with =param & 0xFF= to avoid undefined behavior.
Still, the behavior is locale-specific.
  + multibyte and wide string functions are locale specific and thus unreliable

- Null-terminated strings are slow. String handling functions in libc are badly
designed: =strtok= is not only non-reentrant, it even modifies the input string
by replacing the first character of the delimiter with a ='\0'=. =strcpy= and
=strcat= are unsafe; =strncat= and =strncpy= have confusing semantics about the
terminating =null= and the specified size is the source's length, which should
have been the destination's length to prevent out-of-bound access.

- =errno= is global (hopefully thread-local).

- signals: limited and useless

- C11 threads: badly designed with limited functionality

- I/O streams distinguishes between text and binary. Text streams translate
  input and output and have terrible performance. STDIO are buffered. STDIO are
  usually protected by a mutex. STDIO has terrible support for Unicode. Seek
  offsets are limited to =long=.

- Numeric conversion functions are locale-dependent.

- the functions themselves are fine; their use is too granular.

** Alternatives

- GLib

- libcork

- Apache Portable Runtime

- [[https://github.com/rustyrussell/ccan/][CCAN]]

* String Handling

Differentiate owning strings (=StringBuilder=) and non-owning strings (=string=)

* Workaround Weakness of Typedef

#+begin_src c
typedef struct { int val; } meter_t; // instead of int for type safety
typedef struct { int val; } hour_t;
#+end_src

* Pointers Are =Unsafe=

#+begin_quote
The presence of pointers in C code and in structs always requires special
attention and mental effort to read and understand all the code ‘tainted’ by
those pointers.
#+end_quote
