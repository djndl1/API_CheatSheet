#+title: Back To Procedural Programming

Zig, Rust, Go, Odin, JAI, Carbon: recent programming languages that does not
emphasize OOP.

Procedural programming uses procedures over GOTOs, with strcutured flow control.

* Alan Kay's OOP

- /messaging/: send a message to tell an object to act (calling a method). The
  object looks at the message and decides what action to take based on current
  state. A method is seen as a message type allowed by an object. Calling an method
  sends a message of the type.
  + comparable to HTTP request
  + modern OOP languages move away from messaging.

- /encapsulation/: local retention and protection and hiding of state-process

- extreme /late-binding/ of all things: objects attributes, behaviors and methods
  are completely determined and changeable at runtime.
  + at odds with modern static-typed OOP languages.

C++ didn't take flight because of OOP.
Even functional languages nowadays combine data and actions together, even
without classes (with modules).

* The Pillars of OOP

- Abstraction: don't depend on implementation

- Encapsulation: prevent depending on implementation

- Polymorphism: implementation determined by type at runtime or compile-time

- Inheritance: OOP-unique, hierarchical code sharing, in contrast with
  composition (non-hierarchical code sharing, basically every language, e.g. nesting
  structs in C)
  + method overriding might accidentally break other code due to implicitness of inheritance.

Every modern language has the first three.
Hierarchical code sharing seems to be the actual essence of classical OOP.

* Procedural: Functions and Data

Let data just be data and actions just be actions.
Some languages force users to envision everything as a thing even if it
originates as an action, a process. Not everything is an object.
Also, hierarchical classification is not unique to OOP.

Interfaces are there in Go, Rust and even Haskell. There are various ways to
accept abstract data:
- interfaces

- traits,

- type classes

-  closures: Javascript, where a closure may even refer to the object currently being defined, to which
it belongs, to capture the =self= parameter. The actual behavior depends on the
object definition by duck typing)

- non-closure functions: the =self= parameter is explicitly passed in

- function pointers

Encapsulation, type hierarchy, abstraction are not unique to OOP. Many OOP's
features are not exclusive to it and some are out of favor now. Language
paradigms are not about what styles are possible, more about how those styles
are supported and what styles the ecosystem embraces.

Procedural style is programming with /less hierarchy/,
/organizing code into data and procedures/ and /using modules for modularity/.

* Reference

- [[https://www.youtube.com/watch?v=vQPHtAxOZZw][The Return Of Procedural Programming]]

- [[https://www.youtube.com/watch?v=69edOm889V4][The Design Of C++]]

- [[https://www.youtube.com/watch?v=IRTfhkiAqPw&feature=youtu.be][Object Oriented Programming is Embarassing]]

- [[http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html][Execution in Kingdomn of Nouns]]

- [[https://www.youtube.com/watch?v=0iyB0_qPvWk][Object Oriented Programming is Good*]]

- [[https://www.youtube.com/watch?v=QM1iUe6IofM&t=146s][Object Oriented Programming is Bad]]

- [[https://www.youtube.com/watch?v=V6VP-2aIcSc][Object Oriented Programming is Garbage]]

- [[https://www.youtube.com/watch?v=hxGOiiR9ZKg][The Flaws of Inheritance]]

- [[https://www.youtube.com/watch?v=aq365yzrTVE][Why Inheritance Sucks]]
