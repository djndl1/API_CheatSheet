# Basics

C++ offers _exceptions_ as the preferred alternative to `setjmp` and `longjmp`. Exceptions are the proper way to bail out of a situation which cannot be handled easily by a function itself, but which is not disastrous enough for a program to terminate completely. Exceptions provide a means to break a function's normal flow without having to use a cascade or `return`, and without the need to terminate the program using blunt tools like `exit`. 

In C++, anything having value semantics may be thrown as an exception. There also exists a standard exception type. All exceptions should be generated within a `try`-block explicitly defined by the program. Immediately following try `try`-block, one or more `catch`-clause must be defined. It's best to put a `catch` clause for most general exception last. C++ does not support a Java-style `finally` clause activate after completing a catch clause. 

A program terminates when an exception reaches the boundary of the global `try` block (generated by the runtime support system by which all of the program's code is itself surrounded), and when this happens destructors of local and global objects that were alive at the point where the exception was generated are _not_ called!  Since a program is always surrounded by a global `try` block, `throw` statements may appear anywhere in the code.


The destructor of objects can easily be skipped through `setjmp` and `longjmp`. Exceptions do not disrupt the proper activation of destructors.

Objects defined locally in functions are automatically destroyed once exceptions thrown by these functions leave these functions, which also happens to objects thrown as exceptions. The thrown object is copied to the outer caller and reconstructed there. Don't throw pointers to local objects.

An `Exception` object might support stream-like insertion operations:

```cpp
if (!lookup(variableName))
    throw Exception() << "Undefined variable" << variableName;
```

objects that were successfully constructed within the try block before executing the throw statement are destroyed before any exception handler’s code is executed.

An exception catcher may decide to ignore the exception, to process the exception, to rethrow it after inspection or to change it into another kind of exception. By placing an empty `throw` statement in the exception handler’s code the received exception is passed on to the next level that might be able to process that particular type of exception. The rethrown exception is always transferred to an exception handler at a more superficial level.

In general pointers should not be thrown as exceptions. If dynamically allocated memory must be passed to an exception handler then the pointer should be wrapped in a smart pointer.  the order of the catchers is not important for types not having any hierarchal relationship to each other (i.e., int is not derived from double; string is not derived from an NTBS).

```cpp
#include <iostream>
using namespace std;

int main()
{
    while (true)
    {
        try
        {
            string s;
            cout << "Enter a,c,i,s for ascii-z, char, int, string "
                                                      "exception\n";
            getline(cin, s);
            switch (s[0])
            {
                case 'a':
                    throw "ascii-z";
                case 'c':
                    throw 'c';
                case 'i':
                    throw 12;
                case 's':
                    throw string();
            }
        }
        catch (string const &)
        {
            cout << "string caught\n";
        }
        catch (char const *)
        {
            cout << "ASCII-Z string caught\n";
        }
        catch (double)
        {
            cout << "isn't caught at all\n";
        }
        catch (int)
        {
            cout << "int caught\n";
        }
        catch (char)
        {
            cout << "char caught\n";
        }
    }
}
```

```bash
 djn-pc  djn-pc-lenovo  ../yo/exceptions/examples  ./a.out 
Enter a,c,i,s for ascii-z, char, int, string exception
a
ASCII-Z string caught
Enter a,c,i,s for ascii-z, char, int, string exception
c
char caught
Enter a,c,i,s for ascii-z, char, int, string exception
i
int caught
Enter a,c,i,s for ascii-z, char, int, string exception
s
string caught
Enter a,c,i,s for ascii-z, char, int, string exception
```

This default exception handler (`catch(...)`, placed behind all catchers)cannot determine the actual type of the thrown exception and cannot determine the exception’s value but it may execute some statements, and thus do some default processing. 

In multi-threaded programs (cf. chapter 20), thrown exceptions can be transferred between threads after converting `std::exception` objects to `std::exception_ptr` objects.

__(Removed in C++17)__ A function may specify a function throw list or exception specification list specifying the types of the exceptions that can be thrown by the called function. 

```cpp
throw ()
throw (type)
throw (type1, type2, type3 ...)
```

Once a function throw list has been specified its function may only throw exceptions of the types mentioned in its throw list. A runtime error occurs if such a function throws exceptions of types not specified in its function throw list. A function without a throw list may throw any kind of exception. Without a function throw list the program’s designer is responsible for providing the correct handlers.

 Declaring exception throwers does not imply that the compiler checks whether an improper exception is thrown. Rather, the function for which a function throw list has been specified is surrounded by additional code in which the actually thrown exception is inspected: if the exception is of a type that is listed in the function’s throw list then that exception is rethrown; otherwise a run-time error is thrown. Instead of compile-time checks you get run-time overhead, resulting in additional code (and execution time) that is added to the function’s code

Although function throw lists are deprecated, `noexcept` is not. The `noexcept` keyword is used where previously empty function throw lists were used. when violating `noexcept` it results in `std::terminate`, ending the program. `noexcept` can be given an argument that is evaluated compile-time: if the evaluation returns true then the `noexcept` requirement is used; if the evaluation returns false, then the `noexcept` requirement is ignored.

# `iostream`s and exceptions

Normally the classes of the iostream library do not throw exceptions. However it is possible to modify the behavior using `std::ios::exceptions()`. 

Exceptions should be used in exceptional circumstances. It is questionable to have stream objects throw exceptions for fairly normal situations like `EOF`.

```cpp
cin.exceptions(ios::failbit);   // throw exception on fail
while (true) {
    try {
        cout << "enter a number: ";
        int value;
        cin >> value;
        cout << "you entered " << value << '\n';
    } catch (ios::failure const &problem) {
        cout << problem.what() << '\n';
        cin.clear();
        cin.ignore(INT_MAX, '\n');  // ignore the faulty line
    }
}
```

# Standard Exceptions `<stdexcept>`

`std:;exception` offers the member `char const *what() const;` describing in a short textual message the nature of the exception.

C++ defines the following standard exception classes:

- `std::bad_alloc` (`<new>`): thrown when `operator new()` fails

- `std:;bad_array_new_length` (`<new>`): thrown when an illegal array size (e.g. negative size) is requested when using `new T[]`.

- `std::bad_cast` (`<typeinfo>`): thrown in the context of polymorphism.

- `std::bad_typeid` (`<typeinfo>`): thrown in the context of polymorphism.

- `std::bad_exception` (`<exception>`)

All additional exception classes are derived from `std::exception`: 

- `std::domain_error`: a mathematical domain error;

- `std::invalid_argument`: invalid value of a function argument;

- `std::length_error`: an object have exceeded its maximum permitted length;

- `std::logic_error`: a problem is detected in the internal logic of the problem, e.g. a function like C’s `printf` is called with more arguments than there are format specifiers in its format string;

- `std:;out_of_range`: an argument exceeds its permitted range;

- `std::overflow_error`: an arithmetic overflow

- `std::underflow_error`: an arithmetic underflow

- `std:;range_error`: an internal computation results in a value exceeding a permissible range

- `std::runtime_error`: a problem is encountered that can only be detected while the program is executed 

- `std::tx_exception<T>`: derived from `std::runtime_error`. Thrown from an `atomic_cancel` compound statement to undo statements executed so far.

Current practice in the C++ community is to throw exceptions only in exceptional situations. Another common practice is to follow a 'conceptual' style when designing software. A nice characteristic of exceptions is that exceptions can be thrown at a point where your source shows what’s happening: throwing an `std::out_of_range` exception is nice for the software maintainer, as the reason for the exception is immediately recognized. At the catch-clause the semantical context usually isn’t very relevant anymore and by catching a `std::exception` and showing its what() contents the program’s user is informed about what happened. Throwing values of other types can also be useful, especially when you want to throw an exception that cannot be caught by other code.

The advice is to use std::exception types when available, and clearly do the required job. But if an exception is used to simply bail out of an unpleasant situation, or if there’s a chance that externally provided code might catch std:exceptions then consider throwing objects or values of other types.

# `system_error`, `error_code`, `error_category` and `error_condition` `<system_error>`

`system_error` objects can be thrown when errors are encountered having associated (system) error values. Such errors are typically associated with low-level (like operating system) functions, but other types of errors (e.g., bad user input, non-existing requests) can also be handled.

`system_error` has a `error_code`, which stores error values and matching categories (an error value of a certain `enum` type). The main purpose of `error_code` objects is to encapsulate error values, and associated error categories. Error categories are designed as singletons: only one object of each class should exist.

Error conditions are associated with ‘higher level’ errors causes, like bad user input, failing system functions or non-existing requests. Error conditions are also considered platform independent (as in: users provide bad input on all kinds of platforms) whereas error codes and error categories are tailored to specific programs and library functions. Error condition objects store information about causes of errors, like user input error, permission errors or system function failures. As such error causes are not restricted to specific platforms, they represent platform independent categories.

In POSIX systems the errno variable may be associated with many, often rather cryptic, symbols. The predefined `enum class errc` is an attempt to use intuitively more appealing symbols instead. Since its symbols are defined in a strongly typed enumeration, they cannot directly be used when defining a matching error_code. Instead, a function `make_error_code` is available, converting `enum class errc` values to error_code objects.

More at [Your Own Error Code](https://akrzemi1.wordpress.com/2017/07/12/your-own-error-code/)

# Exception Guarantees

Software should be exception safe: the program should continue to work according to its specifications in the face of exceptions. Since exceptions may be generated from within all C++ functions, exceptions may be generated in many situations. Not all of these situations are immediately and intuitively recognized as situations where exceptions can be thrown.

Although it is possible for exceptions to leave destructors this would violate the C++ standard and so it must be prevented in well-behaving C++ programs.

Serious problems are prevented when we're able to provide at least one of the guarantees:

- basic guarantee: no resources are leaked. The functions that fail to complete their assigned tasks must return all allocated resources, usually memory before terminating. 

```cpp
X *xp = 0;
Y *yp = 0;
try {
    xp = new X[nX]; // might fail and throw
    yp = new Y[nY];
} catch(...) {
    delete xp;      // the first new succeeds and the second one  fails
    throw;
}

delete[] *xDest; // nothrow
*xDest = xp;
delete[] *yDest
*yDest = yp;
```

- strong guarantee: the program's state remains unaltered when an exception is thrown.  This is realized by performing all operations that might throw on a separate copy of the data. All the code that might throw an exception affecting the current state of an object should perform its tasks separately from the data controlled by the object. Once this code has performed its tasks without throwing an exception replace the object’s data by the new data.

```cpp
Class &operator=(Class const& other)
{
    Class tmp{other};
    swap(tmp);
    return *this;
}
```

Member functions modifying their object’s data should not return original (contained) objects by value.

```cpp
void PersonData::erase(Person* dest, size_t idx)
{
    if (idx >= d_size)
        throw string("Array bounds exceeded");
    *dest = d_data[idx];
    Person *tmp = copyAllBut(idx);
    delete[] d_data;
    d_data = tmp;
    --d_size;
}
```
 
- nothrow guarantee: no exception can be thrown from it. Exception safety can only be realized if some functions and operations are guaranteed not to throw exceptions. `std::swap`, `operator delete`, `operator delete[]` offer the nothrow guarantee. Destructors may themselves not throw exceptions. Since the C programming language does not define the exception concept functions from the standard C library offer the nothrow guarantee by implication. Operations on primitive types offer the nothrow guarantee. Pointers may be reassigned, references may be returned etc. without having to worry about exceptions that might be thrown.


# Function try-block

Object destructors are only activated for completely constructed objects. An exception that is generated by the constructor might not be caught by the constructor. To prevent the exception from leaving the cosntructor, a try-block may be used.

```cpp
class Incomplete2 {
    Composed d_composed;
public:
    Incomplete2()
        try : d_composed(/* arguments */)
              {
                  // body
              } catch (...) {
        }
};
```

If no exception is explicitly thrown from the catch clause, the exception originally reaching the catch clause is always rethrown. Such an exception always propagtes to a more shallow block and the object's construction is always considered incomplete. the constructor's catch clause is responsible for preventing resource leaks.

- When multiple inheritance is used, if a later base class throws, then the initial base class are automatically destroyed since they're completely constructed;

- when composition is used: already (read: completely) constructed composed objects are automatically destroyed

- Instead of using plain pointers smart pointers (cf. section 18.4) should be used to manage dynamically allocated memory.

-  If plain pointer data members must be used, the constructor must be provided with a function try-block whose generic catch clause deletes the memory pointed by the class's plain pointer data members.

```cpp
class Incomplte2 {
    Composed d_composed;
    char *d_cp;
    int *d_ip;

public:
    Incomplte2(size_t nChars, size_t nInts)
        try : d_composed{/* args */}, d_cp{nullptr}, d_ip{nullptr}
        {
            preamble(); // might throw
            d_cp = new char[nChars]; // might throw
            d_ip = new int[nInts]; // might throw
            postamble();
        } catch (...) {
            delete[] d_cp;
            delete[] d_ip;
        }

};
```

If a delegated constructor is complete but the delegating constructor throws, it must ensure that the throwing constructor itself does not invalidate the actions performed by the destructor.

Exceptions thrown by destructors may not leave their bodies. Providing a destructor with a function `try` block is a violation of the standard. (rationale TODO)

```cpp
Class:~Class()
{
    try {
        may_throw_exceptions();
    } catch (...) {
    // ...
    }
}
```

