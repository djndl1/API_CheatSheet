#+TITLE: Database

* JDBC =java.sql=

** JDBC Driver Types

- *type 1*: translates JDBC to ODBC, which requires a ODBC driver and related configuration. No longer available by default

- *type 2*: partly Java and partly in native code.

- *type 3*: pure Java library that uses database-independent protocol to communicate with database requests to a server component, which then translates the requests into a database-specific protocol.

- *type 4*: a pure Java library that translates JDBC requests directly to a database-specific protocol.

** JDBC Configuration

- Database URLs: ~jdbc:subprotocol:other stuff~ e.g. ~jdbc:derby://localhost:1527/COREJAVA;create=true~

- Registration
  + automatically if there is a file in ~META-INF/services/java.sql.Driver~ in its jar.
  + ~Class.forName("org.postgresql.Driver")~; ~java. -Djdbc.drivers=org.postgresql.Driver ProgramName~; ~System.setProperty("jdbc.drivers", "org.postgresql.Driver")~

** JDBC Connection

- use =java.sql.DriverManager.getConnection()= to dynamically get a connection with the appropriate JDBC driver.

- A ~Statement~ has at most one *open* result set. Do not fuss with multiple concurrent result sets (~Statements~) (there's a limit to the number of statements per connection).

- Closing a =Connection= closes =Statement=​s, which in turn closes =ResultSet=​s.

** Error Handling

Each ~SQLException~ has a change of ~SQLException~ objects that are retrieved with ~getNextException~.

- ~SQLException~ implments the ~Iterable<Throwable>~ for easy retrival.

- ~SQLException~ is orgainized into a hierarchy.

** Oracle JDBC

Use the thin client driver.

- Thin Client Driver: type 4 pure Java implementation, supports only TCP/IP.

- OCI Client Driver: type 2 driver, supports IPC, named pipes, TCP/IP, IPX/SPX.

- Server-Side driver: type-2 and type-4, for use with Java on the database.

** Basic steps

- Open Connection =DataSource.getConnection()=

- Create a Statement =Connection.createStatement()= or a prepared statement =Connection.prepareStatement=
  + to reuse a =PreparedStatement=, reset the parameters or =clearParameters()=, otherwise, the parameters stay bound.

- prepare parameters =pstmt.setXXX=

- execute SQL
  + =executeQuery=: query
  + =executeUpdate=: DDL or DML that returns an update count
  + =execute=: other

- Processing the result set: =while (resultSet.move()) { resultSet.getXXX(); }=
  + Some query might return multiple ~ResultSet~​s, call ~getMoreResults()~ to move on to the next result set.
  + use =RETURN_GENERATED_KEYS= when executing to retrieve an autogenerated key.

- close the result set, the statement and the connection.

** Batch Update

- ~stmt.addBatch()~ and then ~stmt.executeBatch()~

- better disable autocommit when using batch update to allow proper error handling.

** SP Calls

- =Connection.prepareCall=

 #+begin_src java
// JDBC escape syntax
CallableStatement cs1 = conn.prepareCall
                       ( "{call proc (?,?)}" ) ; // stored proc
CallableStatement cs2 = conn.prepareCall
                       ( "{? = call func (?,?)}" ) ; // stored func
// PL/SQL block syntax
CallableStatement cs3 = conn.prepareCall
                       ( "begin proc (?,?); end;" ) ; // stored proc
CallableStatement cs4 = conn.prepareCall
                       ( "begin ? := func(?,?); end;" ) ; // stored func
 #+end_src

** JDBC Escape Syntax

#+begin_quote
JDBC provides a way of smoothing out some of the differences in the way different DBMS vendors implement SQL. This is called escape syntax. Escape syntax signals that the JDBC driver, which is provided by a particular vendor, scans for any escape syntax and converts it into the code that the particular database understands. This makes escape syntax DBMS-independent.
#+

- date, time, timestamp literals: ~{d 'yyyy-mm-dd'}~, ~{t 'hh:mm:ss'}~, ~{ts yyyy-mm-dd hh:mm:ss[.f...]}~


** Transactions

- by default auto-commit mode. no =commit= or =rollback= is allowed. =Connection.setAutoCommit()=

- implicit commit (oracle)
  + auto-commit disabled and connection closed
  + any DDL

- Some databases support save points ~Savepoint~ to allow fine-grained control over transactions.
  + ~Connection.releaseSavepoint(svpt)~ when no longer necessary.

** Metadata

#+begin_src java
DatabaseMetadata meta = conn.getMetaData();
ResultSet rs = meta.getTables(null, null, null, new String[] { "Tables" }); // metadata about tables

// metadata about a query/ResultSet
ResultSet rs = stat.executeQuery("SELECT * FROM " + tableName);
ResultSetMetaData meta = rs.getMetaData();
for (int i = 1; i <= meta.getColumnCount(); i++)
{
   String columnName = meta.getColumnLabel(i);
   int columnWidth = meta.getColumnDisplaySize(i);
   . . .
}
#+end_src

** Common Concepts

*** =java.sql.ResultSet=

A table of data representing a query result, a cursor pointing to a row in the result.

- Column indices are one-based, column names are case-insensitive.

**** Scrollable Result Set

- =ResultSet.TYPE_SCROLL_INSENSITIVE=, =ResultSet.TYPE_SCROLL_SENSITIVE=

- =CONCUR_UPDATABLE=

- =resultSet.previous()=, ~resultSet.relative(n)~, ~resultSet.absolute(n)~

 #+begin_src java
Statement stat = conn.createStatement(
   ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
String query = "SELECT * FROM Books";
ResultSet rs = stat.executeQuery(query);
while (rs.next())
{
   if (. . .)
   {
      double increase = . . .;
      double price = rs.getDouble("Price");
      rs.updateDouble("Price", price + increase);
      rs.updateRow(); // make sure to call updateRow after updating fields in a row
   }
}

// insert a new row
rs.moveToInsertRow();
rs.updateString("Title", title);
rs.updateString("ISBN", isbn);
rs.updateString("Publisher_Id", pubid);

// delete thr row under the cursor
rs.deleteRow();
 #+end_src

#+begin_quote
It is much more efficient to execute an UPDATE statement than to make a query and iterate through the result, changing data along the way. Updatable result sets make sense for interactive programs in which a user can make arbitrary changes, but for most programmatic changes, a SQL UPDATE is more appropriate.
#+end_quote


*** =java.sql.RowSet=

Row sets do not have to be tied to a database connection.

- ~CachedRowSet~: allows disconnected operation.
  + create a ~CachedRowSet~: from a ~ResultSet~ or by issuing a query from the row set. Also, cached row sets support paging.

- ~WebRowSet~: a cached row set that can be saved to an XML file.

- ~FilteredRowSet~, ~JoinRowSet~: lightweight operations on row sets that are equivalent to SQL ~SELECT~ and ~JOIN~.

- ~JdbcRowSet~: a thin wrapper around ~ResultSet~ to add userful methods from the ~RowSet~ interface.

*** =java.sql.Connection=

A connection (session) with a specific datbase, under the context of which SQL statements ar executed and results are returned.

- A user may enter a custom mapping for a UDT for type mapping =.setTypeMap()=

Vendors of web containers and application servers supply connection pool implementations.
Using a connection pool is completely transparent to the programmer.
Acquire a connection from a source of pooled connections by obtaining a data source and calling ~getConnection~.

** Apache DbUtils

A more flexible but less featured Dapper.

- ~ResultSetHandler~: a generic interface that can convert a ~ResultSet~ to other objects.
  + doesn't support ~java.time~ directly.
  + a few common implementations that transform ~ResultSet~ into arrays, maps and JavaBeans are provided.
  + each provided implementation uses an ~RowProcessor~ (~BasicRowProcessor~ by default) to handle row transformation.
    + the ~RowProcessor~ in turn employs a ~BeanProcessor~ (a more powerful ~GenerousBeanProcessor~ is available) to convert columns into JavaBean properties. By default, columns are mapped to properties by case-insensitive names.
    + Columns are handled by various implementations of ~ColumnHandler~ and ~PropertyHander~ loaded as services by ~BeanProcessor~. The ~BeanProcessor~ reads columns by ~ColumnHandler~ and coerces them using a ~PropertyHandler~ if available and compatible.

- ~SqlNullCheckedResultSet~, ~StringTrimmedResultSet~: two useful ~ResultSet~ wrappers.

- ~StatementConfiguration~: configuration options for a ~Statement~, configures fetch direction, fetch size, the maximum size of a field, the maximum number of rows in a ~ResultSet~ and the timeout.

- ~QueryRunner~: responsible for actually executing SQLs.
    + it wraps a ~DataSource~ to provide connections and uses a ~StatementConfiguration~ to configure ~Statement~​s.
    + results are handled by the passed ~ResultSetHandler~.
    + easy handling of ~OutParameter~ for inout or out parameters.

*** An example of ~LocalDateTimePropertyHandler~

Use SPI to write a jar that contains this handler and add it to the classpath. DbUtils will load it and properly convert ~Timestamp~ to ~java.time~ types.

#+begin_src java
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.LocalDateTime;

import org.apache.commons.dbutils.ColumnHandler;
import org.apache.commons.dbutils.PropertyHandler;

public class LocalDateTimePropertyHandler implements PropertyHandler {

    @Override
    public boolean match(Class<?> parameter, Object value) {
        final String targetType = parameter.getName();
        if ("java.time.LocalDateTime".equals(targetType)) {
            return true;
        } else if ("java.time.LocalDate".equals(targetType)) {
            return true;
        }
        return false;
    }

    @Override
    public Object apply(Class<?> parameter, Object value) {
        final String targetType = parameter.getName();
        if ("java.time.LocalDate".equals(targetType)) {
            Timestamp tsValue = (Timestamp) value;
            value = tsValue.toLocalDateTime().toLocalDate();
        } else if ("java.time.LocalDateTime".equals(targetType)) {
            Timestamp tsValue = (Timestamp) value;
            value = tsValue.toLocalDateTime();
        }

        return value;
    }
}
#+end_src


** HikariCP Connection Pooling

~HikariDataSource~ is a pooled ~DataSource~ implementation.

#+begin_src java
HikariConfig config = new HikariConfig();
config.setJdbcUrl("jdbc:mysql://localhost:3306/simpsons");
config.setUsername("bart");
config.setPassword("51mp50n");
config.addDataSourceProperty("cachePrepStmts", "true");
config.addDataSourceProperty("prepStmtCacheSize", "250");
config.addDataSourceProperty("prepStmtCacheSqlLimit", "2048");

HikariDataSource ds = new HikariDataSource(config);
#+end_src

Or in the property file

#+begin_src
dataSourceClassName=org.postgresql.ds.PGSimpleDataSource
dataSource.user=test
dataSource.password=test
dataSource.databaseName=mydb
dataSource.portNumber=5432
dataSource.serverName=localhost
#+end_src

* Transaction Management

** Atomikos

A lightweight transaction manager.
