#+TITLE: Database

* JDBC =java.sql=

** JDBC Driver Types

- *type 1*: translates JDBC to ODBC, which requires a ODBC driver and related configuration.

- *type 2*: partly Jasva nad partly in native code.

- *type 3*: pure Java library that uses database-independent protocol to communicate with database requests to a server component, which then translates the requests into a database-specific protocol.

- *type 4*: a pure Java library that translates JDBC requests directly to a database-specific protocol.

** JDBC Configuration

- Database URLs: ~jdbc:subprotocol:other stuff~ e.g. ~jdbc:derby://localhost:1527/COREJAVA;create=true~

- Registration
  + automatically if there is a file in ~META-INF/services/java.sql.Driver~.
  + ~Class.forName("org.postgresql.Driver")~; ~java. -Djdbc.drivers=org.postgresql.Driver ProgramName~; ~System.setProperty("jdbc.drivers", "org.postgresql.Driver")~

** JDBC Connection

- use =java.sql.DriverManager=

- A ~Statement~ has at most one *open* result set. Do not fuss with multiple concurrent result sets (~Statements~) (there's a limit to the number of statements per connection).

- Closing a =Connection= closes =Statement=​s, which in turn closes =ResultSet=​s.

** Error Handling

Each ~SQLException~ has a change of ~SQLException~ objects that are retrieved with ~getNextException~.

- ~SQLException~ implments the ~Iterable<Throwable>~ for easy retrival.

- ~SQLException~ is orgainized into a hierarchy.

** Oracle JDBC

Use the thin client driver.

- Thin Client Driver: type 4 pure Java implementation, supports only TCP/IP.

- OCI Client Driver: type 2 driver, supports IPC, named pipes, TCP/IP, IPX/SPX.

- Server-Side driver: type-2 and type-4, for use with Java on the database.

** Basic steps

- Open Connection =DataSource.getConnection()=

- Create a Statement =Connection.createStatement()= or a prepared statement =Connection.prepareStatement=
  + to reuse a =PreparedStatement=, reset the parameters or =clearParameters()=, otherwise, the parameters stay bound.

- prepare parameters =pstmt.setXXX=

- execute SQL
  + =executeQuery=: query
  + =executeUpdate=: DDL or DML that returns an update count
  + =execute=: other

- Processing the result set: =while (resultSet.move()) { resultSet.getXXX(); }=
  + Some query might return multiple ~ResultSet~​s, call ~getMoreResults()~ to move on to the next result set.
  + use =RETURN_GENERATED_KEYS= when executing to retrieve an autogenerated key.

- close the result set, the statement and the connection.

** Batch Update

- ~stmt.addBatch()~ and then ~stmt.executeBatch()~

- better disable autocommit when using batch update to allow proper error handling.

** SP Calls

- =Connection.prepareCall=

 #+begin_src java
// JDBC escape syntax
CallableStatement cs1 = conn.prepareCall
                       ( "{call proc (?,?)}" ) ; // stored proc
CallableStatement cs2 = conn.prepareCall
                       ( "{? = call func (?,?)}" ) ; // stored func
// PL/SQL block syntax
CallableStatement cs3 = conn.prepareCall
                       ( "begin proc (?,?); end;" ) ; // stored proc
CallableStatement cs4 = conn.prepareCall
                       ( "begin ? := func(?,?); end;" ) ; // stored func
 #+end_src

** Transactions

- by default auto-commit mode. no =commit= or =rollback= is allowed. =Connection.setAutoCommit()=

- implicit commit (oracle)
  + auto-commit disabled and connection closed
  + any DDL

- Some databases support save points ~Savepoint~ to allow fine-grained control over transactions.
  + ~Connection.releaseSavepoint(svpt)~ when no longer necessary.

** Metadata

#+begin_src java
DatabaseMetadata meta = conn.getMetaData();
ResultSet rs = meta.getTables(null, null, null, new String[] { "Tables" }); // metadata about tables

// metadata about a query/ResultSet
ResultSet rs = stat.executeQuery("SELECT * FROM " + tableName);
ResultSetMetaData meta = rs.getMetaData();
for (int i = 1; i <= meta.getColumnCount(); i++)
{
   String columnName = meta.getColumnLabel(i);
   int columnWidth = meta.getColumnDisplaySize(i);
   . . .
}
#+end_src

** Common Concepts

*** =java.sql.ResultSet=

A table of data representing a query result, a cursor pointing to a row in the result.

- Column indices are one-based, column names are case-insensitive.

**** Scrollable Result Set

- =ResultSet.TYPE_SCROLL_INSENSITIVE=, =ResultSet.TYPE_SCROLL_SENSITIVE=

- =CONCUR_UPDATABLE=

- =resultSet.previous()=, ~resultSet.relative(n)~, ~resultSet.absolute(n)~

 #+begin_src java
Statement stat = conn.createStatement(
   ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
String query = "SELECT * FROM Books";
ResultSet rs = stat.executeQuery(query);
while (rs.next())
{
   if (. . .)
   {
      double increase = . . .;
      double price = rs.getDouble("Price");
      rs.updateDouble("Price", price + increase);
      rs.updateRow(); // make sure to call updateRow after updating fields in a row
   }
}

// insert a new row
rs.moveToInsertRow();
rs.updateString("Title", title);
rs.updateString("ISBN", isbn);
rs.updateString("Publisher_Id", pubid);

// delete thr row under the cursor
rs.deleteRow();
 #+end_src

#+begin_quote
It is much more efficient to execute an UPDATE statement than to make a query and iterate through the result, changing data along the way. Updatable result sets make sense for interactive programs in which a user can make arbitrary changes, but for most programmatic changes, a SQL UPDATE is more appropriate.
#+end_quote


*** =java.sql.RowSet=

Row sets do not have to be tied to a database connection.

- ~CachedRowSet~: allows disconnected operation.
  + create a ~CachedRowSet~: from a ~ResultSet~ or by issuing a query from the row set. Also, cached row sets support paging.

- ~WebRowSet~: a cached row set that can be saved to an XML file.

- ~FilteredRowSet~, ~JoinRowSet~: lightweight operations on row sets that are equivalent to SQL ~SELECT~ and ~JOIN~.

- ~JdbcRowSet~: a thin wrapper around ~ResultSet~ to add userful methods from the ~RowSet~ interface.

*** =java.sql.Connection=

A connection (session) with a specific datbase, under the context of which SQL statements ar executed and results are returned.

- A user may enter a custom mapping for a UDT for type mapping =.setTypeMap()=

Vendors of web containers and application servers supply connection pool implementations.
Using a connection pool is completely transparent to the programmer.
Acquire a connection from a source of pooled connections by obtaining a data source and calling ~getConnection~.
