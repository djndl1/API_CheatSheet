#+TITLE: Pwsh

* What Pwsh is, what it can do

1. a CLI interpreter, a scripting langguage, a shell

2. Object-based, well integrated with Windows's API-based system

** Simple Examples To show what it can do

*** Pipelining

#+begin_src powershell
$total = 0
Get-ChildItem | ForEach-Object($total += $_.length)

Get-ChildItem | Sort-Object -Property Length | Select-Object -First 1
#+end_src

*** Control-Flow

#+begin_src powershell
foreach ( $i in 1..10 ) { if ($i % 2) { "$i is odd" } }
# or
1..10 | foreach { if ($_ % 2) { "$_ is odd " } }
#+end_src

*** Functions and Scripts

*** Remote Administration

Core: =Invoke-Command= invokes a block of pwsh script on one or more local/remote computers.

** Core Concepts

Based KornShell POSIX shell and aligned with C#

- Case-Insensitive but Case-Sensitive Code easy to read

*** Commands and cmdlets

The common pwsh format:

#+begin_src powershell
command -SwitchParameter -ParameterWithArgument arg1 PositionalArgument
#+end_src

- Pwsh has a smart parameter binder system, which can identify arguments by types, or convert if necessary. Pwsh respect POSIX end-of-parameter =--=

**** Categories

1. /Cmdlets/: implemented by a .NET class derived from =Cmdlet=, specific to the Pwsh environment, in the form of a DLL library.

2. /Functions/

3. /Scripts/: code inside a text file

4. /Native commands/

5. /Device State Configuration/: a configuration management platform in Windows PowerShell

*** Aliases and Elastic Syntax

Various command aliases can be defined (no arguments though). Parameters can also have aliases, defined by their authors.

*** Quoting

Unlike bash, pwsh escapes using =`= instead of =\=

*** Command-Mode and Expression-Mode

In expression mode, strings must be quoted, numbers are always numbers.
In command mode, everything except numbers is treated as strings unless they start with =$=, =@=, ='=, ="=.

*** Statement Termination

A newline can end a syntatically complete statement. If not complete, the newline is treated like any other whitespace. =`=  continues a non-extensible line. Strings are not terminated by a newline character.

** Pipeline

Unlike most shells where separate processes are used for elements in the pipeline, in pwsh, pipelining is implemented in a way similar to a real production line, in which one output object by the last command is immediately pushed to the next command, without waiting for to the entire process to finish.

*** Parameter Binding

**** How parameters are bound when pipelining:

The binding process is controlled by declaration information on the command itself: the type, the optional/mandatory and the pipeline attribute. There is an involved algorithm under the hood to make the binding do what the user wants.

A cmdlet must explicitly build in pipeline support for one or more parameters. =Accept pipeline input?= in the help article describes if this parameter can be bound to pipelined input.

- =ByValue=: by the type of the object passed in, only one parameter can be passed via =ByValue=

- =ByPropertyName=: if the passed object has properties matching certain parameter names

** Display Formatting

Formatting is managed by pwsh with an XML database, detailing how each object should be formatted on screen. A list of =Format-*= commands are at users' disposal.

- =Format-Table= and =Format-List= are most used.

- =Format-Wide= shows some concise info

- =Format-Custom= display objects while preserving its basic structure

Several =Out-*= cmdlets are responsible for finding the correct formatter for objects and output them in different ways (not just to terminals).

- =Out-File=: sending output to a file, also used by IO redirection

- =Out-String=: output as a string (or a stream of strings)

- =Out-GridView=: a new grid window

** Help

- =Get-Alias=

- =Get-Command= Has some options to query various of a command

- =Get-Help= can be updated

* Types

* Basics: Everything in PowerShell is an Object


** Automatic Variables

Premade powershell variables

- =$null=, =$true=, =$false=

- =$LASTEXITCODE=

- preference variables: used to configure the default behavior of output streams

** Data types

Basically CLR types.

- =Select-Object=: mostly used with pipelining

- =Get-Member=

**** Arrays and ArrayList

- =@()=, =,,,,=: pwsh treats any comma-separted set of values as an array

- =[]=

- =..= range operator, full closed interval

- ~+=~ and =+= concatenate arrays or add elements (new arrays are created)

  An ArrayList is created by simply casting an array

 #+begin_src shell
$colorPicker = [System.Collections.ArrayList]@("blue", "white")
 #+end_src

**** =HashTable=

#+begin_src shell
$users = @{
    abertram = "Adam Bertram"
    raquelcer = "Raquel Cerillo"
    zheng21 = "Justin Zheng"
}

$users.abertram
$users['abertram'"]
#+end_src

**** Custom Objects =PSCustomObject=

#+begin_src shell
$users = [PSCustomObject]@{
    abertram = "Adam Bertram"
    raquelcer = "Raquel Cerillo"
    zheng21 = "Justin Zheng"
}
#+end_src


* Control Flows

** Logic Operators

https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_comparison_operators?view=powershell-7.1

#+begin_src shell
if (Test-Connection -ComputerName offlineserver -Quiet -Count 1) {

} elseif {
}
   else {
}

switch (expression) {
    expressionvalue {
        # Do something with code here.
    }
    expressionvalue {
    }
    default {
        # Stuff to do if no matches were found
    }
}

foreach ($server in $servers) {
    Get-Content -Path "\\$server\c$\App_configuration.txt"
}

$servers = @('SRV1','SRV2','SRV3','SRV4','SRV5')
ForEach-Object -InputObject $servers -Process {
Get-Content -Path "\\$_\c$\App_configuration.txt"
}

$servers.foreach({Get-Content -Path "\\$_\c$\App_configuration.txt"})

for ($i = 0; $i -lt 10; $i++) {
        $i
}

while (Test-Connection -ComputerName $problemServer -Quiet -Count 1) {
          Get-Content -Path "\\$problemServer\c$\App_configuration.txt"
          break
}

do {
} while (condition)

do {
} until (condition)

#+end_src

#+RESULTS:

* Error Handling

** Handling Nonterminating Errors

- Set =ErrorAction=: what action to take if the cmdlet encounters a nonterminating error

The best practice is to always set =$ErrorActionPreference= to =Stop= to remove the concept of nonterminating errors altogether. This allows you to catch all types of exceptions, and spare yourself the work of knowing in advance which errors are terminating and which are nonterminating.

** Handling Terminating Errors

#+begin_src shell
try {
    # initial code
} catch {
    # code that runs if terminating error found
} finally {
    # code that runs at the end
}

#+end_src

* Functions

Verb-Noun naming

#+begin_src shell
# Advanced functions
function Install-Software {
   [CmdletBinding()]
   param(
    [Parameter()]
    [ValidateSet('1','2')]
    [string]$Version = 2

    [Parameter(Mandatory, ValueFromPipeline)]
    [string]$ComputerName
   )
   process { # where the main code should live
       Write-Host "I installed software version $Version on $ComputerName. Yippee!"
   }
}

#+end_src

* Modules

- System Modules: in =System32\WindowsPowerShell\1.0\Modules=

- All User modules: =Program~\WindowsPowerShell\Modules=

- Current User Module: =Users\UserName\Documents\WindowsPowerShell\Modules=

=PSModulePath= sets the search path of modules

=Import-Module= is used to manually import a module. Modules in search paths are automatically imported the first time its cmdlets are called.

A typical PowerShell module consists of a folder (the module container), =.psm1= file (the module), and a =.psd1= file (the module manifest).
Any text file with a =.psm1= file extension can be a PowerShell module.
A module manifest =.psd1= (=New-ModuleManifest=) is an optional but recommended text file written in the form of a PowerShell hashtable. This hashtable contains elements that describe metadata about the module.

Powershell gallery and =PowerShellGet= Module.

* Remoting

=&= executes a scriptblock.

- =Invoke-Command=: a script block or a local script file

- =New-PSSession=: create a session (not immediately interactive), =Enter=PSSession=, =Remove-PSSession=, =disconnect-PSSession=, =connect-PSSession=. A session exists on both sides of the connection.

** Applications

*** Structured Data

1. =ConvertTo-Csv=, =CovertFrom-Csv=, =Import-Csv=, =Export-Csv=

* Style and Best Practice

** Style

1. Use aliases for interactive input and full names for scripting

- =Set-StrictMode=: use this to enforce good practice
