#+TITLE: Pwsh

* What Pwsh is, what it can do

1. a CLI interpreter, a scripting langguage, a shell

2. Object-based, well integrated with Windows's API-based system

** Simple Examples To show what it can do

*** Pipelining

#+begin_src shell
$total = 0
Get-ChildItem | ForEach-Object($total += $_.length)

Get-ChildItem | Sort-Object -Property Length | Select-Object -First 1
#+end_src

*** Control-Flow

#+begin_src shell
foreach ( $i in 1..10 ) { if ($i % 2) { "$i is odd" } }
# or
1..10 | foreach { if ($_ % 2) { "$_ is odd " } }
#+end_src

*** Functions and Scripts

*** Remote Administration

Core: =Invoke-Command= invokes a block of pwsh script on one or more local/remote computers.

** Core Concepts

Based KornShell POSIX shell and aligned with C#

- Case-Insensitive but Case-Sensitive Code easy to read

*** Commands and cmdlets

The common pwsh format:

#+begin_src shell
command -SwitchParameter -ParameterWithArgument arg1 PositionalArgument
#+end_src

- Pwsh has a smart parameter binder system, which can identify arguments by types, or convert if necessary. Pwsh respect POSIX end-of-parameter =--=

**** Categories

1. /Cmdlets/: implemented by a .NET class derived from =Cmdlet=, specific to the Pwsh environment, in the form of a DLL library.

2. /Functions/

3. /Scripts/: code inside a text file

4. /Native commands/

5. /Device State Configuration/: a configuration management platform in Windows PowerShell

*** Aliases and Elastic Syntax

Various command aliases can be defined (no arguments though). Parameters can also have aliases, defined by their authors.

*** Quoting

Unlike bash, pwsh escapes using =`= instead of =\=

*** Command-Mode and Expression-Mode

In expression mode, strings must be quoted, numbers are always numbers.
In command mode, everything except numbers is treated as strings unless they start with =$=, =@=, ='=, ="=.

*** Statement Termination

A newline can end a syntatically complete statement. If not complete, the newline is treated like any other whitespace. =`=  continues a non-extensible line. Strings are not terminated by a newline character.

** Pipeline

Unlike most shells where separate processes are used for elements in the pipeline, in pwsh, pipelining is implemented in a way similar to a real production line, in which one output object by the last command is immediately pushed to the next command, without waiting for to the entire process to finish.

*** Parameter Binding

**** How parameters are bound when pipelining:

The binding process is controlled by declaration information on the command itself: the type, the optional/mandatory and the pipeline attribute. There is an involved algorithm under the hood to make the binding do what the user wants.

A cmdlet must explicitly build in pipeline support for one or more parameters. =Accept pipeline input?= in the help article describes if this parameter can be bound to pipelined input.

- =ByValue=: by the type of the object passed in, only one parameter can be passed via =ByValue=

- =ByPropertyName=: if the passed object has properties matching certain parameter names

** Display Formatting

Formatting is managed by pwsh with an XML database, detailing how each object should be formatted on screen. A list of =Format-*= commands are at users' disposal.

- =Format-Table= and =Format-List= are most used.

- =Format-Wide= shows some concise info

- =Format-Custom= display objects while preserving its basic structure

Several =Out-*= cmdlets are responsible for finding the correct formatter for objects and output them in different ways (not just to terminals).

- =Out-File=: sending output to a file, also used by IO redirection

- =Out-String=: output as a string (or a stream of strings)

- =Out-GridView=: a new grid window

** Help

- =Get-Alias=

- =Get-Command= Has some options to query various of a command

- =Get-Help= can be updated

* Type System

Dynamic-typed with intuitive conversion

** Members

- /Synthetic/: a pwsh layer member extension to an object. A pwsh object can be even made purely out of synthetic members with no "native" properties at all.

- /Native/: members defined by the object's type in NET/COM/CIM etc.

- /Fallback/: defined by the pwsh itself.

** Basic Types and Literals

- /String/: .NET string. Here strings (more like a multiline string literal)

- Numeral: pwsh supports multiplier suffix (=KB=, =MB=, =GB=, =TB=)

- =HashTable= (=System.Collections.HashTable=): =@{ name1 = vallue2; ... }=. Key can be accessed like a member =htbl.name1=, or in batch =htbl[keys]=. =foreach= in pwsh does not consider =HashTable= to be a collection type, =.GetEnumerator()= must be explicitly used. Ordered =System.Collections.Specialized.OrderedDictionary= is also available =[ordered]@{ ... }=

- =Array=: there is no array literal in pwsh, =A,B,C,D= is not an array literal but a sequence of expressions (comma expressions). Any object is a pseudo-array and has a =.Count= property. Pipeline output is collected into an array. Arrays are weakly typed and thus polymorphic by default.

 #+begin_src shell
(, 1) # singleton
@() # empty array
 #+end_src

- /Type Literal/: =[TypeName]=. This is not a mere type cast but also a data conversion or used to invoke a static method. Pwsh searches type names first in the type alias table, then check the full name and finally try to append a =System=.

#+begin_src shell
[char[]] '123'
[int[]] '123'
[System.Collections.Generic.List[int]]
[String]::Join(' + ', @(1, 2, 3))
[int[]] [char[]] 'Hello world'
#+end_src

*** Type Conversion Algorithm

* Operators and Expressions

** Arithmetic

- =+=: addition, string concatenation, collection join

- =*=: multiplication, string multiplication,

** Assignment

Assignment in Pwsh is also a value expression

#+begin_src shell
$a, $b, $c = 1, 2, 3, 4
$a, $b = $b, $a

$data = cat -Path .\csv.csv | foreach {
    $e = @{}
    $e.level, [int] $e.lower, [int] $e.upper = -split $_
    $e
}
#+end_src

** Comparison

**** =-gt=, =-ge=, =-le= =-lt= =-eq= =-ne= and their case-sensitive (=-ceq=) and case-insensitive (=-ieq=) version. (All shell languages have been using =<= and =>= for IO redirection).

The behavior of the comparison operators is significantly affected by the type of left operand (e.g. type conversion).

If the operands are not strings and numbers, the .NET comparison mechanisms are used

1. =IComparable= interfaces

2. =.Equals()= method

3. Convert the right operand into the type of the left

Basic comparison involving a collection and a scalar is a filter operation.

#+begin_src shell
1,2,3,4,5,6 -gt 2 # any numbers greater than 2
#+end_src

**** =-contains=, =-notcontains=, =-in=, =-notin= and their friends.

** Pattern Matching and Text Manipulation

These operators also have case-sensitive and case-insensitive versions.

- =-like=, =-notlike=: wildcard matching

- =-match=, =-notmatch=: regex matching. =$matches= is set and represents the matched part.

- =-replace=: regex substitution

- =ireplace=: deletion of the regex matched

** =-split= and =-join=

Join the lements of a collection into a single string or split strings into a collection of substrings

#+begin_src shell
1,2,3 -join '+'

'a:b:c:d:e' -split ':'
'a:b:c:d:e' -split ':',3
#+end_src

=-split= accepts a complex scriptblock.

*** Logical and bitwise operators

- =-and=, =-or=, =-not=, =-xor=

- =-band=, =-bxor=, =-bnot=, =-shl=, =-shr=

*** =.where()= and =.foreach()= methods

#+begin_src shell
(Get-Process).where({$_.handles -gt 1000})
($data).ForEach({$_ * 2})
$data.ForEach([double]) | Get-Member
(Get-Process).foreach('Name')
#+end_src

** Type Operators

- =-is=, =-isnot=, =-as=: the type operand can be a type literal or a string. =-as= is more aggressive in pwsh than in C#.

** Unary Operators

- =-not=, =-=, =+=, =++=, =--=, =,= (one-element array)

- =[type]=: the output of an expression can be discarded by casting it to =[void]=.

** Grouping and Subexpressions

- parenthesis grouping: =(Get-ChildItem).Count=. Pipelines are allowed.

- subexpression =$(statementList)= group collections of statements. subexpression voids voidable expressions =$($a++)= returns nothing.

- array subexpression =@(...)=: groups collections of statements and returns the result as an array. This is convenient since it does not wrap an array with another array but wraps a single element with an array.

 #+begin_src shell
@(dir c:\; dir d:\) # a shorthand for [object[]] $(...)
 #+end_src

** Range Operator and Index Operator

- =valueExpression..valueExpression=: high precendence than all binary operators

- =arr.[idx]=: supports negative indices and slicing

 #+begin_src shell
(1,2,3)[-1]
(1,2,3,4,5)[-1,-2]
(1,2,3,4,5)[0..2]
$2d[ (0,0) , (1,0) ] # $2d[0,0] and $2d[1,0]
 #+end_src

* Providers and its use: COM and CIM

A PowerShell provider is a software component used to produce a filesystem-like named-drive experience for other data stores such as the registry.

- =Get-PSProvider=, =Get-PSDrive=

A provider provides the core activities groped by =Item=, =ChildItem=, =ItemProperty=, =Content=, =Location=, =Path= =PSDrive= and =PSProvider=.
(help =aoubt_Core_Commands= and =about_providers=). Each provider has at least one drive (=PSDrive=) associated with it.

PSDrives can also be accessed directly by using namespace of =PSProvider=

#+begin_src shell
cd FileSystem::\\localhost\c$ # same as "cd C:\"
#+end_src

** FileSystem

- Hidden files are not displayed by default and a =-Force= parameter is required.

- =-LiteralPath= parameter suppresses pattern-matching and related special characters.

** The Registry

The Registry is mounted as several PSDrives. Under them there are items (keys), their properties and child items (subkeys)


** COM

Pwsh can load COM with its own adaption layer without the use of .NET/COM interop. =-Switch= enforces this by throwing an error if .NET one is loaded.

COM objects are located in a GUID, not a friendlier alias =ProgID= (=<Program>.<Component>.<Version>=) exists for use.

#+begin_src shell
$shell = New-Object -ComObject Shell.Application
$shell.Explore('C:\Temp') # this opens up the file explorer and navigates to C:\Temp
#+end_src

There are some problems with Pwsh's support for COM. Many COM components are 32-bit and a 32-bit pwsh must be launched to use them. Also, some COM objects have different .NET wrappers, giving them different interfaces.

** CIM

Provides a common definition of management information for systems, networks, applications and services.

All CIM classes are identified by a path of =\\computer\namespace\namespace:class=. The default namespace is =root\cimv2=.

- =Get-CimClass=: retrieves class structures of specified CIM classes, also for retrieving available CIM classes.

- =Get-CimInstance=: With =-ComputerName=, it retrives data from a remote computer. =-Filter= and WQL query is available for filtering and other use.

- =New-CimInstance=: ??. Instances are then deleted by =Remove-CimInstance=

- =Set-CimInstance=: modify a property value on a CIM instance.

  CIM classes have methods to call.

 =-Invoke-CimMethod=

#+begin_src shell
<# This starts a new calculator #>
Invoke-CimMethod -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine = 'calc.exe'}
#+end_src

*** CIM Remoting

Create a session (=New-CimSession=) and pass it to =Get-CimInstance=

Some of the pwsh cmdlets are actually implemented as a wrapper around CIM classes, which accepts a =-CimSession= parameter.


* Basics: Everything in PowerShell is an Object


** Automatic Variables

Premade powershell variables

- =$null=, =$true=, =$false=

- =$LASTEXITCODE=

- preference variables: used to configure the default behavior of output streams

** Data types

Basically CLR types.

- =Select-Object=: mostly used with pipelining

- =Get-Member=

**** Arrays and ArrayList

- =@()=, =,,,,=: pwsh treats any comma-separted set of values as an array

- =[]=

- =..= range operator, full closed interval

- ~+=~ and =+= concatenate arrays or add elements (new arrays are created)

  An ArrayList is created by simply casting an array

 #+begin_src shell
$colorPicker = [System.Collections.ArrayList]@("blue", "white")
 #+end_src

**** =HashTable=

#+begin_src shell
$users = @{
    abertram = "Adam Bertram"
    raquelcer = "Raquel Cerillo"
    zheng21 = "Justin Zheng"
}

$users.abertram
$users['abertram'"]
#+end_src

**** Custom Objects =PSCustomObject=

#+begin_src shell
$users = [PSCustomObject]@{
    abertram = "Adam Bertram"
    raquelcer = "Raquel Cerillo"
    zheng21 = "Justin Zheng"
}
#+end_src


* Control Flows

** Logic Operators

https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_comparison_operators?view=powershell-7.1

#+begin_src shell
if (Test-Connection -ComputerName offlineserver -Quiet -Count 1) {

} elseif {
}
   else {
}

switch (expression) {
    expressionvalue {
        # Do something with code here.
    }
    expressionvalue {
    }
    default {
        # Stuff to do if no matches were found
    }
}

foreach ($server in $servers) {
    Get-Content -Path "\\$server\c$\App_configuration.txt"
}

$servers = @('SRV1','SRV2','SRV3','SRV4','SRV5')
ForEach-Object -InputObject $servers -Process {
Get-Content -Path "\\$_\c$\App_configuration.txt"
}

$servers.foreach({Get-Content -Path "\\$_\c$\App_configuration.txt"})

for ($i = 0; $i -lt 10; $i++) {
        $i
}

while (Test-Connection -ComputerName $problemServer -Quiet -Count 1) {
          Get-Content -Path "\\$problemServer\c$\App_configuration.txt"
          break
}

do {
} while (condition)

do {
} until (condition)

#+end_src

#+RESULTS:

* Error Handling

** Handling Nonterminating Errors

- Set =ErrorAction=: what action to take if the cmdlet encounters a nonterminating error

The best practice is to always set =$ErrorActionPreference= to =Stop= to remove the concept of nonterminating errors altogether. This allows you to catch all types of exceptions, and spare yourself the work of knowing in advance which errors are terminating and which are nonterminating.

** Handling Terminating Errors

#+begin_src shell
try {
    # initial code
} catch {
    # code that runs if terminating error found
} finally {
    # code that runs at the end
}

#+end_src

* Functions

Verb-Noun naming

#+begin_src shell
# Advanced functions
function Install-Software {
   [CmdletBinding()]
   param(
    [Parameter()]
    [ValidateSet('1','2')]
    [string]$Version = 2

    [Parameter(Mandatory, ValueFromPipeline)]
    [string]$ComputerName
   )
   process { # where the main code should live
       Write-Host "I installed software version $Version on $ComputerName. Yippee!"
   }
}

#+end_src

* Modules

- System Modules: in =System32\WindowsPowerShell\1.0\Modules=

- All User modules: =Program~\WindowsPowerShell\Modules=

- Current User Module: =Users\UserName\Documents\WindowsPowerShell\Modules=

=PSModulePath= sets the search path of modules

=Import-Module= is used to manually import a module. Modules in search paths are automatically imported the first time its cmdlets are called.

A typical PowerShell module consists of a folder (the module container), =.psm1= file (the module), and a =.psd1= file (the module manifest).
Any text file with a =.psm1= file extension can be a PowerShell module.
A module manifest =.psd1= (=New-ModuleManifest=) is an optional but recommended text file written in the form of a PowerShell hashtable. This hashtable contains elements that describe metadata about the module.

Powershell gallery and =PowerShellGet= Module.

* Remoting

=&= executes a scriptblock.

- =Invoke-Command=: a script block or a local script file

- =New-PSSession=: create a session (not immediately interactive), =Enter=PSSession=, =Remove-PSSession=, =disconnect-PSSession=, =connect-PSSession=. A session exists on both sides of the connection.

** Applications

*** Structured Data

1. =ConvertTo-Csv=, =CovertFrom-Csv=, =Import-Csv=, =Export-Csv=

* Style and Best Practice

** Style

1. Use aliases for interactive input and full names for scripting

- =Set-StrictMode=: use this to enforce good practice
