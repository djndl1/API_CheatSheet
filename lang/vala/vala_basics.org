* Basics
  :PROPERTIES:
  :CUSTOM_ID: basics
  :END:

- basic types have =to_string()= and =parse(string str)= methods.

- All classes are subclasses of =GLib.Object=.

- non-specified fields in =struct= are zero-initialized and constructed
  with =new=.

- =unichar=: 32-bit unicode

- =string=: UTF-8 string. string templates: ==== and =!== compare the
  content of two strings. Slicing =[start:end]= is supported. Strings
  are immutable. Many basic types have methods for parsing from and
  converting to strings. =in= can be used to determine whether one
  string contains another.

#+BEGIN_EXAMPLE
    int a = 6, b = 7;
    string s = @"$a * $b = $(a * b)";  // => "6 * 7 = 42"
#+END_EXAMPLE

- Slicing an array results in a reference to the requested data.
  Assigning the slice to an owned variable results in a copy.
  Multi-dimensional arrays are like those in C#. A mono-dimensional
  array can't be obtained from a multidimensional array.

- Use =+== to append an element to an array.

- All class types are reference types, regardless of whether they are
  descended from =GLib.Object= or not. Objects are ref-counted

- =var= type inference is available.

- =??=: null coalescing

- =in=: works on arrays, strings, collections or any other type that has
  an appropriate =contain()= method.

- Operators/functions/methods cannot be overloaded. Choose slightly
  different names to avoid a name clash. However , default argument is
  supported. Index access are mapped to=get=/=set= methods.
  =[start:end]= is mapped to =slice(long start, long end)=. =in= is
  mapped to =contains()=; =foreach/in= loop is mapped to =iterator()=

- no fallthrough between cases. Each non-empty case must end with a
  =break=, =return= or =throw=.

- Nullability check can be added to a method parameter by postfixing the
  parameter with =?=. By default these parameters are non-nullable.

- Closures/lambda: =(a) => { stdout.printf("%d\n", a); }=.

- =using= namespace is supported. =global::= namespace is there.

- Vala support /named constructors/ with different names. Constructor
  dispatch is supported. Destructors are there if needed.

* Structured Error Handling
  :PROPERTIES:
  :CUSTOM_ID: structured-error-handling
  :END:

Related errors are grouped into error domains. Vala error domains do not
form a class hierarchy.

#+BEGIN_SRC C
    public errordomain MathError 
    {
        DIVISION_BY_ZERO,
        OVERFLOW,
        //...
    }
#+END_SRC

* Method Contracts
  :PROPERTIES:
  :CUSTOM_ID: method-contracts
  :END:

Vala has basic support for contract-based programming. Every method can
specify a boolean expression that it =requires= to be true (a
precondition checked at runtime) before the control flow enters the code
block. If evaluated to =false=, a critical warning is emitted that
usually leads to program termination. Postconditions are specified using
the =ensures= keyword.

* Signal
  :PROPERTIES:
  :CUSTOM_ID: signal
  :END:

Defined as a member of a class and appears similar to a method with no
body. Signal handlers can be added to the signal using the =connect()=
method (or call =disconnect()= to disconnect an event handler from a
signal). Signals are emitted by calling them like a method. It is
possible to connect signal handlers not taking any parameters,
independent of the actual signal signature.

Every =GLib.Object= instance has a signal called =notify=, which is
emitted every time a property changes.

* OOP
  :PROPERTIES:
  :CUSTOM_ID: oop
  :END:

Only available only for =GLib.Object=, run right after registering the
class with the underlying glib type system. The static construction
block runs first but only once, then the per-instance construct block
and after that the default constructor.

=[Compact]= classes are not registered with the underlying glib type
system and do not support refcount or private fields. Compact classes

- Interface in vala may not inherit from other interfaces but may
  declare other interfaces (and classes) to be prerequisites, that is,
  when a class implements the interface, all the prerequisites must also
  be specified by the class declaration.

- Vala allows method implementation in interfaces.

- Vala also allows implementing two interfaces that have methods with
  the same name.

#+BEGIN_EXAMPLE
    interface Foo {
     public abstract int m();
    }

    interface Bar {
     public abstract string m();
    }

    class Cls: Foo, Bar {
     public int Foo.m() {
      return 10;
     }

     public string Bar.m() {
      return "bar";
     }
    }

    void main () {
     var cls = new Cls ();
     message ("%d %s", ((Foo) cls).m(), ((Bar) cls).m());
    }
#+END_EXAMPLE

- Vala provides =base= keyword to refer to the base class.

- =new= modifier hide an inherited method with a new method of the same
  name.

* RTTI
  :PROPERTIES:
  :CUSTOM_ID: rtti
  :END:

- =is=: check type

- =get_type()=

- =typeof()=

#+BEGIN_EXAMPLE
    Type t = typeof(Foo);
    Foo foo = (Foo) Object.new(t);
#+END_EXAMPLE

* Dynamic Type Casting
  :PROPERTIES:
  :CUSTOM_ID: dynamic-type-casting
  :END:

- =as=: =Button b = widget as Button;= dynamic type casting, returning
  =null= if invalid

* Generics
  :PROPERTIES:
  :CUSTOM_ID: generics
  :END:

Vala includes a runtime generics system. Vala's is similar to the system
used by Java. There is no restriction on what type may be used in
generic.

* Files
  :PROPERTIES:
  :CUSTOM_ID: files
  :END:

- =.vapi=: interface file

- =.deps=: depedency specification for interface files

* =linux.vapi=
  :PROPERTIES:
  :CUSTOM_ID: linux.vapi
  :END:

A large number of constants and functions wrapping specific features of
the Linux OS, including a number of non-POSIX extensions to facilities
defined by POSIX.

TODO

* Networking
  :PROPERTIES:
  :CUSTOM_ID: networking
  :END:

A server =bind=s a socket with an address and then =listen=s. A client
=connect=s to the server. The server =accept= the connection.

JSON has pretty much replaced XML as the most popular data exchange
format for web services.

GIO for higher level networking, a generic I/O library for synchronous
and asynchronous transfers.

* DBus
  :PROPERTIES:
  :CUSTOM_ID: dbus
  :END:

An open IPC protocol, now the standard IPC on many UNIX-like platforms.

Based on the client/server paradigm. Two communication schemes
(/bidirectional/ (for interactions with a request/response pattern),
/unidirectional/(a subscription service where parties can broadcast
information to interested clients) ).

There is central process (dbus daemon) that provides the bus and the
distribution of messages. Most Unix-like systems distinguish between a
/DBus system bus/ (only one per machine, access to services provided by
the system bus is subject to matching authorization credentials) and a
/DBus session bus/ (every user session gets a dedicated session bus).

=mdbus2=: a cmd tool for communicating with DBus

This bus name is an /anonymous name/ (=:12.123=) or a /well-known/
(reverse domain name is used by default) name as a bus-wide unique
identification of any process communicating via DBus. When a process
connects to the bus, it is assigned an anonymous bus name (/unique
connection name/), never reused during the lifetime of the bus daemon. A
process may ask to own additional well-known bus names to offer
services.

/Object Paths/: communication addresses for DBus objects, which
implement services. =/org/freesmartphone/phone/0=

/Interface/: an interface describe the communication syntax of a
service.

- /Method Call/: point-to-point communication between processes

- /properties/: variables exposed by a service, whose values can be
  accessed via getter and setter method calls.

- /signals/: point-to-multipoint communication, initiated by one process
  and broadcasted to multiple other processes.

/marshaling/: converting a value from some other representation into the
/wire format/ (a sequence of bytes). DBus knows a number of types which
are mapped to the respective programming language's basic and compound
types.

Error handling is done by returning an error textual message.

** DBus in Vala
   :PROPERTIES:
   :CUSTOM_ID: dbus-in-vala
   :END:

Support for DBus is implemented in =gio=.
