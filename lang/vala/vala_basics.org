* Structure

- Source Code (UTF-8 vala source); =.vapi= (API bindings); =.deps= (dependency files that specify
  the dependencies of a certain binding).

* Basics
  :PROPERTIES:
  :CUSTOM_ID: basics
  :END:

- identifiers with the same name as keywords are prefixed with =@=.

- C#-style namespaces are available. The =global= namespace is similar to C++'s
  =::= namespace but is referenced as =global::=

- Enum types are similar to C#'s, with normal enum types and flag types but can
  contain functions (instance or static).
  + enum's =to_string()= returns its C identifier: =EnumName.A= is rendered =ENUM_NAME_A=

- /basics types/: =char=, =uchar=, =unichar=, =int=, =uint=, =long=, =ulong=,
  =short=, =ushort=, =(u)int8/16/32/64=, =float=, =double=, =bool=
  + basic types have =to_string()= and =parse(string str)= methods.
  + Many basic types have methods for parsing from and converting to strings.

- =string=: immutable UTF-8 character string.
  + Similar to C#, ==== and =!== compare the content of two strings.
  + Python-style slicing =[start:end]= is partially supported (the start and end parameters
    can not be left out). No run-time bounds checking is implemented.
  + =in= can be used to determine whether one string contains another.
  + string templates (interpolation), with implementation similar to =str.printf()=; verbatim string (escape sequences are not
    interpreted and supports multiline)
#+BEGIN_EXAMPLE vala
int a = 6, b = 7;
// string template
string s = @"$a * $b = $(a * b)";  // => "6 * 7 = 42"
#+END_EXAMPLE

- /array/: directly mapped to its C equivalent (not even =GArray=) with no
  run-time bounds checking.
  + multidimensional arrays are supported while jagged arrays (array of arrays) are not supported in vala.
  + Slicing an array results in a reference to the requested data.
    Assigning the slice to an owned variable results in a copy.
    Multi-dimensional arrays are like those in C#. A mono-dimensional
    array can't be obtained from a multidimensional array.
  + Use =+== to append an element to an array.

- /struct/: stack-allocated mutable compound value types
  + all its fields are always public
  + Structs can contain functions with =private= visibility by default.
  + =var a = Vector() { x = 1, y = 2, z = 3 }=, constructed without a =new=
    operator.
  + non-specified fields in =struct= are zero-initialized and constructed

- /class/
  + All classes are subclasses of =GLib.Object=.
  + All class types are reference types, regardless of whether they are
    descended from =GLib.Object= or not. Objects are ref-counted
  + Vala supports /named constructors/ with different names. Constructor
    dispatch is supported. Destructors are there if needed.

- /operators/
  + =sizeof=, =is=, =typeof=
  + =??=: null coalescing
  + =in=: works on arrays, strings, collections or any other type that has
  an appropriate =contain()= method.
  + Operators/functions/methods cannot be overloaded. Choose slightly
  different names to avoid a name clash. However, default argument is
  supported.
  + Index access are mapped to =get(index)=​/​=set(index, item)= methods.
  =[start:end]= is mapped to =slice(long start, long end)=. =in= is
  mapped to =contains()=; =foreach/in= loop is mapped to =iterator()=;
  string template is implemented with =to_string()=.

- /switch clause/
  + no fallthrough between cases. Each non-empty case must end with a
    =break=, =return= or =throw=.
  + applies also to =string=

- /value types/ and /reference types/
  + the underlying C code uses pointer for passing struct data but somehow
    maintain the semantics of value types.

- Nullability check can be added to a method parameter by postfixing the
  parameter with =?=. By default these parameters are non-nullable.

- Structured Error Handling
  + for handling recoverable run-time errors.
  + Related errors are grouped into error domains. Vala error domains do not
    form a class hierarchy (=GError=​s are not =GObject=).

#+BEGIN_SRC vala
public errordomain MathError
{
    DivisionByZero,
    Overflow,
    //...
}

public int division(int dividend, int divisor) throws MathError
{
    if (divisor == 0) {
        throw new MathError.DivisionByZero("divided by zero");
    }

    return dividend / divisor;
}

try {
    var x = division(30, 20);
} catch (MathError.Overflow e) {
    ...
} catch (MathError e) {
    ...
} finally {
   ...
}
#+END_SRC

- /Method Contracts/
  + for unrecoverable errors
  + Every method can specify a boolean expression that it =requires= to be true (a precondition checked at runtime) before the control flow enters the code block. If evaluated to =false=, a critical warning is emitted that usually leads to program termination. Postconditions are specified using the =ensures= keyword.

* Signal
  :PROPERTIES:
  :CUSTOM_ID: signal
  :END:

Defined as a member of a class and appears similar to a method with no
body. Signal handlers can be added to the signal using the =connect()=
method (or call =disconnect()= to disconnect an event handler from a
signal). Signals are emitted by calling them like a method. It is
possible to connect signal handlers not taking any parameters,
independent of the actual signal signature.

Every =GLib.Object= instance has a signal called =notify=, which is
emitted every time a property changes.

* OOP
  :PROPERTIES:
  :CUSTOM_ID: oop
  :END:

Only available only for =GLib.Object=, run right after registering the
class with the underlying glib type system. The static construction
block runs first but only once, then the per-instance construct block
and after that the default constructor.

=[Compact]= classes are not registered with the underlying glib type
system and do not support refcount or private fields. Compact classes

- Interface in vala may not inherit from other interfaces but may
  declare other interfaces (and classes) to be prerequisites, that is,
  when a class implements the interface, all the prerequisites must also
  be specified by the class declaration.

- Vala allows method implementation in interfaces.

- Vala also allows implementing two interfaces that have methods with
  the same name.

#+BEGIN_EXAMPLE
    interface Foo {
     public abstract int m();
    }

    interface Bar {
     public abstract string m();
    }

    class Cls: Foo, Bar {
     public int Foo.m() {
      return 10;
     }

     public string Bar.m() {
      return "bar";
     }
    }

    void main () {
     var cls = new Cls ();
     message ("%d %s", ((Foo) cls).m(), ((Bar) cls).m());
    }
#+END_EXAMPLE

- Vala provides =base= keyword to refer to the base class.

- =new= modifier hide an inherited method with a new method of the same
  name.

* RTTI
  :PROPERTIES:
  :CUSTOM_ID: rtti
  :END:

- =is=: check type

- =get_type()=

- =typeof()=

#+BEGIN_EXAMPLE
    Type t = typeof(Foo);
    Foo foo = (Foo) Object.new(t);
#+END_EXAMPLE

* Dynamic Type Casting
  :PROPERTIES:
  :CUSTOM_ID: dynamic-type-casting
  :END:

- =as=: =Button b = widget as Button;= dynamic type casting, returning
  =null= if invalid

* Generics
  :PROPERTIES:
  :CUSTOM_ID: generics
  :END:

Vala includes a runtime generics system. Vala's is similar to the system
used by Java. There is no restriction on what type may be used in
generic.

* Files
  :PROPERTIES:
  :CUSTOM_ID: files
  :END:

- =.vapi=: interface file

- =.deps=: depedency specification for interface files

* =linux.vapi=
  :PROPERTIES:
  :CUSTOM_ID: linux.vapi
  :END:

A large number of constants and functions wrapping specific features of
the Linux OS, including a number of non-POSIX extensions to facilities
defined by POSIX.

TODO

* Networking
  :PROPERTIES:
  :CUSTOM_ID: networking
  :END:

A server =bind=s a socket with an address and then =listen=s. A client
=connect=s to the server. The server =accept= the connection.

JSON has pretty much replaced XML as the most popular data exchange
format for web services.

GIO for higher level networking, a generic I/O library for synchronous
and asynchronous transfers.

* DBus
  :PROPERTIES:
  :CUSTOM_ID: dbus
  :END:

An open IPC protocol, now the standard IPC on many UNIX-like platforms.

Based on the client/server paradigm. Two communication schemes
(/bidirectional/ (for interactions with a request/response pattern),
/unidirectional/(a subscription service where parties can broadcast
information to interested clients) ).

There is central process (dbus daemon) that provides the bus and the
distribution of messages. Most Unix-like systems distinguish between a
/DBus system bus/ (only one per machine, access to services provided by
the system bus is subject to matching authorization credentials) and a
/DBus session bus/ (every user session gets a dedicated session bus).

=mdbus2=: a cmd tool for communicating with DBus

This bus name is an /anonymous name/ (=:12.123=) or a /well-known/
(reverse domain name is used by default) name as a bus-wide unique
identification of any process communicating via DBus. When a process
connects to the bus, it is assigned an anonymous bus name (/unique
connection name/), never reused during the lifetime of the bus daemon. A
process may ask to own additional well-known bus names to offer
services.

/Object Paths/: communication addresses for DBus objects, which
implement services. =/org/freesmartphone/phone/0=

/Interface/: an interface describe the communication syntax of a
service.

- /Method Call/: point-to-point communication between processes

- /properties/: variables exposed by a service, whose values can be
  accessed via getter and setter method calls.

- /signals/: point-to-multipoint communication, initiated by one process
  and broadcasted to multiple other processes.

/marshaling/: converting a value from some other representation into the
/wire format/ (a sequence of bytes). DBus knows a number of types which
are mapped to the respective programming language's basic and compound
types.

Error handling is done by returning an error textual message.

** DBus in Vala
   :PROPERTIES:
   :CUSTOM_ID: dbus-in-vala
   :END:

Support for DBus is implemented in =gio=.
