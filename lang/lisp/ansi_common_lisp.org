Lisp has outgrown "LISt Processor": Common Lisp is a general-purpose
programming language with a wide variety of data structures.

* Basic Concepts
  :PROPERTIES:
  :CUSTOM_ID: basic-concepts
  :END:

- /cons cell/: an ordered pair =(car . cdr)= created by =(cons a b)=.
  The elements can be either cons cells or atoms.

- /atom/: anything that is not a cons cell: integers, floating-point
  numbers, strings, symbols (the reader converts all unescaped
  characters in a name to uppercase and then interned into the package's
  symbol table)

- /S-expression/: an atom or an expression of the form of a cons cell
  where =car= and =cdr= are S-expressions. S-expressions refer to the
  syntax of a certain form, not data types.

- /Lisp Forms/: any atom and any list that has a symbol as its first
  element are legal Lisp forms.

- /Proper List/: a nil or a cons cell whose cdr is another proper list.
  A conceptual singly-linked list. A proper list always ends with a
  =NIL=. Lists can be written as S-expressions of a chain of nested cons
  cells.

#+BEGIN_SRC lisp
    (cons 'a '(b c d))
    (cons 'a (cons 'b nil))
#+END_SRC

- /Cycle/: An S-expression that contains a reference to itself.

- *Top level**: an interactive front-end.

* Run/Load A Program
  :PROPERTIES:
  :CUSTOM_ID: runload-a-program
  :END:

- =(load "source.lisp")=

Lisp implementations are divided into

- /Reader/: translates text into S-expressions.

- /Evaluator/: implements the semantics of the language. Defines a
  syntax of Lisp forms that can be built out of S-expressions.

Code can be generated in Lisp in the form of S-expressions and fed into
the evaluator to execute.

** Evaluation
   :PROPERTIES:
   :CUSTOM_ID: evaluation
   :END:

- A symbol are taken by the evaluator as the name of a variable and
  evaluated to the current value of the variable (except for keyword
  symbols and =T= and =NIL=). Other atoms are evaluated to themselves.

- List evaluations: function call forms, macro forms, special form

Function call forms =(function-name argument*)=: arguments are evaluated
from left to right before the function is executed.

Special operators (25 in total) e.g. =(if x (...) (...))= is evaluated
to the rules of that operator.

Macros give users a way to extend its syntax. The elements of the macro
from are passed unevaluated to the macro function and expanded and then
returned and evaluated according to the normal rules.

* Basics
  :PROPERTIES:
  :CUSTOM_ID: basics
  :END:

** Data
   :PROPERTIES:
   :CUSTOM_ID: data
   :END:

=quote= / ='=: a special operator meaning it does nothing. A way to
protect expressions from evaluation.

*** Numbers
    :PROPERTIES:
    :CUSTOM_ID: numbers
    :END:

*** Boolean and Truth
    :PROPERTIES:
    :CUSTOM_ID: boolean-and-truth
    :END:

- =nil=/=NIL=/=()=/='()=/='NIL= <-> =t=, ='T=: everything except =nil=
  counts as true in a logical context

**** Common Predicates
     :PROPERTIES:
     :CUSTOM_ID: common-predicates
     :END:

Clisp predicates often have names that end with =p=. =integerp=

- =listp=: check if the argument is a list.

- =null=: check if the argument is a =NIL=

- =not=: reverse the boolean value

- =if= is a special operator in that one of its argument is not
  evaluated.

- =(and ...)=, =(or ...)= (macros): evaluate as many as they need to in
  order to decide what to return.

** Input and Output
   :PROPERTIES:
   :CUSTOM_ID: input-and-output
   :END:

The most general output function in Common Lisp is =format=. The
standard function for input is =read=, which a complete parser, does not
just read characters and return a string.

** Variables
   :PROPERTIES:
   :CUSTOM_ID: variables
   :END:

All values in Clisp are references to objects.

- /binding/: an association of an identified to an entity. Machine
  languages have no built-in notion of identifiers. Bindings can be
  /dynamic/ or /static/. Dynamic dispatch is dynamic in the sense that
  the function called is not known until the subtype is known at
  runtime, but can be static since the subtype can be known before
  compilation in many cases. The referencing identifier can be
  /rebound/, and the referenced entity can be /mutated/ (not related to
  binding).

- /binding occurrence/: The establishment of a binding.

- /applied occurrence/: assignment, subprogram calls.

- /scope/: the portion of program in which a binding of a name with an
  entity applies. A property of a name binding.

- /context/: a property of a program, a portion of source code, or a
  portion of runtime.

- /lexical scope/: "The portion of program" means the source code, the
  /lexical/static context/, which can be determined at compile time.
  e.g. most modern languages

- /dynamic scope/: "The portion of program" means the
  /execution/runtime/dynamic context/, resolved by searching the local
  execution context, and then the outer execution context and so on
  progressing up the call stack. e.g. some dialects of Lisp, some
  scripting languages. Each name has a global stack of bindings.
  Introducing a local variable with name x pushes a binding onto the
  global x stack (which may have been empty), which is popped off when
  the control flow leaves the scope. Evaluating x in any context always
  yields the top binding

- /binding form/: any construct that introduces a new variable name
  that's usable only within the construct e.g. the function definition,
  =let=, =let*=

The bindings of the inner variable shadows the outer bindings.

- By default, all binding forms introduce /lexically scoped variables/.
  However, closures can keep the binding of the captured variable even
  out of the binding form (infinite /extent/).

- /Global Variable/ (=defparameter= (unconditionally (re)definition,
  =defvar= (define a variable and optionally initialize it only when
  uninitialized)): settable by =setf=. =boundp= checks if a name is
  bound to a global variable or constant.

- /Dynamic Variable/ (indefinite scope but dynamic extent on a
  per-thread basis): may or may not be a global one: any construct that
  creates a new variable binding of the same variable name will be a
  dynamic one and shadow the global one (Define a global with the =**=
  pair to avoid such shadowings for pure global variables), and a
  dynamic variable can be declared locally (relatively rare).

*** Constant
    :PROPERTIES:
    :CUSTOM_ID: constant
    :END:

- =defconstant=: sometimes with =**= surrounded. The constant can be
  redefined and thus leads to undesired behavior. Use this only for true
  constants.

*** Assignment
    :PROPERTIES:
    :CUSTOM_ID: assignment
    :END:

- =setf=: the general-purpose assignment macro (not just for variable
  assignment) for all assignment. =setf= returns the assigned value.

#+BEGIN_SRC lisp
    (setf x 10)
    (setf (aref a 0) 10)
    (setf (gethash 'key hash) 10)
    (setf (field o) 10)
#+END_SRC

- [ ] =incf=, =decf=, =rotatef= (swap), =shiftf=, =push=, =pop=,
  =pushnew=: modify macros

* Macros
  :PROPERTIES:
  :CUSTOM_ID: macros
  :END:

** Standard Control Constructs
   :PROPERTIES:
   :CUSTOM_ID: standard-control-constructs
   :END:

- =when=, =unless=: conditional constructs with a series of forms
  without =progn=.

#+BEGIN_SRC lisp
    (defmacro my-when (condition &rest body)
      `(if ,condition (progn ,@body)))

    (defmacro my-unless (condition &rest body)
      `(if (not ,condition) (progn ,@body)))
#+END_SRC

- =cond=: a chain of =if-else if-else if-else=

 #+begin_src lisp
    ;;; the conditions are evaluated in order until one of them returns true
    (defun our-member (obj lst)
      (cond ((atom lst) nil)
            ((eql (car lst) obj) lst)
            (t (our-member obj (cdr lst)))))

    (defun month-length (mon)
      (case mon
        ((jan mar may jul aug oct dec) 31)
        ((apr jun sept nov) 30)
        (feb (if (leap-year) 29 28))
        (otherwise "unknown month")))
 #+end_src

- =and=, =or=: actually not that different from a normal C =&&=/=||=,
  except that since Lisp forms always return values, all forms can be
  used here.

*** Looping
    :PROPERTIES:
    :CUSTOM_ID: looping
    :END:

Looping is provided through macros.

- =return=: breaks out of a loop early.

- =dolist=: iterates over a list for the body and finally evaluates the
  result form.

#+BEGIN_SRC lisp
    (defun our-length (lst)
      (let ((len 0))
        (dolist (obj lst)
          (incf len)) ;such an assignment is not unacceptable
        len))

    (our-length '(1 2 3 4 5))

    (defun our-length-recursive (lst)
      (if (null lst)
          0
          (+ 1 (our-length-recursive (cdr lst)))))

    (our-length-recursive '(1 2 3 4 5 6))
#+END_SRC

- =dotimes=: similar to =dolist= but with a form that returns the count
  instead of a list.

- =do=: similar to a for-loop with an additional result-form after the
  end test.

#+BEGIN_SRC lisp
    (defun show-squares (start end)
      (do ((i start (+ i 1)))
          ((> i end) 'done)

    (format t "~A ~A~%" i (* i i))))

    (show-squares 1 5)

;; the recursive version
    (defun show-squares-recursive (i end)
      (if (> i end)
          'done
          (progn
            (format t "~A ~A~%" i (* i i))
            (show-squares (+ i 1) end))))
#+END_SRC

**** The =loop= Macro

- =(loop body-form*)=: infinite loop until breaking out

- extended =loop= that does not look lispy.

#+BEGIN_SRC lisp
    (loop for x in '(1 2 3)
          do (print x))
    (loop for x in '(1 2 3)
          collect (* x 10))
    (loop for x on '(1 2 3)
          do (print x))
    (loop for x across #(1 2 3)
          do (print x))
    (loop for x in '(a b c)
          for y across #(1 2 3)
          collect (list x y))
    (loop (print "hello"))
    (loop for i in '(1 2 3 4)
          when (> i 3)
            return i)
    (loop repeat 10
          do (format t "Hello!~%"))
    (loop repeat 10 collect (random 10))
    (loop for x from 1 to 3
          collect (loop for y from 1 to x
                        collect y))
    (loop for x from 1 to 3
          for y = (* x 10)
          with z = x
          collect (list x y z))
    (loop for x in '(a b c d e)
          for y from 1

          when (> y 1)
            do (format t ", ")
          do (format t "~A" x))
    (loop for i from 0 to 10
          do (print i))
    (loop for i from 0 below 10
          do (print i))
    (loop for i from 10 downto 0
          do (print i))
    (loop for i from 10 above 0
          do (print i))
    (loop repeat 10
          for x = (random 100)
          if (evenp x)
            collect x into evens
          else
            collect x into odds
          finally (return (values evens odds))
          )
    (loop for x in '(1 2 3 4 5)
          until (> x 3)
          collect x)
    (loop for x in '(1 2 3 4 5)
          while (< x 3)
          collect x)
    (loop named loop-1
          for x from 0 to 20 by 2
          do (loop for y from 0 to 100 by (1+ (random 3))
                   when (< x y)
                     do (return-from loop-1 (values x y))))
    (loop for x in '(1 2 3 2)
          thereis (numberp x))
    (loop for i from 1 to 3 count (oddp i))
    (loop for i from 1 to 3 sum i)
    (loop for i from 1 to 3
          sum (* i i) into total
          do (print i)
          finally (print total))
    (loop for i from 1 to 3 maximize (mod i 3))
    (loop for (a b) in '((x 1) (y 2) (z 3))
          collect (list b a))
    (loop for (x . y) in '((1 . a) (2 . b) (3 . c))
          collect y)
    (loop for (x . nil) in '((1 . a) (2 . b) (3 . c))
          collect x)
    (loop for rest on '(a 2 b 2 c 3) by #'cddr
          collect rest)
    (loop for (key value) on '(a 2 b 2 c 3) by #'cddr
          collect (list key (* 2 value)))


    (mapcar (lambda (it) (+ it 10)) '(1 2 3 4 5))
    (mapcar #'list
            '(a b c)
            '(1 2 3))
    (mapcan #'list
            '(a b c)
            '(1 2 3))

    ;; Generic for lists and vectors
    (map 'list (lambda (it) (+ it 10)) '(1 2 3 4 5))
    (map 'vector (lambda (it) (+ it 10)) #(1 2 3 4 5))
    (map 'string (lambda (it) (code-char it)) '#(97 98 99))

    (dotimes (n 10)
      (print n))
    (dotimes (i 10)
      (if (> i 3)
          (return)
          (print i)))

    (dolist (item '(1 2 3))
      (print item))
#+END_SRC

** Custom Macros

- macro parameters are automatically destructured, which gives an error if the parameter count is illegal.

- =&rest= = =&body=

 #+begin_src lisp
(defun primep (number)
  (when (> number 1)
    (loop for fac from 2 to (isqrt number) never (zerop (mod number fac)))))

(defun next-prime (number)
  (loop for n from number when (primep n) return n))

(defmacro do-primes ((var start end) &body body)
    `(do ((,var (next-prime ,start) (next-prime (+1 ,var))))
         ((> ,var ,end))
       ,@body))

;;; macroexpand can be used to inspect the expanded macro.
 #+end_src

 Basically, everything in =`= is quoted except those prefixed with ~,~.

 Macros are abstractions, and abstractions are always leaky to some degree.
 The above code leaks as the end-form might be a function call and is called multiple times, giving a different limit each time.

#+begin_src lisp
(defmacro do-primes ((var start end) &body body)
  (let ((ending-value-name (gensym))) ; fix variable shadowing
  `(do ((,var (next-prime ,start) (next-prime (+ 1 ,var)))
        (,ending-value-name ,end)) ; fix multiple end-form evaluations
       ((> ,var ,ending-value-name))
       ,@body)))
#+end_src

*** Some Tips

- Include any subforms in the expansion in position that will be evaluated in the same order as the subforms appear in the macro call.

- Make sure subforms are evaluated only once by creating a variable in the expansion to hold the value of evaluating the argument form and then using that variable anywhere else the value is needed in the expansion.

- Use =gensym= to create such variables used in the expansion.

* Lists
  :PROPERTIES:
  :CUSTOM_ID: lists
  :END:

https://stackoverflow.com/questions/134887/when-to-use-or-quote-in-lisp

Lists are conses linked together. Every that is not a cons is an atom.
Note that =nil= is both an atom and a list. Each time =cons= is called,
Lisp allocates a new piece of memory with room.

=list= builds a list; =copy-list= copies a list; =append= returns the
concatenation of any number of lists.

#+BEGIN_SRC lisp
    (defun our-copy-list (lst)
      (if (atom lst)
      lst
      (cons (car lst) (our-copy-list (cdr lst)))))
      
    (defun our-listp (x)
        (or (null x) (consp x)))
        
    (defun our-atom (x)
        (not (consp x)))
#+END_SRC

Every value in Lisp is conceptually a pointer. When a value to a
variable or store it in a data structure what gets stored is actually a
pointer to the value. For efficiency, a small integer may be handled
directly.

- /Property List/: a list with keyword symbols as elements for actual
  data elements.

#+BEGIN_SRC lisp
    (setf a (list :a 1 :b 2 :c 3))
    (getf a :a) ; 1
#+END_SRC

** Equality
   :PROPERTIES:
   :CUSTOM_ID: equality
   :END:

- =eq=: object identity. Not for numbers and characters since they may
  or may not have the same identity even if the the values are the same.

- =eql=: an enhanced version of =eq= to deal with the value semantics of
  numbers and characters.

- =equal= if of the same elements. =equalp= is the loosened version of
  =equal= that only considers the case-insensitive value of strings and
  the mathematical value of numbers.

#+BEGIN_SRC lisp
    ;; semantics of equal
    (defun our-equal (x y)
      (or (eql x y)
          (and (consp x)
               (consp y)
               (our-equal (car x) (car y))
               (our-equal (cdr x) (cdr y)))))
#+END_SRC

Conses can be considered as binary trees. CL has several built-in
functions for use with trees. =copy-tree= takes a tree and returns a
copy of it.

#+BEGIN_SRC lisp
    (defun our-copy-tree (tr)
      (if (atom tr)
          tr
          (cons (our-copy-tree (car tr))
                (our-copy-tree (cdr tr)))))
#+END_SRC

=subst= traverses a tree

#+BEGIN_SRC lisp
    (defun our-subst (new old tree)
      (if (eql tree old)
          new
          (if (atom tree)
              tree
              (cons (our-subst new old (car tree))
                    (our-subst new old (cdr tree))))))
#+END_SRC

** a run-length compression example
   :PROPERTIES:
   :CUSTOM_ID: a-run-length-compression-example
   :END:

#+BEGIN_SRC lisp
    (defun n-elts (elt n)
      (if (> n 1)
          (list n elt)
          elt))

    (defun compr (elt n lst)
      (if (null lst)
          (list (n-elts elt n))
          (let ((next (car lst))) ;lst is the part yet to examine
            (if (eql next elt)
                (compr elt (+ n 1) (cdr lst))
                (cons (n-elts elt n)
                      (compr next 1 (cdr lst)))))))

    (defun compress (x)
      (if (consp x)
          (compr (car x) 1 (cdr x))
          x))

    ;;; unfold a (elt n) pair
    (defun list-of (n elt)
      (if (zerop n)
          nil
          (cons elt (list-of (- n 1) elt))))

    (defun uncompress (lst)
      (if (null lst)
          nil
          (let ((elt (car lst))
                (rest (uncompress (cdr lst))))
            (if (consp elt)
                (append (apply #'list-of elt)
                        rest)
                (cons elt rest)))))

    (setf runned (compress '(1 1 1 0 1 0 0 0 0 1)))
    (uncompress runned)
#+END_SRC

The representation of lists as conses makes it natural to use them as
pushdown stacks. Two macros =push= and =pop= are available. =pushnew= is
a variant of =push= that uses =adjoin= instead of =cons=.

** accessing a list
   :PROPERTIES:
   :CUSTOM_ID: accessing-a-list
   :END:

=nth=, =nthcdr=, =last=(last cons) (zero-indexed); =first= to =tenth=
(one-indexed)

#+BEGIN_SRC lisp
    (defun our-nthcdr (n lst)
        (if (zerop n)
            lst
            (our-nthcdr (- n 1) (cdr lst))))
#+END_SRC

** Mapping functions
   :PROPERTIES:
   :CUSTOM_ID: mapping-functions
   :END:

=mapcar= returns the result of applying the function to elements taken
from each list until some list runs out.

#+BEGIN_EXAMPLE
    (mapcar #'list '(a b c) '(1 2 3 4))
#+END_EXAMPLE

=maplist= calls the function on successive cdrs of the lists

#+BEGIN_EXAMPLE
    (maplist #'(lambda (x) x) '(a b c))
#+END_EXAMPLE

** Sets
   :PROPERTIES:
   :CUSTOM_ID: sets
   :END:

- =(member 'b '(a b c))=: by default uses =eql=

#+BEGIN_SRC lisp
    (member '(a) '((a) (z)) :test #'equal)
    (member '(a) '(((a) b) ((c) d)) :key #'car :test #'equal)

#+END_SRC

Lists are a good way to represent small sets. =member=, =member-if=,
=adjoin= (conditional =cons=), =intersection=, =union=, =set-difference=

#+BEGIN_SRC lisp
    (defun our-member-if (fn lst)
      (and (consp lst)
           (if (funcall fn (car lst))
               lst
               (our-member-if fn (cdr lst)))))
#+END_SRC

#+BEGIN_SRC lisp
    (defun new-union (x y)
      (let ((new-lst x))
        (if (null y)
            new-lst
            (if (member (car y) x)
                 (new-union new-lst (cdr y))
                 (new-union (append new-lst (list (car y))) (cdr y))))))
#+END_SRC

** Sequences
   :PROPERTIES:
   :CUSTOM_ID: sequences
   :END:

Another way to think of a list is as a series of objects in a particular
order. In CL, sequences include both lists and vectors. =length=

#+BEGIN_SRC lisp
    (defun mirror? (s)
      (let ((len (length s)))
        (and (evenp len)
             (let ((mid (/ len 2)))
                   (equal (subseq s 0 mid)
                          (reverse (subseq s mid)))))))
#+END_SRC

=sort= takes a sequence and a comparison function of two arguments. For
efficiency reasons, =sort= is allowed to modify the sequence given to it
as an argument.

#+BEGIN_SRC lisp
    (let ((vec #(1 2 3 4)))
      (print (sort vec #'>))
      (print vec))

    (defun nthmost (n lst)
      (nth (- n 1)
           (sort (copy-list lst) #'>)))
#+END_SRC

=some=, =every=

** Stacks
   :PROPERTIES:
   :CUSTOM_ID: stacks
   :END:

#+BEGIN_SRC lisp
    (setf s '(1 2 3 4))
    (push 1 s)
    (pop s)
#+END_SRC

** Proper Lists and Dotted lists
   :PROPERTIES:
   :CUSTOM_ID: proper-lists-and-dotted-lists
   :END:

A proper list is either =nil= or a cons whose =cdr= is a proper list.
dot notation implies a nonproper list (dotted list). In dot notation,
the car and cdr of each cons are shown separated by a period.

#+BEGIN_SRC lisp
    (defun proper-list? (x)
      (or (null x)
          (and (consp x)
               (proper-list? (cdr x)))))
#+END_SRC

** Assoc-lists (a dict)
   :PROPERTIES:
   :CUSTOM_ID: assoc-lists-a-dict
   :END:

A list of conses are called an assoc-list or alist. Such a list could
represent a set of translations.

=assoc= retrieves the pair associated with a given key:

#+BEGIN_SRC lisp
    (setf trans '((+ . "add") (- . "substract")))
    (assoc '+ trans)
#+END_SRC

*** Shortest Path in a Graph
    :PROPERTIES:
    :CUSTOM_ID: shortest-path-in-a-graph
    :END:

Given a directed graph, the neighbor of a certain node is obtained as
above:

#+BEGIN_SRC lisp
    (setf net '((a b f) (b c d) (c) (d c) (f d)))
    (cdr (assoc 'b net))
#+END_SRC

A breadth-first search implementation

#+BEGIN_SRC lisp
    ;;; generate a list of paths that extend `path' via `node'in `net'
    (defun new-paths (path node net)
        (mapcar #'(lambda (n)
            (cons n path))
        (cdr (assoc node net))))
        
    ;;; breadth first search to `end' in `net'
      ;;; `queue' is a list of reversed candidate paths that might lead to `end', longer paths will be appended to the back
      (defun bfs (end queue net)
        (if (null queue)
            nil     ; not found
            (let ((path (car queue)))
              (let ((node (car path)))
                (if (eql node end) ; current node is the end
                    (reverse path)
                    (bfs end
                         (append (cdr queue)  ; (car queue) is already searched and nothing has been found
                                 (new-paths path node net))
                         net))))))
                         
    (defun shortest-path (start end net)
        (bfs end (list (list start)) net))
#+END_SRC

** Pointers, garbage collection
   :PROPERTIES:
   :CUSTOM_ID: pointers-garbage-collection
   :END:

Every value is conceptually a pointer. When a value is assigned to a
variable or store it in a data structure, what gets stored is actua lly
a pointer to the value. When the contents of the data structure or the
value of the variable is asked for, Lisp returns what it points to. For
efficiency, Lisp sometimes use an immediate representation instead of a
pointer.

/Automatic memory management/ is one of Lisp's most valuable features.
The Lisp system maintains a segment of memory, /heap/. The function
=cons= returns a newly allocated cons. Allocating memory from the heap
is sometimes generically known as /consing/. Memory that is no longer
needed is called /garbage/, and the scavenging operation is called
/garbage collectiion/ or *GC*. Allocating storage and scavenging memory
to reclaim it can be expensive compared to the routine operations of a
program. It is easy to write programs that cons excessively.

The typical approach to write programs that don't cons at all would be
to write the initial version of a program in a purely functional style
and using a lot of lists.

* Arrays and vectors
  :PROPERTIES:
  :CUSTOM_ID: arrays-and-vectors
  :END:

A literal array is dentoed by =#na= where =n= is the number of
dimensions in the array.

=make-array= makes an array

#+BEGIN_SRC lisp
    (setf arr (make-array '(2 3) :initial-element nil)) ; make a 2-by-3 array with nil values
#+END_SRC

A literal array is denoted by

#+BEGIN_SRC lisp
    #2a((b nil nil) (nil nil nil))
#+END_SRC

where =2= is the number of dimensions in the array.

=aref= returns an reference to an element of an array.

#+BEGIN_SRC lisp
    (setf (aref arr 0 0 ))
#+END_SRC

One-dimensional array is a vector, also built by calling =vector=,
literally denoted by =#(a b c)=.

#+BEGIN_SRC lisp
    (vector "a" 'b 3)
#+END_SRC

=svref= (simple vector)is faster than =aref= when accessing a vector.

*** an example of binary search
    :PROPERTIES:
    :CUSTOM_ID: an-example-of-binary-search
    :END:

#+BEGIN_SRC lisp
    (defun finder (obj vec start end)
      (let ((range (- end start)))
        (if (zerop range)
            ;; if there's only one element in the vector
            (if (eql obj (aref vec start))
               obj
               nil)
            ;; otherwise, find the middle one and compare it with obj to find the next search range
           (let ((mid (+ start (round (/ range 2)))))
             (let ((obj2 (aref vec mid)))
               (if (< obj obj2)
                   (finder obj vec start (- mid 1))
                   (if (> obj obj2)
                       (finder obj vec (+ mid 1) end)
                       obj)))))))   ; not in two sides then the middle one is the one

    (defun bin-search (obj vec)
     (let ((len (length vec)))
       (and (not (zerop len))       ; ensure the vector is not empty and reture nil
            (finder obj vec 0 (- len 1))))) ; otherwise, return the position
#+END_SRC

** Strings and Characters
   :PROPERTIES:
   :CUSTOM_ID: strings-and-characters
   :END:

Strings are vectors of characters, so both sequence functions and array
functiosn work on them. A constant string is denoted as a series of
characters surrounded by double quotes, and an individual character c as
=#\c=.

=char-code= returns the number associated with a character, =code-char=
returns the character associated with a number.

=char<=, =char<==, =char==, =char>==, =char>= and =char/== (different)
compare characters.

=char= access the element of string specified by index and is faster
than =aref= when working on strings.

*** How to replace chars in strings
    :PROPERTIES:
    :CUSTOM_ID: how-to-replace-chars-in-strings
    :END:

#+BEGIN_SRC lisp
    (let ((str (copy-seq "Merlin")))
      (setf (char str 3) #\k)
      str)
#+END_SRC

Use =equal= to compare two strings.

#+BEGIN_SRC lisp
    (equal "fred" "Fred")
#+END_SRC

Common lisp provides a large number of functions for comparing and
manipulating strings.

=format= is one of the way to build a string.

#+BEGIN_SRC lisp
    (format nil "~A or ~A" "truth" "dare")
#+END_SRC

Use =concatenate= to join several strings.

** Sequence
   :PROPERTIES:
   :CUSTOM_ID: sequence
   :END:

In Common lisp, the tyep sequence include both lists and vectors (and
therefore strings).

=remove=, =length=, =subseq=, =reverse=, =sort=, =every=, =some= are
actually sequence functions.

=elt= is a function that retrieves elements of sequences of any kind.

another =mirror?= suited for =vector=

#+BEGIN_SRC lisp
    (defun mirror? (s)
      (let ((len (length s)))
        (and (evenp len)
        ;; test head and tail one by one, 
             (do ((forward 0 (+ forward 1))
                  (back (- len 1) (- back 1)))
                  ;; stop condition test
                 ((or (> forward back)
                      (not (eql (elt s forward)
                                (elt s back))))
                 ;; forward > back means check pass.
                  (> forward back))))))
#+END_SRC

Many sequence functions take one or more keyword arguments.

- =:key=: a function that is applied to each element of a sequence
  before it is considered. defualt to =identity=.

#+BEGIN_SRC lisp
    (position 'a '((c d) (a b)) :key #'car)
#+END_SRC

- =:start=, =:end=: at which to start, default to =0= and =nil=
  respectively.

- =:from-end=: if work backwards, default =nil=

- =:test=: a two-argument comparison function. Default to =eql=.

The following function returns the second word.

#+BEGIN_SRC lisp
    (defun second-word (str)
      (let ((p1 (+ (position #\  str) 1)))
        (subseq str p1 (position #\  str :start p1))))
#+END_SRC

=position-if= finds an elememnt satisfying a predicate of one argument,
which, of course, cannot take =:test= keyword.

#+BEGIN_SRC lisp
    (position-if #'oddp '(2 3 4 5))
#+END_SRC

=member= and =member-if= functions have similar relation. Also for
=find= and =find-if=, =remove= and =remove-if=.

=remove-duplicates= preserves only the last of each occurrences of any
element of a sequence. It takes all keyword five arguments listed above.

=reduce= boids down a sequence into a single value using a function with
two arguments which will be called with initially the first two
arguments.

#+BEGIN_SRC lisp
    (reduce #'fn '(a b c d))
    ;;; is equivalent to
    (fn (fn (fn 'a 'b) 'c ) 'd)
#+END_SRC

#+BEGIN_SRC lisp
    (reduce #'intersection lst1 lst2 ...)
#+END_SRC

takes the intersection of multiple lists

This may be used to compute a polynomial in the form

$$
3x^4 + 5x^3 + 6x^2 + 7 = x (x (x (3x + 5) + 6) +0) + 7
$$

where the function should take two coefficent $a$ and $b$ and returns
$ax+b$.

#+BEGIN_SRC lisp
    (defun polynomial-compute (lst x)
        (reduce #'(lambda (a b) (+ (* a x) b)) lst))
#+END_SRC

A token parser

#+BEGIN_SRC lisp
    (defun tokens (str test start)
      "a token parser"
        (let ((p1 (position-if test str :start start)))
          (if p1
              (let ((p2 (position-if #'(lambda (c)
                                         (not (funcall test c)))
                                     str :start p1))) ;; the end of a token
                (cons (subseq str p1 p2)
                      (if p2
                          (tokens str test p2)
                          nil)))
              nil))) ;; not even a single char satisfying the test

    (defun constituent (c)
      "test if a char is anything but newline and space"
        (and (graphic-char-p c)
             (not (char= c #\ ))))
#+END_SRC

And then a date parser

#+BEGIN_SRC lisp
    (defun parse-date (str)
      "doc"
      (let ((toks (tokens str #'constituent 0)))
        (list (parse-integer (first toks))
              (parse-month (second toks))
              (parse-integer (third toks)))))

      (defconstant +month-names+
        #("jan" "feb" "mar" "apr" "may" "jun"
          "jul" "aug" "sep" "oct" "nov" "dec"))

      (defun parse-month (str)
        (let ((p (position str +month-names+
                           :test #'string-equal)))
          (if p
              (+ p 1)
              nil)))

      (parse-date "16 Aug 1980")
#+END_SRC

An integer parser

#+BEGIN_SRC lisp
      (defun read-integer (str)
        (if (every #'digit-char-p str)
            (let ((accum 0))
              (dotimes (pos (length str))
                (setf accum (+ (* accum 10)
                               (digit-char-p (char str pos)))))
              accum)
            nil))
#+END_SRC

** Structures
   :PROPERTIES:
   :CUSTOM_ID: structures
   :END:

Similarly to C struct.

#+BEGIN_SRC lisp
    (defstruct point
        x
        y)
#+END_SRC

It also implicitly defines the functions =make-point=, =point-p=,
=copy-point=, =point-x= and =point-y=.

=typep= can also be used to determine the type of an object.

#+BEGIN_SRC lisp
    (typep p 'point)
#+END_SRC

We can also specify default values for structure fields by enclosign the
field name and a default expression in a list in the original
definition.

#+BEGIN_SRC lisp
    (defstruct polemic
        (type (progn
                (format t "What kind of polemic was it? ")
                (read)))
        (effect nil))
#+END_SRC

We can also control things like the way a structure is displayed and the
prefix used in the names of the access functions it creates.

#+BEGIN_SRC lisp
    (defstruct (point (:conc-name p)
                      (:print-function print-point))
        (x 0)
        (y 0))
        
    (setf p (make-point :x 0 :y 0))

    (defun print-point (p stream depth)
        (format stream "#<~A,~A>" (px p) (py p)))
#+END_SRC

The =:conc-name= argument specifies what should be concatenated to the
front of the field names to make access functions for them. The
=print-function= is the name of the function that should be used to
print a point when it has to be displayed.

** A binary search tree example
   :PROPERTIES:
   :CUSTOM_ID: a-binary-search-tree-example
   :END:

A BST is a binary tree in which, for some ordering function =<=, the
left child of each elemetn is =<= the element andthe element is =<= its
right child.

The fundamental data structure is the =node= which has three fields, one
for the object stored at the node, and one each for the left and right
children of the node.

#+BEGIN_SRC lisp
    (defstruct (node (:print-function
                        (lambda (n out d)
                          (format out "#<~A>" (node-elt n)))))
        elt (l nil) (r nil))
#+END_SRC

#+BEGIN_SRC lisp
      (defun bst-min (bst)
        (and bst
             (or (bst-min (node-l bst)) bst)))

      (defun bst-max (bst)
        (and bst
             (or (bst-max (node-r bst)) bst)))
#+END_SRC

A BST is either =nil= or a node whose left and right fields are BSTs.

#+BEGIN_SRC lisp
    (defun bst-insert (obj bst <)
        (if (null bst)
            (make-node :elt obj)
            (let ((elt (node-elt bst)))
              (if (eql obj elt)
                  bst
                  (if (funcall < obj elt)
                      (make-node
                       :elt elt
                       :l (bst-insert obj (node-l bst) <)
                       :r (node-r bst))
                      (make-node
                       :elt elt
                       :l (node-l bst)
                       :r (bst-insert obj (node-r bst) <)))))))

      (defun bst-find (obj bst <)
        (if (null bst)
            nil
            (let ((elt (node-elt bst)))
              (if (eql obj elt)
                  bst
                  (if (funcall < obj elt)
                      (bst-find obj (node-l bst) <)
                      (bst-find obj (node-r bst) <))))))
#+END_SRC

** Hash Tables
   :PROPERTIES:
   :CUSTOM_ID: hash-tables
   :END:

Used as a fast set/mapping. The objects stored in a hash table or used
as keys can be of any type. To use a hash table as a set, set the value
to =t=

#+BEGIN_SRC lisp
    (setf fruit (make-hash-table))
    (setf (gethash 'apricot fruit) t)
    (remhash 'apricot fruit)
#+END_SRC

=maphash=

**** =cond=: a broad =switch-case= without =break=
     :PROPERTIES:
     :CUSTOM_ID: cond-a-broad-switch-case-without-break
     :END:

Returns the value of the form whose test-form evaluates to true.

#+BEGIN_SRC lisp
     (defun select-options ()
       (cond ((= a 1) (setq a 2))
             ((= a 2) (setq a 3))
             ((and (= a 3) (floor a 2)))
             (t (floor a 3)))) =>  SELECT-OPTIONS
#+END_SRC

#+BEGIN_SRC lisp
     (setq a 1) =>  1
     (select-options) =>  2
     a =>  2
     (select-options) =>  3
     a =>  3
     (select-options) =>  1
     (setq a 5) =>  5
     (select-options) =>  1, 2
#+END_SRC

**** remove an element from the BST
     :PROPERTIES:
     :CUSTOM_ID: remove-an-element-from-the-bst
     :END:

#+BEGIN_SRC lisp
    (defun rperc (bst)
        (make-node :elt (node-elt (node-r bst))
                   :l (node-l bst)
                   :r (percolate (node-r bst))))

      (defun lperc (bst)
        (make-node :elt (node-elt (node-l bst))
                   :l (percolate (node-l bst))
                   :r (node-r bst)))

      (defun percolate (bst)
        (cond ((null (node-l bst))
               (if (null (node-r bst))
                   nil                          ; has none
                   (rperc bst)))                ; has a right subtree only
              ((null (node-r bst)) (lperc bst)) ; has a left subtree only 
              (t (if (zerop (random 2))         ; has both, random at 0 or 1
                     (lperc bst)
                     (rperc bst)))))

      (defun bst-remove (obj bst <)
        (if (null bst)
            nil
            (let ((elt (node-elt bst)))
              (if (eql obj elt)
                  (percolate bst)
                  (if (funcall < obj elt)
                      (make-node
                       :elt elt
                       :l (bst-remove obj (node-l bst) <)
                       :r (node-r bst))
                      (make-node
                       :elt elt
                       :l (node-l bst)
                       :r (bst-remove obj (node-r bst) < )))))))
#+END_SRC

An inorder traverse function

#+BEGIN_SRC lisp
     (defun bst-inorder-traverse (fn bst)
        (when bst
          (bst-inorder-traverse fn (node-l bst))
          (funcall fn (node-elt bst))
          (bst-inorder-traverse fn (node-r bst))))
#+END_SRC

* Control: Various Operators that violate the Evaluation Rule
  :PROPERTIES:
  :CUSTOM_ID: control-various-operators-that-violate-the-evaluation-rule
  :END:

** Creating Blocks of Code
   :PROPERTIES:
   :CUSTOM_ID: creating-blocks-of-code
   :END:

#+BEGIN_SRC lisp
    ;;; evaluated in order and return the last expression, has side effects
    (progn
      (format t "a")
      (format t "b")
      (+ 1 2))

    ;;; has a name and can be returned from
    (block head
      (format t "Here we go")
      (return-from head 'idea)
      (format t "We'll never see this"))

    ;;; or named nil
    (block nil
      (return 27))

    ;;; with an implicit `block`
    (dolist (x '(a b c d))
      (format t "~A " x)
      (if (eql x 'c)
          (return 'done)))

    ;;; implicit block foo
    (defun foo ()
      (return-from foo 27))
      
    ;;; allow goto, hardly used
    (tagbody
        (setf x 0)
        top
        (setf x (+ x 1))
        (format t "~A " x)
        (if (< x 10) (go top)))
#+END_SRC

Nearly all the time =progn= is used

#+BEGIN_SRC lisp
#+END_SRC


** Multiple Values
   :PROPERTIES:
   :CUSTOM_ID: multiple-values
   :END:

An expression can return zero or more values, the maximum number of
return values is at least 19.

#+BEGIN_SRC lisp
    (defun fun (a b c)
      (values a b c))

    (multiple-value-bind (res1 res2 res3) (fun 1 2 3)
      (format t "~a ~a ~a~&" res1 res2 res3))

    (multiple-value-list (fun 1 2 3))

    (nth-value 0 (values 1 2 3))

    ;;; if something is expecting only one value, all but the first will be discarded
    (let ((x value 1 2))
        x)
    ;;; or if no value is returned, a nil is returned
    (let ((x (values)))
        x)
        
    (multiple-value-call #'+ (values 1 2 3))
    (multiple-value-list (values 'a 'b 'c))
#+END_SRC

** Aborts: catch and throw
   :PROPERTIES:
   :CUSTOM_ID: aborts-catch-and-throw
   :END:

#+BEGIN_SRC lisp
    (defun sub ()
      (throw 'abort 99))

    (defun super()
      (catch 'abort
        (sub)
        (format t "We'll never reach here")))

    ;;; transfer control to the lisp erorr handler
    (progn
      (error "Oops")
      (format t "After the error"))

    (setf x 1)
    (catch 'abort
      (unwind-protect ;; try-finally
           (throw 'abort 99)
        (setf x 2))) ;  wil be evaluated , a `finally`
#+END_SRC

* Functions
  :PROPERTIES:
  :CUSTOM_ID: functions
  :END:

** Global Functions
   :PROPERTIES:
   :CUSTOM_ID: global-functions
   :END:

Functions are at the core of Lisp. =fboundp= tells whether there is a
function with a given symbol as its name. =symbol-function= returns it.

=(defun name (list-of-parameters) (body-of-function))=

=(defun (setf fname) (val rest-of-params) (body-of-function))=: for
=(setf (fname rest-of-params) val)=

#+BEGIN_SRC lisp
    (defun our-third (x)
        "docstring here" ;; a string by itself does not have side-effects, can be retrieved by calling `documentation`
        (car (cdr (cdr x))))
        
    (defun hello (name &optional age gender &key happy))
#+END_SRC

Lisp makes no distinction between a program, a procedure and a function.
Functions do for everything. Use =load= to load a lisp program.

CL has different namespaces for functions and variables. A symbol can be
bound to a value (=boundp=, =symbol-value=) or a function (=fboundp=,
=symbol-function=). If a symbol is evaluated, it's treated as a variable
in that its value cell is returned.

** Local Functions
   :PROPERTIES:
   :CUSTOM_ID: local-functions
   :END:

Local functions are only accessible within a certain context, defined
with =labels= (a kind of =let= for functions)

#+BEGIN_SRC lisp
    (labels ((add10 (x) (+ x 10))
             (consa (x) (cons 'a x)))
      (consa (add10 3)))

    (labels ((len (lst)
               (if (null lst)
                   0
                   (+ (len (cdr lst))  1))))
      (len '(1 2 3 4)))
#+END_SRC

** Parameter List
   :PROPERTIES:
   :CUSTOM_ID: parameter-list
   :END:

- =&rest=: indicates the variable after which is a variadic parameter
  list

- =&optional=: optional parameter. Default values are enclosing in a
  list with the paramter

#+BEGIN_SRC lisp
    ;; optional parameter with a default value 10. This default value can be another parameter, a third variable that indicates the presence of the default parameter can be declared in the default parameter list.
    (defun optional-parameters (a &optional (b 10)) 
      (list a b))
#+END_SRC

- =&key=: keyword parameter. They have default parameters of =nil= if
  not specified. It's even possible to write =((:apple a) (:box b))= to
  specify parameter names different from variable names.

#+BEGIN_SRC lisp
    (defun our-funcall (fn &rest args)
      (apply fn args))
      
    (defun keylist (a &key x y z) ;; unspecified keys default to nil
      (list a x y z))
#+END_SRC

Combining keyword parameters and optional parameters could lead to
problems where keyword symbols are treated as arguments for optional
parameters. Use keyword parameters only.

Combining keyword parameters and the =&rest= parameters might lead to
surprising results: arguments would be treated as both and thus create
duplication.

** Return Values
   :PROPERTIES:
   :CUSTOM_ID: return-values
   :END:

- by default the function returns the value of the last expression.

- =return-from= can be used to return in the middle of a block (e.g. a
  function).

** Functional Programming
   :PROPERTIES:
   :CUSTOM_ID: functional-programming
   :END:

It would inconvenient to do without side-effects entirely.

** Functions as Objects (First-Class Functions)
   :PROPERTIES:
   :CUSTOM_ID: functions-as-objects-first-class-functions
   :END:

- =function= returns a function object given the name of the function.
  Just as ='= is an abbreviation for =(quote ...)=, =#'= (/sharp quote/)
  is for =(function ...)=.

#+BEGIN_SRC lisp
    (apply #'+ '(1 2 3))
    (funcall #'+ 1 2 3)
#+END_SRC

lambda expression (anonymous functions since all Lisp functions are
closures):

#+BEGIN_SRC lisp
    (lambda (x y)
        (+ x y))
#+END_SRC

In common lisp, values or objects have types, not variables. This
approach is called /manifest typing/. An object always has more than one
type. The builtin Common lisp types form a hierarchy of subtypes and
supertypes.

** Compilation
   :PROPERTIES:
   :CUSTOM_ID: compilation
   :END:

=compiled-function-p=, =compile=, =compile-file=.

The inner functions should also be compiled if the containing function
is.

** Recursion
   :PROPERTIES:
   :CUSTOM_ID: recursion
   :END:

The advantage of recursion is precisely that it lets us view algorithms
in a more abstract way.

#+BEGIN_SRC lisp
    (defun our-member (obj lst)
        (if (null lst)
            nil
            (if (eql obj (car lst))
                lst
                (our-member obj (cdr lst)))))
                 
    (defun find-nil (x)
      (and (not (null x))
           (or (null (car x))
               (find-nil (cdr x)))))

    (defun find-list (lst)
      (and (not (null lst))
           (or (listp (car lst))
               (find-list (cdr lst)))))
               
    (defun my-position (elt lst)
      (if (null lst)
          nil
          (if (eql (car lst) elt)
              0
              (let ((z (my-position elt (cdr lst))))
                (and z (+ z 1))))))

    (defun linear-search-recursive (item lst)
      (if (null lst)
          -1
          (if (eql item (car lst))
              0
              (let ((i (linear-search-recursive item (cdr lst))))
                (if (eql i -1)
                    -1
                    (+ 1 i))))))
#+END_SRC
