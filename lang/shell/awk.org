#+title: Awk

A sequence of patterns and actions that tell what to look for in the input data
and what to do when it's found. A set of files arae searched for lines matched by
any of the patterns and the corresponding action is performed on a matching line.

* Basics

- Pattern-action statement: =pattenr { action }=. Each awk program is a sequence of one or more pattern-action statements.
  + a pattern without an action prints all lines matching the pattern
  + actions are separated by newlines or semicolons

#+begin_src awk
ip a | awk '$1 == "inet" { print $2} '
awk -f programFile inputfiless...
#+end_src

- =$1=, =$2= ... fields; =$0= the entire line; =NF=: the number of fields; =$NF=: the last field. Any expression can be used after =$= to denote a field number; =NR=: number of lines

#+begin_src awk
{ print } # or
{ print $0 }
#+end_src

- the C-style =printf= format print is also supported.

- =BEGIN= matches before the first line of the first input file; =END= matches after the last line of the last file;
  Used to do anything before/after the actual matching.

- declaration is not necessary for variables

  #+begin_src awk
{ pay += $2 * $3 }; END { printf "total pay %.2f\n", pay } # pay is defined the first time it's used and is used afterwards
  #+end_src

- string are concatenated by a blank between them.

#+begin_src awk
'{ names = names $1 " " }; END { print names }'
#+end_src

- NR retains its value in an =END= action, =$0= does not (but =gawk= and =mawk= does preserve =$0=)

#+begin_src awk
# show the last line
{ last = $0 }; END { print last } # END { print $0 } works for some implementation
#+end_src

- C-style if-else, while and for clauses are available.

- Arrays are more powerful than C arrays, with automatic resizing.

#+begin_src awk
{ line[NR] = $0 }
END {
    for (i = NR; i > 0; i--) {
        print line[i]
    }
}
#+end_src


** Some Oneliners

#+begin_src awk
END {print NR } # print line count

NR = 10 # print the tenth line

# print the count of lines containing "Beth"
/Beth/ { nlines += 1 }
END { print nliens }
#+end_src

* Language

- The opening brace of an action muyst be on the same line as the pattern it accompanies.

- statements can be broken after backslashes, commas.

** Patterns

- =BEGIN=, =END=: a way to gain control for initialization and wrapup.
  + =FS= can be changed at =BEGIN=.

- /expression/: statements are executed at each input line where the expression evaluates to true.

- =/regex/=: lines are matched when they conbtain a string matched by the regex.

- compound pattern: expressions with =&&=, =||=, =|= and parentheses.

- =pattern1, pattern2=: a range pattern that starts from the line matched by =pattern1= to the line matched by =pattenr2= inclusively.

*** Regex Matching

- =/regex/=: matches the input line

- =expression ~ /regex/=: matches the string value of the expression

=expression !~ /regex/=: matches if the string value of the expression does not contain a substring matched by the regex.

Gawk uses the POSIX extended regex.

- metacharacters: =\=, =^=, =$=, =.=, =[=, =]=, =|=, =(=, =)=, =*=, =+=, =?=

- A basic regex
  + a nonmetacharacter that matches itself
  + an escape character e.g. =\t=
  + a quoted metacharacter: =\*=
  + =^= and =$= that matches the beginning and the end of a string
  + =.=: any single character
  + a character class. Quoting metacharacters is not always needed inside a character class.

- operators conmbine regexes into larger ones (=A= and =B= are regexes): ordered by precedence from the lowest to the highest
  + alternation: =A|B= matches =A= or =B=
  + concatenation: =AB=
  + closure =*=: matches zero or more of the previous regex.
  + positive closure =+=: one or more of the previous regex.
  + zero or one =?=
  + grouping =(r)=: matches the same strings as the pattern =r= does.
    parentheses can often be omitted since groupings take precedence.

*** Range Pattern

A range pattern matches multiple lines. If the second pattern is not found, the match goes on.
