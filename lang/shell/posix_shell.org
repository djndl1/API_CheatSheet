#+title: Posix Shell

* History

- Thompson Shell (Ken Thompson, Unix Version 1 throughout 6), modeled after the Multics shell =RUNCOM=,
  hence the =rc= configuration.

- Bourne Shell (Stephen Bourne, Unix Version 7). There are some modern alternatives:
  + Almquist Shell (ash), a clone of the original Bourne shell (FreeBSD, NetBSD, Busybox, dash)
  + Bourne-Again Shell: the GNU shell as a superset, the default interactive
    shell on most Linux distros.
  + KornShell (ksh), the POSIX shell is a subset of Korn shell, an enhanced
    version the Bourne shell.
  + Public domain Korn shell (pdksh)
    - MirBSD Korn shell (mksh), used by Android as =/system/bin/sh=.
  + Z shell: a relatively modern shell compatible with bash.

- C shell: modelled after the C programming language. The TENEX C shell as an
  improved version is a modern alternative.

* Dash

This note uses =dash= as the POSIX shell due to its availability on Debian-based
Linux distros and its fully POSIX compliance. On Debian, Ubuntu and termux, =dash= is not configured with
=libedit= and thus gives no support for vi-mode line editing and history.

* Filename Expansion

Wildcards (=*=, =?=, =[=, =]=) in POSIX shells expands only filenames, not
random strings. They are not simplified regexp. They are expanded automatically when
they occurs in a shell.

- Files whose name starts with a dote are not normally listed and various
  shells, utilities follow this convention.

* Quoting

Metacharacters are commonly used in shell. They must be quoted or escaped to be
treated as regular characters. But quoted characters do not have a
special meaning. Double quotes are weak in that certain characters retain their
special meanings.

* Control Flow Structure

- list :: a series of command that ends with a semicolon or ends with a newline character.
  A list can have more than one command: the last one is used to make a
  decision.  A list cannot be empty: empty statement =:= must be used.

** Conditional

*** if

#+begin_src shell
if list then list fi
if list then list else list fi
if list then list elif list then list fi
if list then list elif list then list elif list then list fi
if list then list elif list then list else list fi
#+end_src

=if= may be nested.

*** case

#+begin_src shell
case word in esac
case word in pattern ) list ;; esac
case word in pattern | pattern) list ;; esac
#+end_src

#+begin_src shell
echo answer yes or no
read word
case "$word" in
    yes | YES )
        echo you answered yes
        ;;
    no | NO )
        echo you answered no
        ;;
esac
#+end_src

** Iteration

*** while

#+begin_src shell
while list do list done
#+end_src

#+begin_src shell
while read msg
do
    echo "$msg"
done
#+end_src

*** until

#+begin_src shell
until list do list done
#+end_src

*** for

#+begin_src shell
for name do list done # use positional arguments
for name in word ... do list done # use the word list
#+end_src

#+begin_src shell
for args in "a A" "b B" "c C"
do
  set $args
  echo lower case is $1, upper case is $2
done
#+end_src

** break & continue

They work the way as in C.
