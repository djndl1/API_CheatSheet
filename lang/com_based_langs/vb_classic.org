#+TITLE: Vb Classic
#+bibliography: vb_classic.bib
#+cite_export: csl

*Visual Basic Application (VBA)* is the name of the language. A glue language
that interfaces with various objects that make up an application via the host
application's object model.

VB5 introduces the Visual Basic IDE. VBA programs and the VBA development
environment itself both execute in the same process before compilation.

In the era of [[https://en.wikipedia.org/wiki/Rapid_application_development][Rapid Application Development]]

1. Heavily integrated with COM/OLE, (=String= is OLE =BSTR= and arrays are =SAFEARRAY=)

2. Primarily used for Windows GUI apps

3. Use refcount for memory management

4. Compiled to P-code or native code

5. Supported on up to Windows 10

6. Poor support on OOP and limited threading capability

7. It is possible to reference any COM-visible objects in VB6, including those in CLR.

8. event-driven programming, modular programming and half OOP.

* VBA Development Environment

** Computational Environemnt

Mostly hosted an another application and made available to access host
application data and host computational processes.

** Project Structure

- =.vbp= :: the [[#projectfile][project file]]

- =.frm= :: a form file

- =.frx= :: binary data (images etc.) of a form

- =.bas= :: standard code module

- =.cls= :: Class module

- =.res= :: resource files, bitmaps, text strings and other data.

- =.vbw= :: not part of a project, used by the IDE to position the window.

** [[https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-basic-6/aa231236(v=vs.60)][VB6.exe]]

This executable is the IDE for Visual Basic Classic but also a command line tool
for VB compilation.

#+begin_src shell
# compile a VB6 project
# output as filename
# to output directory
# compilation definition, like C's macro
vb6.exe /make project.vbp [/out filename] [/outdir path] [/d const=value]

# to make a console app
# use MS linker to edit the subsystem
link /edit /subsystem:console app.exe
#+end_src

** Project File =.vbp=
:PROPERTIES:
:CUSTOM_ID: projectfile
:END:

Here is an example with comments;
The bare minimum requires =Type=, =Reference= to =stdole=.tlb=, =Module=, =Startup=

#+begin_src ini
Type=[Exe for Standard Exe,OleExe for ActiveX EXE,OleDll for ActiveX DLL,Control for ActiveX Control]  # project type
Reference=*\G{COM Library UUID}#Version#0#PathToDllOrTypeLib#Library Helpstring name
Module=ModuleName; ModuleFile.bas # module source file
Form=FormName.frm  # form source file
Form=MDIForm.frm
Class=ClassName; ClassName.cls # class source file
UserControl=UserControlName.ctl # UserControl source file
Startup="Sub Main" # Startup object
HelpFile="" # a help file for the project
[Description=Project Description] # optional
Title="MyAppName"
ExeName32="ExecutableName.exe"
Command32=""
Name="MyProjectName"
MajorVer=1
MinorVer=0
RevisionVer=0
AutoIncrementVer=0
CompilationType=[-1 for P-code, 0 for native]
Unattended=[0 for false, -1 for true] # unattended execution
...
#+end_src

Here is a VB module source file

#+begin_src sql
' a VB module metainfo
Attribute VB_Name = "ModuleName"
Option Explicit
#+end_src

And a class source file

#+begin_src fortran
VERSION 1.0 CLASS
BEGIN 'properties
  MultiUse = -1  'True
  Persistable = 0  'NotPersistable
  DataBindingBehavior = 0  'vbNone
  DataSourceBehavior  = 0  'vbNone
  MTSTransactionMode  = 0  'NotAnMTSObject
END
Attribute VB_Name = "Class1"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
#+end_src

** Language Variants

1. VBA: for application scripting, still COM/OLE based

2. VBScript: COM-based Windows scripting language for automation and web page (succeeded by PowerShell)

3. GAMBAS: a FOSS variant mainly on Linux

* Basics

VB keywords and identifiers are Case-Insensitive. Be careful, many common words
used in other language are keywords in VB (e.g. =Open=, =Close= etc.)

** Concepts

- *Data Value* :: a single element from a specific finite domain of such
  elements, e.g. single, double, integer, =Nothing=, =Missing=, =Error=,
  aggregate type values etc.

- *Entity* :: a component that can be accessed by name or index, according to
  the resolution rules for simple name expressions, index expressions, and member
  access expressions. e.g. projects, procedural modules, types (class modules,
  UDTs, Enums or built-in types), properties, functions, subroutines, events,
  variables, literals, constants and conditional constants.

- *Variable* :: a /mutable/ container of data values.

- *Dependent variable* :: the variable that corresponding to an element of an
  aggregate value.

- *Extent* of a variable :: the time a variable is created to the time it is destroyed.
  + /Program extent/ :: the entire existence of an active VBA environment, i.e. static
  + /Module extent/ :: the span from the point the module is incorporated into the project
    to the point it is removed from the VBA environment, e.g. static local
    variable in a procedure, a module variable declaration.
  + /Procedure Extent/ :: the duration of a particular procedure invocation.
  + /Object Extent/ :: the lifespan of the containing object, e.g. a variable
    declaration within a class module
  + /Aggregate Extent/ :: the lifespan of the variable holding the containing
    aggregate data value.

- *Procedure* :: a unit of algorithmic functionality, identified by its name
  that is part of its declaration, including subroutines, functions and properties.
  + *Property* :: a set of named procedures referenced as if it was a variable
    name. Properties are more than OOP-object members.

- *Objects* :: In OOP sense, a set of related variables, procedures and events.
  + events are =RaiseEvent=-ed
  + Each class has a public interface of its own, but it may also implement the
    public interface of one or more other classes.

- *Extended Environment* :: additional entities accessible using VBA
  + the VBA standard library
  + Host environment: entities defined by the host app, accessible similar to
    the VBA library
  + external variables, procedures and others: entities defined using other
    programming languages.

** Program Entry Point

Every global variables and constants are loaded before the entry point
(Form-level global variables are not since the form hasn't been loaded).
A form or a code module function can be the entry point of a program.

- /Form/: the form is loaded and several events are fired
  + =Initialize=: if the code references a control, =Load= is immediately fired
    before the end of =Initialize=.
  + =Load=

- /code module/: the =Main= procedure (=Public= or =Private= or none).
  + a form can be instantiated and shown in =Main=, the recommended alternative
    to a startup form.

** Program Exit

- The program exits the =Main= procedure returns.

- the =End= statement aborts the program without cleanup.

- ActiveX components shouldn't exit by themselves: they should be managed by the
  OS since they may be referenced by other apps.

- =Unload= the main form exits the program.

** Variable and Constants

#+begin_src basic
Dim varname As varType, [varname2 As varType2]
#+end_src

*USE* =Option Explicit= *TO FORCE EXPLICIT DECLARATION OF VARIABLES AND CONSTANTS*.

*** Constants

#+begin_src vba
[ Public | Private ] Const constname [ As type ] = expression
#+end_src

*** Object Variable

- In general terms, late binding is slightly more efficient for out-of-process
  ActiveX EXEs, and early binding is vastly more efficient for in-process DLLs.

- Setting an =Object= variable requires a =Set=. Value assignment might
  causes the right-side to use its default property and thus unexpected behavior.

*** Scopes and Lifetimes

*Scope* is the visibility of a variable; *lifetime* is the period of program
execution when the variable is live and available for use.

- /Global/ :: BAS module =Public= variables. application long lifetime; application-wide scope
  + best practice: define all variables in a UDT and declare such a UDT in one
    place. =Public MyPublicVar As Long= in BAS modules.

- /Private/ module-level :: =Dim= or =Private= statement in the declaration
  section of a module. Module-long lifetime

- /Public/ module-level :: except in BAS modules where /Public/ variables are
  global or called /property/; module-long lifetime.

- /Dynamic Local/ :: =Dim= defined within a procedure; procedure-wide scope/lifetime.

- /Static Local/ :: procedure-wide scope; module-level lifetime.
  =Static InProgress As Boolean=; useful for preventing procedure reentry. VB6
  apps are single-threaded, no need to worry about thread safety.

- /Project/ :: =Friend= inside an object (class or form) module. Project-wide
  scope.

** Data Types

*** Simple Types

- =Boolean= (2-byte): =0= for =False= and =-1= for =True=

- =Byte=

- =Integer= (16-bit) and =Long= (32-bit, the preferred type for integer values):
  =&= prefixed forces a literal integer into a =Long= value.
  + =&H1234=, =&O011064=
  + an =enum= type can have a maximum sentinel value to guard against invalid
    integers assigned to a variable of such a =enum= type.

- =Single= and =Double=

- =String= (=BSTR=):
  + Unicode is supported but Unicode String literals are not due to the IDE's
    non-Unicodeness. The IDE doesn't even recognize support UTF-16.
    Use =ChrW= instead
  + =Dim VarLenStr As String= (variable-length);
    =Dim FixedLenStr As String * 40= fixed-length (not well-supported by VB's
    string functions and causes low performance);
  + =""""= for embedding a quote inside a string.
  + String constants such as =vbTab= and =vbCrLf= are available.
  + =NULL= and =""= are equivalent for =BSTR=. See
    [[https://nolongerset.com/check-for-empty-strings-in-vba/][Check for Empty Strings in VBA]].

- =Date= ([[https://learn.microsoft.com/en-us/cpp/atl-mfc-shared/date-type?view=msvc-170][OLE =DATE=]], 8-bytes): one-second precision
  + ~#12/3/2013#~, ~#2024-01-03 13:21:33#~. No subsecond precision.
  + actually a DateTime

- =Object=: stores references. Object variables are assigned using =Set=.
  Missing =Set= might lead to unexpected results (the value might be assigned to
  the object's default property). =Nothing= for null reference.

- =Currency= (=CURRENCY=, 8-byte number in an integer format scaled down by
  10000, i.e. =2^63 / 10000=)

*** =Variant=

the default data type in VBA if no type is not specified.
=Variant= is basically a dynamic type.

- =VARIANT= defined by OLE, 16 bytes with 2 bytes for typing and 14
  bytes for actual data; most types except =Decimal= use only the upper 8
  bytes.

- Special values
  + =Empty= (the uninitialized =Variant= variable value), =IsEmpty()=;
  + =Null= (no valid data), =IsNull=
  + =Error= (an error code)

- =Variant= can be useful when returning a result of different types on some
  condition, especially as a =Result<T, E>= type since it can contains a
  =vbError= type, checked using =IsError=.

- Use =IsObject= instead of =VarType= to test for an object within a  =Variant=.
  The latter may evaluates to its default property before passed to =VarType=.

- Use =VarType= and =TypeName= to get the type information of a =Variant= variable.

- [[https://learn.microsoft.com/en-us/office/vba/language/reference/user-interface-help/decimal-data-type][Decimal]] (12-byte unsigned integer with a scaling factor): not declarable (not
  a variable type but a data type), used
  only as a =Variant= with =CDec=

There are several different null/empty values, some of which are commonly used
with =Variant=.

- =Nothing= :: null object reference value.

- =vbEmpty= :: uninitialized =Variant= value.

- =Null= :: special =Variant= value that denotes "no value", =DBNull.Value=
  + =Null = Null= returns =False=, use =IsNull(var)=.
  + =vbNull= :: =Null= variant's type enum.

- =vbNullChar= :: C's ='\0'= (the actual =Variant= value seems a =String=)

- =vbNullString= :: empty string literal =""=.

*** User-Defined Type

basically a structure or record type.

+ Fixed-length strings are stored directly in a UDT while variable strings are stored as pointers.

+ Structures can contain substructures.

#+begin_src vba
Private Type EmployeeUDT
    Name As String
	DepartmentID As Long
    Salary As Currency
End Type

emp1 = emp2 ' copy one UDT to another
#+end_src

*** Arrays: Ordered sets of homogeneous items.

Creating an array is called *dimensioning* (defining the size of) the array,
hence =Dim= and =ReDim=.

+ can be static or dynamic. Dynamic arrays can be first declared =Dim arr() As
  Type= then defined using =ReDim arr(N) As Type= or with only =ReDim=.

+ The lower index is assumed to be =0= by default or explicitly with
    =ReDim Customer(1 To 1000) As String=. Also created by =Array()=

+ To resize an array, use =ReDim= again.
    - To destroy an array, use the =Erase= statement.
    - =ReDim Preserve= tries to preserve the original values.
      Only the last dimension can resized with =Preserve=

+ Use =LBound=, =UBound= for bounds and length.

+ Array can be assigned to a =Variant= with =var = arr()= by physically copying.
    - an array and an =Variant= can be assigned to each other.
    - an array in =Variant= has its =VarType(v) = vbArray + vbElementType=.
    - an array passed into a procedure as an =Variant= by ref while assignment
      makes an array copy itself.

+ Array assignment only works if the target is a dynamic array. =b() = a()=.

+ Byte Array: a string can be assigned to a byte array with all its Unicode
    characters converted to its proper binary representation. The opposite is
    also possible. =LenB=

#+begin_src vba
' Dynamically polymorphism, slow execution
Function ArraySum(arr As Variant) As Variant
    Dim i As Long, result As Variant
    For i = LBound(arr) To UBound(arr)
        result = result + arr(i)
    Next
    ArraySum = result
End Function
#+end_src

+ to use array of arrays, each array element should be a =Variant= that actually
  contains an array.

*** Type Conversions

**** Implicit

Various data types are converted automatically, even from string to integers.

#+begin_src vba
   Dim s As String
   s = "123"
   Dim i As Long
   i = s            'i = 123
#+end_src

**** Explicit

- legacy functions: =Int=, =Str= ...

- the =C*= series locale-aware functions
  + =CBool=, =CByte=, =CDec=, =CDate=, =CCur=, =CDbl=, =CSng=, =CInt=, =CLng=,
    =CStr=, =CVar=,


*** [[https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-basic-6/aa231021(v=vs.60)][Collection]]

A heterogeneous collection of =Variant= items, indexed one-based by =Long= with optional
=String= keys.

=Collection= supports the =For Each= enumeration by implementing a =NewEnum=
method that returns an enumerator, which can be access by
=collectionVar.[_NewEnum]=

=Collection= does not support replacing an element in place. One has to
=.Remove= and then =.Add Item, , beforeThisIndex=.

One trick to store UDT types in =Collection= is to store a UDT as an array.

#+begin_src vba
' Filter out all duplicate entries in any Variant-compatible array.
' On entry, NUMELS should be set to the number of items to be examined.
' On exit, NUMELS holds the number of nonduplicate items.
Sub FilterDuplicates(arr As Variant, numEls As Long)
    Dim col As New Collection, i As Long, j As Long
    On Error Resume Next
    j = LBound(arr) - 1
    For i = LBound(arr) To numEls
        ' Add a dummy zero value, but use the array's value as the key.
        col.Add 0, CStr(arr(i))
        If Err = 0 Then
            j = j + 1
            If i <> j Then arr(j) = arr(i)
        Else
            Err.Clear
        End If
    Next
    ' Clear all remaining items.
    For i = j + 1 To numEls: arr(i) = Empty: Next
    numEls = j
End Sub
#+end_src

** Source Code Organization

*** Modules

Module are made a of a *declaration section* (types, constants and variables)
plus *a collection of procedures*.

- Form Module: basically class module with GUI controls

- Class Module: OOP-like

- BAS Module: C-like compilation unit

*** Procedure/Function

- Public procedures of a public module can be called through COM. =Public= is
  the default scope attribute for procedures.

- All event procedures are =Private=

- =Friend= is project-level scope.

#+begin_src vba
Private/Public Sub SubName
...
End Sub

Private/Public Function FuncName
...
End Function
#+end_src

**** Invoking Functions/Procedures

There are some weird rules about parentheses with subroutine call.

If a function is used in an expression, parameters must be enclosed within
parentheses. Otherwise, =Call= must be used with parentheses. To avoid all these
rules, one may use =Call= if possible.

- Unnecessary parentheses causes problems especially for subroutines with a
  single parameter. The parameter is evaluated (either into a rvalue or a
  default property value) in the parentheses before being
  passed into the subroutine.

*** Parameters and Return Values

- Parameters can be passed =ByVal= or =ByRef= (by default even for basic types
  like =Long=, which can lead to undetected bugs).
  + =ByVal= performs possible type conversion for values passed in
  + A =ByRef Variant= accepts arguments of any types.
    #+begin_src vba
    ' Swap values of any type.
    Sub Swap(first As Variant, second As Variant)
        Dim temp As Variant
        temp = first: first = second: second = temp
    End Sub
    #+end_src
  + Use =ByVal= whenever possible.

- Passing User Defined Types is restricted
  + a =Public= UDT defined in a =BAS= module cannot be only be passed into
    =Public= procedures defined in BAS modules. (Such UDT types are unknown to COM)
  + Define a COM-aware UDT in a class module or a form module.

- A type private to a project can be used as a parameter or the return value of
  procedure that can be called from outside the project.

- /Optional/ parameters
  + If the type is =Variant= (an =Err= value), it can checked by =IsMissing()=.
    A =Missing= value is pushed onto the stack for an optional argument.
    =IsMissing= only works with an optional parameter once, the second time it
    would return =False=.
  + Can be used with a default value. ~Optional color As Long = vbWhite~;
  + A non-Variant optional parameter receives its default value if no default value
    is assigned (not =Missing=).
  + a UDT type cannot be used with =Optional=.

- /Named/ arguments: ~NamedArg := paramVal~.
  + Better than multiple commas with optional parameters in between before a
    final parameter.

- =ParamArray args() As Variant=: any number of arguments as a =Variant= array.
  + (undocumented) =IsMissing= can be used with =ParamArray= =args= to check if
    =args= is an empty array=. The legal syntax is to check if =LBound(args) > UBound(args)=.

#+begin_src vba
With Emp
    Print .Name
    Print .Salary
    With .Location
        Print .Address
        Print .City & "  " & .Zip & "  " & .State
    End With
End Type
#+end_src

** Programming Construct

*** Branch

- Logical operator with ===, =<>=; =And=, =Or=, =Xor=, =Not= bitwise operator
  (for boolean there's no difference)
  + be careful when using these operators with integers in conditional expressions.

- =If () Then ... ElseIf () Then ... Else ...=; multi-line branch statement
   requires a =End If=.
   + any non-zero value in =IF= is considered =True=
   + =IF= is not short-circuited

- =Select Case= supports short-circuited evaluation
  + Case subexpressions are evaluated only until they return True, after which
    all the remaining expressions on the same line are skipped.

#+begin_src vba
Select Case Mid$(Text, i, 1)
    Case "0" To "9"
        ' It's a digit.
    Case "A" To "Z", "a" To "z"
        ' It's a letter.
    Case ".", ",", " ", ";", ":", "?" ' connected by OR
        ' It's a punctuation symbol or a space.
    Case Else
        ' It's something else.
End Select
#+end_src

- =GoTo= is there but not advised. Use sparingly.

**** Functions

All expressions are always evaluated which might lead to unexpected bugs.

- =IIF()=: basically =IF ... Else ... End If=

- =Choose()=: choose a candidate based on the index expression

- =Switch()=: a simple replacement for =Select Case=

*** Loop

There is no =continue= in VB, use =IF= with =GOTO=

#+begin_src vba
' item must be a Variant or an Object type if elements are of certain object type
For Each item In Col
...  ' Exit For
Next item

For i = 0 To N [Step Increment]
...
Next i
#+end_src

#+begin_src vba
' While Wend is limited in VBA
While (expr) ' break is not available, use Do While Loop
...
Wend

' break out of the loop by `Exit Do`
Do While (expr) ''
...
Loop

Do
...
Loop [Until (expr)]
#+end_src

** Event

- [[https://learn.microsoft.com/en-us/dotnet/visual-basic/language-reference/modifiers/withevents][=WithEvents=]]:

** Quick I/O

=InputBox=

=MsgBox=

** Common Functions

=Len(String)=

=&=: string concatenation

=Mid=: get a substring

- =LBound=, =UBound=

- =Split= a string

- =Join= an array of strings

- =Filter= a string based on a criterion

- =Left=, =Right=: the leftmost/rightmost n chars

- =LCase=, =UCase=

- =Space=: n spaces

- =Replace= a part of a string with another string

- =StrReverse=

- =LTrim=, =RTrim=

- =Asc= a character

- =Chr= an ASCII code integer

* Error Handling

Primitive with =GoTo= but better than C's =errno= check.

- =On Error Resume Next=: ignore any error.
  + can be used to test if an object has certain properties.

- =On Error Resume=: retry the erring line. Error is not cleared after the
  control returns to the calling code.

- =On Error Goto=: jump to the named label to handle any error; to exit from a
  error routine:
  + =Resume= to retry the line of code that caused the error.
  + =Resume Next= to resume execution at the next line after the one that caused
    the error
  + =Resume <label>=
  + =Err.Raise=: errs out again
  + =Exit Sub= or =Exit Function= with the calling code receiving a zero error code.

- =On Error Goto 0=: disable any previous =On Error=

If any error inside an event handler goes unhandled, the program terminates.
Error that go unhandled in event procedures terminates the program immediately.

#+begin_src vba
Err.Raise Number, [Source], [Description], [HelpFile], [HelpContext]
#+end_src

* OOP

- No parameterized constructors, initializer methods and factory methods are used.

- Properties can have arguments

- Public variables have default property implemented by the compiler.

** Auto-Instancing

The problem with auto-instancing is not about performance: the reference is
checked for nothing in any case. Auto-instancing is not declartion along with
initialization. It doesn't initialize the variable on the spot and this variable
is guaranteed not to be =Nothing= even if it has been set to =Nothing=.
Auto-instancing prevents the user from initializing and assigning to the
variable explicitly.

** Properties

Properties are not limited to class modules: ordinary code modules may have
properties, similar to static properties in C#.

#+begin_src vba
Private m_BirthDate As Date

Property Get BirthDate() As Date
    BirthDate = m_BirthDate
End Property
Property Let BirthDate(ByVal newValue As Date)
    If newValue >= Now Then Err.Raise 1001, , "Future Birth Date !"
    m_BirthDate = newValue
End Property
#+end_src

To implement a init-once property, use =Variant= and =IsEmpty=.

A property can take an argument:

#+begin_src vba
Private m_Notes(1 To 10) As String

Property Get Notes(Index As Integer) As String
    Notes = m_Notes (Index)
End Property
Property Let Notes(Index As Integer, ByVal newValue As String)
    ' Check for subscript out of range error.
    If Index < LBound(m_Notes) Or Index > UBound(m_Notes) Then Err.Raise 9
    m_Notes(Index) = newValue
End Property
#+end_src

Every =Public= member variables are accessed through a pair of hidden
procedures from outside the class or with
=Me.property=, which causes the following code invalid

#+begin_src vba
Sub ToCentimeters (value As Single)
    ' Value is received by reference, therefore it can be changed.
    value = value * 2.54
End Sub

ToCentimeters pers.Height                ' pers.Height returns a rvalue, not a reference
#+end_src

#+begin_src vba
Dim m_HomeAddress As CAddress      ' A module-level private variable.

Property Get HomeAddress() As CAddress
    Set HomeAddress = m_HomeAddress
End Property
Property Set HomeAddress(ByVal newValue As CAddress)
    Set m_HomeAddress = newValue
End Property
#+end_src

*** Variant Property

=Property Set= accepts object parameter and =Property Let= accepts value types.

#+begin_src vba
Private m_CurrentAddress As Variant

Property Get CurrentAddress() As Variant
    If IsObject(m_CurrentAddress) Then
        Set CurrentAddress = m_CurrentAddress   ' Return a CAddress object.
    Else
        CurrentAddress = m_CurrentAddress       ' Return a string.
    End If
End Property

Property Let CurrentAddress(ByVal newValue As Variant)
    ' Check that it is a string value
    If VarType(newValue) <> vbString Then Err.Raise 5
    m_CurrentAddress = newValue
End Property

Property Set CurrentAddress(ByVal newValue As Variant)
    ' Check that it is a CAddress object.
    If TypeName(newValue) <> "CAddress" Then Err.Raise 5
    Set m_CurrentAddress = newValue
End Property

' in case only one type of object may be accepted'
Property Set CurrentAddress(ByVal newValue As CAddress)
    Set m_CurrentAddress = newValue
End Property
#+end_src

*** Property In BAS Module (Undocumented)

#+begin_src vba
Dim m_Percent As Integer

Property Get Percent() As Integer
    Percent = m_Percent
End Property
Property Let Percent(newValue As Integer)
    If newValue < 0 Or newValue > 100 Then Err.Raise 5
    m_Percent = newValue
End Property

'Implement a special global constant'
Property Get DoubleCrLf() As String
    DoubleCrLf = vbCrLf &; vbCrLf
End Property
#+end_src



** Class Events

- =Class_Initialize=

- =Class_Terminate=: finalizer. fired before releasing the data instance block and
  terminating the object's life.
  + useful for RAII or debug tracing (a special =Tracer= class created at the
    entry of a procedure)

*** Custom Event Implementation

#+begin_src vba
' implementation
' define an event
Event FileCopied(file As String, DestPath As String)

Public Sub StartCopy(filespec As String)
    ...
    RaiseEvent FileCopied(thisFile, thisDestPath) ' raise the event
End Sub
#+end_src

To subscribe to an event, declare the event source with =WithEvents=,
the event handler should be named as =EventSourceVariable_EventName=.
Raising events are not asynchronous.

#+begin_src vba
' subscribe to an event
Dim WithEvents Fop As CFileOp ' declare the event source object with WithEvents

Private Sub Fop_FileCopied(file As String, DestPath As String)
    ...
End Sub
#+end_src

** Attribute

*** Class Module Attributes

#+begin_src vba
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
  Persistable = 0  'NotPersistable
  DataBindingBehavior = 0  'vbNone
  DataSourceBehavior  = 0  'vbNone
  MTSTransactionMode  = 0  'NotAnMTSObject
END
Attribute VB_Name = ""
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
#+end_src

- =VB_Name=: class name

- =VB_PredeclaredId=: if =True=,  the default instance
  variable is given the name of the class as its name (a singleton with the same
  name as the class name).

*** Procedure Attributes

Tools-Procedure Attributes: stored next to the member definition, not shown in
the IDE.

**** Default Property/Method (Not Encouraged)

Default property/method is used if any member name is omitted when using an
object. Object Browser can change the default member of a class, which is
strongly discouraged.

** Object Structure and Memory Management

- Reference Counting

- Structure:
  - *VTable pointer*: The first seven entries are =IUnknown= and =IDispatch=
    methods. All public instance functions, procedures, properties are
    virtual (that's how COM works).
    + /early VTable binding/: The compiler produces VTable offsets that are then
      efficiently used at run time to access the object's properties and
      methods.
    + /early ID binding/: the compiler can't derive the actual offset in the
      VTable, but at least it can check that the property or method is there. If
      so, the compiler stores a special ID value in the executable code. At run
      time, Visual Basic uses this ID for a very quick look in the object's list
      of methods (used by ActiveX controls).
    + /late binding/: the compiler can't deduce which type of object such a
      variable will contain and can therefore store only information about the
      property's or the method's name and arguments.
  - refcounter
  - module variables and static variables.

#+begin_src vba
Dim obj As Object
If n > = 0.5 Then
    Set obj = New CPerson
Else
    Set obj = New CCustomer
End If
Print obj.CompleteName 'late binding
#+end_src

- Termination:
  + Visual Basic prevents an object from being destroyed while its procedures
    are being executed.

- =Is=: check object identity

** Reflection

- =CallByName(object, procname, calltype, [,arguments])=: late binding call

#+begin_src vba
Function GetProperties(obj As Object, ParamArray props() As Variant) As String()
    Dim i As Integer, result() As String
    On Error Resume Next
    ' Prepare the result array.
    ReDim result(LBound(props) To UBound(props)) As String
    ' Retrieve all properties in turn.
    For i = LBound(props) To UBound(props)
        result(i) = vbNullChar
        ' If the call fails, this item is skipped.
        result(i) = props(i) &; "=" &; CallByName(obj, props(i), vbGet)
    Next
    ' Filter out invalid lines.
    GetProperties = Filter(result(), vbNullChar, False)
End Function

' Assign a group of properties in one operation.
' Expects an array in the format returned by GetProperties
Sub SetProperties(obj As Object, props() As String)
    Dim i As Integer, temp() As String
    For i = LBound(props) To UBound(props)
        ' Get the Name-Value components.
        temp() = Split(props(i), "=")
        ' Assign the property.
        CallByName obj, temp(0), vbLet, temp(1)
    Next
End Sub
#+end_src

- =TypeOf ... Is ...=: test type. Inefficient

#+begin_src vba
' instead of using TypeOf'
Dim lst As ListBox, cbo As ComboBox
On Error Resume Next
Set lst = obj     ' The assignment that fails will leave
Set cbo = obj     ' the corresponding variable set to Nothing.
On Error Goto 0   ' Cancel error trapping.
#+end_src

- =TypeName()=: the name of an object's class in the form of a string.

- =ByRef= and =ByVal= for object variables: basically in the same way as =ref=
  and non-=ref= parameters in C#.

#+begin_src vba
Sub Reset(pers As CPerson)     ' ByRef can be omitted.
    Set pers = Nothing         ' This actually sets the original
End Sub                        ' variable to Nothing.

Sub Reset2(ByVal pers As CPerson)
    Set pers = Nothing         ' This code doesn't do anything.
End Sub
#+end_src

** Collection

Not only can a wrapped collection object provides type safety and other niceties,
the wrapper is itself a factory that encapsulates the object activation logic.
The collection keeps an account of all the created objects.

A contained object may keep a reference to its containing collection, which
inevitably introduces circular reference, which can not be easily solved by VBA
itself unless a weak reference type is available or the user would have to
manually break the cycle.

** Inheritance

Not natively supported.

*** Through Delegation

Initialize the base object in the =Class_Initialize= handler and delegate
behaviors and property access to the base object. A second interface or the base
object can be accessed through a second variable.

Inheritance through delegation gives the subclass freedom to use the base
implementation or override the behavior.

** Polymorphism

VBA supports polymophisim either through late binding (=Object= type variable)
or through interfaces.

*** Interfaces

There is no dedicated interface type in VBA. Each VBA class module defines an implicit
COM interface thus also acts as an *abstract class*.
Class modules can include one or more *secondary* interfaces.
An interface is defined as an *abstract* class with no executable code.
Interfaces never include =Event= declarations. A concrete class is an
interface itself and can be implemented by another class module, possibly with
inheritance through delegation.

#+begin_src vba
' The IShape class module
Public Hidden As Boolean

Sub Draw(pic As Object)
    ' (Empty comment to prevent automatic deletion of this routine)
End Sub

Sub Move(stepX As Single, stepY As Single)
    '
End Sub

Sub Zoom(ZoomFactor As Single)
    '
End Sub
#+end_src

#+begin_src vba
Implements IShape

Public Property Let IShape_Hidden(ByVal rhs As Boolean)
'''
End Property

Public Property Get IShape_Hidden() As Boolean
'''
End Property

Sub IShape_Draw(pic As Object)
  '''
End Sub

Sub IShape_Move(stepX As Single, stepY As Single)
  '''
End Sub

Sub IShape_Zoom(ZoomFactor As Single)
  '''
End Sub
#+end_src

To access a secondary interface, declare a variable of such an interface type
and assign an object to it. To avoid constant declaration of interface
variables, define a =QI_MyInterface()= function to cast a variable object to
proper interface type.

#+begin_src vba
QI_IShape(rect).Move 10, 20

With QI_IShape(rect)
     .Move 10, 20
     .Zoom 1.2
End With
#+end_src

A class that implements a secondary interface comes with a secondary VTable
structure, which of course points to the procedures of that secondary interface.

** OLE Automation

Use as few 'dots' as possible and cache COM object references
to avoid expensive COM calls.

*** Late Binding Creation Of OLE Objects

Declare a variable to the =Object= type forces late binding call on that variable.

- =CreateObject()=

- =GetObject()=

* Database Programming

- ODBC
  + Most data access techniques in VB can use ODBC drivers as intermediate
    layers.
  + A connection may or may not use the configured DSN (either stored in the
    registry or in a file). An ODBC connection can
    be DSN-less with all connection details specified in the connection string.

- Data Access Object (DAO): an OO interface to Microsoft Jet (Access) and ODBC.

- Remote Data Object (RDO): improved upon DAO and designed around ODBC

- OLE DB: based on COM
  + the =MSDASQL= provider (Microsoft OLE DB Provider for ODBC): a bridge from
    OLE DB to ODBC drivers.
    - the default provider if not specified.

- ActiveX Data Object (ADO): the high-level interface to OLE DB

** ADO Programming

*** Object Model

The three core classes (=Connection=, =Command= and =RecordSet=) are not tightly
related.
Some of their functionalities overlap due to implicit use of the other types of
objects but only one specializes. =Connection= represents a physical
connection/session to the database, =Command= utilizes an =ActiveConnection= to
execute a database command (possibly a SQL command, be it a normal SQL text
statement, a stored procedure or something else). A =RecordSet= is a handle to
the result of a query, which can be modified/updated and propagated back to the
database.

**** =Connection=: =ADODB.Connection=

If no provider is specified in the connection string, =MSDASQL= is used which is the OLE DB provider
for ODBC drivers.

+ =.Open()=: open a connection

+ =.Execute()=

+ =.BeginTrans()=, =.CommitTrans()=, =.RollbackTrans()=

+ =.OpenSchema()=: for metadata

+ =.ConnectionTimeout=, =CommandTimeout=

**** =Command=

A command or query that can be executed on a data source.
+ =.CommandText=, =.CommandType=:  SQL command/query or the name of a table or
  the name of a stored procedure.

+ =.ActiveConnection=: associated DB connection.

+ =.Prepared=:

+ =.CommandTimeout=:

+ =.Execute() As RecordSet=: in case of an action, the returned =RecordSet= is closed.

+ =.CreateParameter() As Parameter=:

+ =Command.Parameters.Refresh()= can even retrieve provider-specific parameter
  information for a stored procedure.

+ =.NamedParameter=: may not be supported by a provider (e.g. Oracle, ODBC).

+ =.Name=: a command can have a name and then its associated
  =.ActiveConnection= can call this named command =conn.NamedCommandName= like
  a custom method.

**** =Parameter=

+ =.Name=, =.Type=, =.Precision=, =.NumericScale=: precision and numeric scale
  must be specified for =adNumeric= and =adDecimal=.

+ =.Value=: the default property of a parameter object

+ =.Direction=:

+ =.Size=: must be set for variable-length data type.

+ =.Attributes=: bit-field value

+ note that ODBC does not support named parameters except in stored procedures.

**** =RecordSet=

+ a =RecordSet= can be created independent of a certain =Connection= and can use a
  =Connection= explicitly or implicitly.

+ One can retrieve a =Recordset= from a database, close the connection,
  modify the data in the =Recordset=, and finally reestablish the connection
  to send all the updates to the server.

+ =.Source=: the name of the table, the SQL text, the SP name or the
  =CommandText= of a =Command=

+ =.Open()=, =.ActiveConnection=, =.ActiveCommand=

+ Cursor: a set of records that represent the results of query, may contain
  the actual data (client-side, for optimistic update) or just pointers to records in the database
  (forward-only server-side, better performance)
  + =.CursorLocation=: =2-adUseServer= or =3-adUseClient= (client-side cursor
    implementation provided by Microsoft Cursor Service for OLE DB)
  + =.CursorType=:
    + *dynamic* =adOpenDynamic=: able to view additions, changes and deletions by other users.
    + *keyset* =adOpenKeySet=: built from unique keys that identify the rows in the result
      set, which is used to access each row corresponding to each key.
      Records added by others are invisible and records deleted by
      others (or of which the key is changed by others) cannot be accessed;
      only changes of non-key values are still visible.
    + *static* =adOpenStatic= (client-side): a static copy of a set of records that display
      the result set as it was when the cursor was first opened, a snapshot. Additions, changes or
      deletions by other users are not visible.
    + *forward-only* =adOpenForwardOnly=: (default) =.MoveNext()= only; additions, changes or deletions by
      other users are not visible. *forward-only* cursors are *dynamic by
      default*, meaning any change is detected as the current row is processed.
    + use *forward-only* or =static* cursor to go through data; use *keyset*
      to select a few rows from a large result set; use *dynamic* to
      synchronize a result set with recent adds.
  + =.MoveFirst()=, =.MoveNext()=, =.Move()=, =MoveLast()=,
    =.MovePrevious()=: moving forward/backward
  + =.Bookmark=: get/restore where previously moved to, unique to a record set.
  + =PageSize=, =PageCount=, =AbsolutePage= (current page): paging functionality support

+ =.MaxRecords=: a limit to the number of records returned in the
    =RecordSet=

+ =.CacheSize=

+ *Update, Insertion, Delete*:
  - /Immediate Update/: =.Update()=, =.AddNew()=. A field is =.Update()=-ed
    when the record set moves to the next one;
  - /Batch Update/: =UpdateBatch=: batch update with =.AddNew()=, =.Update()=, =.Delete()=

+ =.Fields=: the field/column collection of the current record.
  + =.Count=, =.Item= (indexed by integers or column names)
  + a field may be =.Append= to the collection by the client code before a
    query is made.
  + Each field has a =.Name= and =.Value= (the current row value), =.Type=,
    =.Precision=, =.NumericScale=, =.DefinedSize=, =.ActualSize=

+ =.Requery=: refresh data result set with the same command

+ =.NextRecordset=: multiple result set support. A query may return multiple record sets just like a cursor
  may point to multiple rows after moving.

+ =.BOF= and =.EOF= to delineate the beginning and end of the dataset. Both
  combined, a record set can be determined empty or not in case =.RecordCount=
  is not reliable.

- =.Properties= of =Connection=, =RecordSet=, =Command=, =Field=: contains all the dynamic properties that the ADO provider has
  added to the built-in properties.


**** Transactions

- Concurrency control or *Locks*
  + =adLockReadOnly=: read-only
  + =adLockPessimistic=: pessimistic locking by locking records at the data
  source immediately before editing.
  + =adLockOptimistic=: optimistic locking by assuming no other user may change
  the data between the time of editing and committing and thus does not lock on
  the data source. If any modification is detected, the transaction is rolled back.
  + =adLockBatchOptimistic=:

- *Isolation levels*
  + =adXactChaos=: pending changes from more highly isolated transactions cannot
    be overwritten
  + =adXactBrowse=, =adXactReadUncommitted=: uncommitted changes from one transaction can be viewed in another
  + =adXactCursorStability=, =adXactReadCommitted=: changes from one transaction
    can only be viewed from another after committing the changes
  + =adXactIsolated=, =adXactSerializable=: transactions are conducted in
    isolation of other transactions.
  + =adXactRepeatableRead=: ReadUncommitted after requerying.

* GUI Programming

in VB6, controls can be classified into (1) /Standard Controls/, managed by the
Windows OS, and the (2) /Lightweight Controls/, handled by the VB runtime itself.

** Form Properties

- =Tag=: VB extender properties that is always available, no specific use,
  stores any object related to that control.

- =hWnd=: the internal handle used by Windows to identify a control, available
  only to standard Windows controls.

- =Enabled=, =Visible=: disabled controls don't react to user's actions.
  Invisible controls are automatically disabled. All mouse events for disabled or invisible controls are passed to the underlying container or to the form itself.

** Form Lifecycle

1. =Initialize=: triggered where variables are initialized; before the actual window and the
   controls are created

2. =Load=: triggered when properties and controls are referenced. The windows
   and its child controls are created. Graphical operations will not work.
   A form is visible after its =Show= method is called.

3. =Resize=: visible or sized changed

4. =Activate=: ready to accept user input

5. =Deactivate=: end user switches to another form

6. =Paint=: the form refreshes itself (fired only if =AutoRedraw= is =False=)

7. =QueryUnload=: =OnClosing=

#+begin_src vba
' refuse to unload
Private Sub Form_QueryUnload(Cancel As Integer, _
    UnloadMode As Integer)
    ' Don't let the user close this form.
    Select Case UnloadMode
        Case vbFormControlMenu, vbAppTaskManager
            Cancel = True
    End Select
End Sub
#+end_src

8. =Unload=: a last chance to prevent the closure of the form

#+begin_src vba
' This is a module-level variable.
Dim Saved As Boolean

Private Sub Form_Unload(Cancel As Integer)
    If Not Saved Then
        MsgBox "Please save data first!"
        Cancel = True
    End If
End Sub
#+end_src

9. =Terminate=: deallocate the memory for the Form

Forms expose a special property, the =Controls= collection, which contains all the controls that are currently loaded on the form itself.

** Form Events

- =Click=, =DblClick=: triggered not only by actual mouse clicks.

- =GetFocus=, =LostFocus=

- =Change=: its behavior is not consistent across VB controls. Not available for =CheckBox= and =OptionButton=, which fires a
  =Click= event when its content is changed.

- =KeyPress=, =KeyDown= (the key translated into ANSI numeric code), =KeyUp=: Only keys that correspond to control keys (Ctrl+x, BackSpace, Enter, and Escape) and printable characters activate the =KeyPress= event.

- =MouseDown=, =MouseUp=, =MouseMove=: mouse button state, Shift/Ctrl/Alt state
  and the cursor's location are passed.

** The =Controls= Collection

Container of all the controls currently loaded on the form itself.

* VBA and VB Operators & Libraries

** Numbers

- =/= always converts its operands into =Double=; Use =\= for pure integer
  division.

- =^=: exponentiation.

- =MOD= works only for integers.

- Common math functions are available: =Abs=, =Sgn=, =Sqr=, =Exp=, =Log=

- =Int=: round to the lower integer, a ceiling function; =Fix=: truncates the decimal part; =Round=
  to the specified number of digits and uses banker's rounding.

#+begin_src vba
Function Ceiling(number As Double) As Long
    Ceiling = -Int(-number)
End Functio
#+end_src

- =Val=; =Hex=, =Oct=

- =Randomize= sets the random seed; =Rnd= returns a the next random number
  between =[0, 1)=

** String Operations and Functions

Use the =$= version, they return a string instead of =Variant=.

- =&=: concatenation

- =Left$=, =Right$=, =Mid$=: substring; =Mid$= also returns a string slice,
  which can be assigned. =Mid$(Text, 3, 4) = "abcd";

- =Len=: string length;

- =LTrim$=, =RTrim$=, =Trim$=: discard unwanted trailing or leading blanks.

- =Asc=, =Chr$=: ASCII-string conversion

- =Space$=, =String$=: construct a string out of repeated characters.

- =StrComp=: case-insensitive string comparison

- =UCase$=, =LCase$=;

- =StrConv= multi-functionality string conversion
  + case conversion with =vbUpperCase=, =vbLowerCase=, =vbProperCase=
  + ANSI-Unicode conversion with =vbUnicode=, =vbFromUnicode=

- =Val=: string to decimal representation; locale-independent

- =CInt=, =CLng=, =CSng=, =CDbl=, =CCur=, =CDate=: locale-aware conversion from
  string

- =Str$=: converts a number into its representation, with a leading space if the
  number is positive.

- =InStr=, =InStrRev=: =IndexOf=, =IndexOfLast= substring position search

- =Like=: regex-like pattern matching =?= (any single character), =*= (zero or
  more), =#= (any single digit), =[A-Z]=, =[0-9]=

#+begin_src vba
value Like "[A-C]###"
value Like "[AEIOU][A-Z][A-Z]"
value Like "[!0-9]??*"
#+end_src

- =Replace=

- =strReverse=

- =Split=, =Join=

- =Filter=: return an array of items (not) containing a certain substring.

- =Format=: string format

** Date and Times

- Date literal =#8/15/1998 9:20:57 PM#=

- =DateSerial=, =TimeSerial=: may be used added together to create a DateTime

#+begin_src vba
Function IsLeapYear(year As Integer) As Boolean
    ' Are February 29 and March 1 different dates?
    IsLeapYear = DateSerial(year, 2, 29) <> DateSerial(year, 3, 1)
End Function
#+end_src

- =Date=, =Time=, =Timer= (subsecond precision) property: the current date and the current time.

- =Now=: the current date and time.

- =DateValue=, =TimeValue=: returns the Date/Time component of the argument.
  + =Year=, =Month=, =Day=, =Hour=, =Minute=, =Second= returns the corresponding
    component
  + =DatePart=

- =Weekday=: locale-dependent; Use =Weekday(arg, vbMonday)= to force locale independence.

- Date Arithmetic
  + =+=: =Now + 2 + #12:00#=
  + =DateAdd=, =DateDiff=: addition/difference with the specified time unit.

- Date Format
  + =Format=, =FormatDateTime=, =MonthName=: useless unless for human eyes.

#+begin_src vba
Public Function DateTimeAsISO8601(ByRef d As Date) As String
   DateTimeAsISO8601 = Format(d, "yyyy-mm-ddThh:nn:ss")
End Function
#+end_src

** Files

- =Name= (move); =Kill= (delete); =FileCopy=

- =GetAttr=, =SetAttr= [[https://learn.microsoft.com/en-us/windows/win32/fileio/file-attribute-constants][Windows File Attributes]], =FileLen=, =FileDateTime=

- =CurDir$=; =ChDrive=, =ChDir=: both commands must be used to change the
  current directory to another drive's.

- =MkDir=, =RmDir=; =Name= (rename only)

- =Dir=: iterate through files, something similar to C's =strtok= that maintains a global state.
#+begin_src vba
Function FileExists(filename As String) As Boolean
    On Error Resume Next
    FileExists = (Dir$(filename) <> "")
End Function

Function DirExists(path As String) As Boolean
    On Error Resume Next
    DirExists = (Dir$(path & "\nul") <> "") ' check for nul device
End Function

Function GetFiles(filespec As String, Optional Attributes As _
    VbFileAttribute) As String()
    Dim result() As String
    Dim filename As String, count As Long, path2 As String
    Const ALLOC_CHUNK = 50
    ReDim result(0 To ALLOC_CHUNK) As String
    filename = Dir$(filespec, Attributes)
    Do While Len(filename)
        count = count + 1
        If count > UBound(result) Then
            ' Resize the result array if necessary.
            ReDim Preserve result(0 To count + ALLOC_CHUNK) As String
        End If
        result(count) = filename
        ' Get ready for the next iteration.
        filename = Dir$
    Loop
    ' Trim the result array.
    ReDim Preserve result(0 To count) As String
    GetFiles = result
End Function
#+end_src

*** =FileSystemObject= : the OOP Way

- =FileExists()=, =DriveExists()=, =FolderExists()=

** Interoperation With the System

- =App=: the current app's
  + =ExeName=, =Path=
  + =PrevInstance=: if there's another instance already running

- =Shell=: asynchronously starts a process; returns the PID of the new process.

#+begin_src vba
Private Declare Function WaitForSingleObject Lib "kernel32" _
    (ByVal hHandle As Long, ByVal dwMilliseconds As Long) As Long
Private Declare Function OpenProcess Lib "kernel32" (ByVal dwAccess As _
    Long, ByVal fInherit As Integer, ByVal hObject As Long) As Long
Private Declare Function CloseHandle Lib "kernel32" _
    (ByVal hObject As Long) As Long

' Wait for a number of milliseconds, and return the running status of a
' process. If argument is omitted, wait until the process terminates.
Function WaitForProcess(taskId As Long, Optional msecs As Long = -1) _
    As Boolean
    Dim procHandle As Long
    ' Get the process handle.
    procHandle = OpenProcess(&H100000, True, taskId)
    ' Check for its signaled status; return to caller.
    WaitForProcess = WaitForSingleObject(procHandle, msecs) <> -1
    ' Close the handle.
    CloseHandle procHandle
End Function
#+end_src


** External Libaries

*** Microsoft Scripting Runtime

Windows-builtin COM library.

* .NET Interop and COM

**  Issues

- Somehow, VBA loads .NET 2-3.5 even if .NET 4 typelib is referenced. It needs a
  =appname.exe.config= with the following configuration.

  #+begin_src xml
  <configuration>
    <startup useLegacyV2RuntimeActivationPolicy="true">
      <supportedRuntime version="v4.0"/>
    </startup>
  </configuration>
  #+end_src

  See [[http://web.archive.org/web/20130128072944/http://www.marklio.com/marklio/PermaLink,guid,ecc34c3c-be44-4422-86b7-900900e451f9.aspx][What is useLegacyV2RuntimeActivationPolicy for?]]. This disables in-process
  side-by-side of different .NET versions and uses the specified version.

  #+begin_quote
  All these have a “single runtime per process” view of the world, so we try to
  make those codepaths believe they still exist in that world by “unifying” the
  version that they see.  After a given version has been chosen by one of these
  codepaths, that’s the version that all of them see for the remainder of the
  process lifetime.  Additionally, all of these activation paths had some kind of
  roll-forward semantics associated with them.
  #+end_quote

  This reason why by default .NET 2.0 is loaded is backward compatiblity:

  #+begin_quote
  We “cap” those semantics at v2,
  meaning by default none of these codepaths see v4 at all.  This allows us to
  claim that installing v4 is “non-impactful”.
  #+end_quote

- By default, .NET =ComVisible= types' generated class interfaces derive from =IDispatch=
  + Exposed .NET interfaces are by default dual unless overriden by =InterfaceTypeAttribute=;

- =System.Object= has a default property =ToString=

- [[https://learn.microsoft.com/en-us/visualstudio/code-quality/ca1402?view=vs-2022&tabs=csharp][Method overloading]]

- [[https://marc.info/?l=ms-dcom&m=103440425612266&w=2][IUnknown Support]]
  + VBA supports holding an =IUnknown= pointer with =Variant= (=vbDataObject=)
  + =CreateObject= can return an =IUnknown= pointer to a =Variant= variable.
  + These pointers are not of much use except for passing around.

** Useful =mscorlib= classes

- =System.Random=.

- =System.Type= is returned as =mscorlib.[_Type]=

- =ArrayList=, =Queue=, =HashTable=, =Stack=, =SortedList=
  + - =For Each ... Next= works as long as the object variable is an
    =IEnumerable=. The enumerating element has to be a =Variant= as
    =System.Collections.IEnumerator= is marshaled as =IEnumVARIANT=,
    see [[https://learn.microsoft.com/en-us/dotnet/standard/native-interop/type-marshalling][Type Marshaling]].

- Various =*Calendar=

- =UTF8Encoding=, =ASCIIEncoding=

- =StringBuilder= works but overloading makes it hard to find the correct method name.

- Various crytographic classes

* Unicode

VB strings are UTF-16 strings but VB lacks proper Unicode support due to many
API design flaws and tooling problems.

** Some APIs Would Convert VB Unicode Strings to ANSI

*** Controls

The builtin controls are an example. *After the conversion*, the =Font.Charset= property determines the
charset used by the runtime to interpret the ANSI bytes.

Its =PropertyBag= (the Properties window on the screen) is in ANSI mode.

**** Solutions

- Use other control libraries such as Microsoft Forms 2.0 (downloadable)

** The IDE itself does not recognize Unicode Literals

not even UTF-16 and rejects BOM at the beginning of a source file.

*** Solutions

- A workaround is to encode every UTF-16 code units as =ChrW(codepoint)=.
  The only ultimate savior is probably UTF-8 as a locale since Windows 10.

- Save Unicode text externally in a database or in a file and load it in the code.

* P-Code, Compiler, Linker and Optimization[cite:@vbMinutiae]
:PROPERTIES:
:ID:       16923a7f-e53a-400f-ab29-4e6c954e7333
:END:

** P-Code (PseudoCode)[cite:@MSPCodeTech]

The name p-code was common before Java's bytecode and used in Pascal,

A RISC-like stack machine instruction.
An intermediate step between the high-level instructions in VB programs and the
low-level machine code. The sizes of P-code executables are smaller by 50 percent than that of
native compilation and the process of compilation is much faster.

MS P-code was made to reduce the size of programs. It can be applied globally to
the program or a certain functions. From a systemic view, the final result may
not be as slow as imagined. [[https://en-academic.com/dic.nsf/enwiki/464666][Historically]], both MSVC and VB supported P-code generation.

There are some VB P-Code dissemblers available: [[https://github.com/bontchev/pcodedmp][pcodedmp]], [[https://github.com/bontchev/pcodedmp][pcode2code]].

** Code Generation and =C2.EXE=

=C2.EXE= is the backend code generator for VB6, invoked by =VB6.EXE= (which does
some preprocessing before generating native code).

By hooking a logger program (printing all the arguments and then invoking the
real =C2.EXE=), the command line arguments of invoking =C2.EXE= can be dumped.
=C2.EXE= is a modified version of =C2.EXE= used in VC++ 6.

#+begin_src shell
C2.EXE
-il C:\DOCUME~1\Admin\LOCALS~1\Temp\VB886942 # undocumented, used for C programs as well
-f Program.bas
-W 3
-Gy
-G5
-Gs4096
-dos # undocumented, used for C programs as well
-Zl
-Fo Program.OBJ
-Zi
-QIfdiv
-ML
-basic # visual basic, undocumented
#+end_src

** Linking

Only =VBAEXE6.LIB= is linked against. COM references are resolved at runtime.

#+begin_src shell
LINK
Program.OBJ
Console.OBJ
ConsoleApp.OBJ
C:\Program Files\Microsoft Visual Studio\VB98\VBAEXE6.LIB
/ENTRY:__vbaS
/OUT:ConsoleApp.exe
/BASE:0x400000
/SUBSYSTEM:WINDOWS,4.0
/VERSION:1.0
/DEBUG
/DEBUGTYPE:CV
/INCREMENTAL:NO
/OPT:REF
/MERGE:.rdata=.text
/IGNORE:4078
#+end_src



* Bibliography

These days, [[https://learn.microsoft.com/en-us/openspecs/microsoft_general_purpose_programming_languages/ms-vbal/d5418146-0bd2-45eb-9c7a-fd9502722c74][VBA Language Specification]] from Microsoft should be regarded as the ultimate reference.

#+print_bibliography:
