#+TITLE: Nim Basics

#+begin_src shell
nim c -r nim_file.nim arg1 arg2
#+end_src

* Basic Types

- =bool=: =not=, =and=, =or=, =xor=, =<=, ~<=~, =>=, ~>=~, ~==~. =and= and =or= performs short circuit evaluation.

- =char=: one byte

- integers: =int=, =uint=, =(u)int8=, =(u)int16=, =(u)int32=, =(u)int64=
  + =0'i8=, =0'i32=, =0'u=. =int= has the same size as a pointer.
  + =shl=, =shr=
  + bit shifting operators always treat their arguments as unsigned.
  + unsigned integers wrap around and never over- or underflow.

- floating-point, =float= (currently always 64-bit), =flaot32=, =float64=
  + =0.0'f32=, =0.0'f64=

- =r"C:\Program Files\nim"=: raw string literal
  + ="""..."""=: multiline string literal

- =#[Documentation comment]#=: allowed only in a few places as they belong to the syntax tree!

- =1_000_000=, =1.0e9=, =0xFF=, =0b1001=, =0o123=

- =var=: global/local variable

 #+begin_src nim
var
  x, y: int
  # a comment can occur here too
  a, b, c: string
 #+end_src

- =const=: compile-time constant

- =let=: declares single assignment variable (=final= in Java)

- =repr()=: the internal type representation, for debugging

* Advanced Types

** Enumerations

#+begin_src nim
type
  Direction = enum
    north, east, south, west
#+end_src

** Ordinal Types

Enumerations, integers, =char=, =bool=, subranges.

- =ord(x)=

- =inc(x)=, =inc(x, n)=, =dec(x)=, =dec(x, n)=

- =succ(x)=, =succ(x, n)=, =pred(x)=, =pred(x, n)=

*** Subranges

A range of values from an integer or enumeration type.

*** Sets

Sets of an ordinal type, implemented as a high performance bit vectors, often used to define a type for the flags of a procedure.

*** Bit fields

Enum, sets and casting can used together

#+begin_src nim
type
  MyFlag* { .size: sizeof(cint). } = enum
    A
    B
    C
    D
  MyFlags = set[MyFlag]
#+end_src

** Array

- Value type, not a pointer to a region of memory

- Array access is bounds checked (at compile-time or at runtime) by default.

- Array indices are specified by users (do not always starts at zero).

More like C# arrays

*** Open Array

Array type used in typing with variable sizes, compatible with arrays and sequences.

** Sequence

Resizable array

#+begin_src nim
var x: seq[int]
x = @[1, 2, 3, 4, 5]
#+end_src

** Varargs

=varargs=

#+begin_src nim
proc myWriteln(f: File, a: varargs[string, `$`]) =
  for s in items(a):
    write(f, s)
  write(f, "\n")
#+end_src

** Slices

An object of type =Slice= which contains two bounds.

** Objects

Value type, record type.

#+begin_src nim
type
  Person = object
    name: string
    age: int
#+end_src

** Tuples

Tuple types are structurally typed: different tuple-types are equivalent if they specify fields of the same type and of the same name in the same order. Tuples created with different field names will be considered different objects despite having the same field types

#+begin_src nim
type
  Person = tuple
    name: string
    age: int

PersonY = (string, int)
#+end_src

** References =ref= and Pointers =ptr= (Untraced by GC)

#+begin_src nim
type
  Node = ref object
    le, ri: Node
    data: int

var n = Node(data: 9)
new(n)
n = nil
#+end_src

** Procedural Type

Basically a delegate or function pointer type

* Iterators

- =1 .. 10=, =countup(1, 10)= (full closed):

- =countdown(10, 1)=

- =1 ..< 10=,

- =.. ^n=: to the the last n-th element

- =.items=, =.mitems= immutable/mutable elements

- =.pairs=, =.mpairs=: element and its index number

#+begin_src nim
iterator countup(a, b: int): int =
  var res = a
  while res <= b:
    yield res     # can only called from a loop
    inc(res)
#+end_src


* Control Flow

- Python-style if-elif-else, while, for loop with iterators

#+begin_src nim
case name
of "":
    ...
of "name":
    ...
of "Dave", "Frank":
    ...
else:
    echo "Hi, ", name
#+end_src

- when-elif-else: compile-time if

* Scope

=block= statement with label to create a scope

* Indentation

#+begin_src nim
if x: x = false

const fac4 = (var x = 1; for i in 1..4: x *= i; x)
#+end_src

Like Python, Expressions can contain indentation at certain places for better readability: indentation within expressions is allowed after operators, an open parenthesis and after commas.

With parenthesis and semicolons (;) you can use statements where only an expression is allowed

* Declaration

Variables, procedures needs to be declared before it can be used.

* Procedure

#+begin_src nim
proc yes(arg1: argType1): returnType =
    ...
#+end_src

A procedure that returns a value has an implicit variable =result= as its return value,
initialized with its default value. A procedure that does not have any return statement and does not use the special =result= variable returns the value of its last expression.

A parameter with =var= in its type is passed by reference.

=discard= before a procedure to discard the return value.

Nim procedures supports named arguments, default parameter values and overloading.

Operator overloading is also supported. =``= notation is used to call operators like a normal procedure.

* Modules

Each module is in its own file. Modules enable information hiding and separate compilation.

- Only top-level symbols marked with =*= are exported.

- A module's top-level statements are executed at the start of the program.

- Each module has a special magic constant =isMainModule= if the module is compiled
  as the main file.

- =import mymodule except y= excludes certain symbols.

- =from mymodule import x, y, z=

- =from mymodule (as m) import nil=: =m.x()=

- =include= C-style =#include=
